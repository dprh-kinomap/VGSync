import os
import sys
import shutil
import subprocess

base_dir = os.path.dirname(os.path.abspath(__file__))

import path_manager
path_manager.ensure_mpv_library(parent_widget=None, base_dir=base_dir)




import urllib.request
import datetime
import config
import fingerprint_collect
import path_manager
import platform

config.clear_temp_directories()  # Jetzt wird die Funktion nur beim Start von `app.py` aufgerufen

## das ist für die map:
os.environ["QSG_RHI_BACKEND"] = "opengl"

from PySide6.QtWidgets import (
    QApplication, QDialog, QMessageBox, QWidget, QSystemTrayIcon
)
from PySide6.QtCore import Qt
from PySide6.QtGui import QGuiApplication, QIcon
from config import LOCAL_VERSION  # <= wir lesen die Version aus config

# Für JSON-Parsing und NTP:
import json
import ntplib
from datetime import datetime as dt, timezone

CHECK_URL = "http://vgsync.casa-eller.de/project/check.php?token=SUPER_SECRET_123"

from config import (
    TMP_KEYFRAME_DIR,
    MY_GLOBAL_TMP_DIR,
    is_disclaimer_accepted,
    set_disclaimer_accepted
)
from views.disclaimer_dialog import DisclaimerDialog
#from views.start_dialog import StartDialog
from views.mainwindow import MainWindow

from config import LOCAL_VERSION

PHP_TIME_API_URL = "http://vgsync.casa-eller.de/project/timeserver.php"
NTP_SERVERS = [
    "pool.ntp.org",
    "time.windows.com",
    "time.cloudflare.com",
    "time.google.com",
    "time.nist.gov"
]

def _fetch_time_from_php(url):
    print(f"[DEBUG] Trying primary HTTP timeserver (PHP): {url}")
    with urllib.request.urlopen(url, timeout=10) as response:
        data = json.loads(response.read().decode("utf-8"))
    dt_str = data["datetime"]  
    dt_obj = dt.fromisoformat(dt_str.replace("Z", "+00:00"))
    date_only = dt_obj.date()
    print(f"[DEBUG] PHP timeserver succeeded! Date is: {date_only}")
    return date_only

def _fetch_time_from_ntp(server_list):
    c = ntplib.NTPClient()
    last_error = None
    for server in server_list:
        print(f"[DEBUG] Trying NTP server: {server}")
        try:
            response = c.request(server, version=3)
            dt_utc = dt.fromtimestamp(response.tx_time, tz=timezone.utc)
            date_only = dt_utc.date()
            print(f"[DEBUG] NTP server succeeded! UTC time: {dt_utc.isoformat()}")
            return date_only
        except Exception as e:
            print(f"[WARN] NTP server failed ({server}): {e}")
            last_error = e
    raise RuntimeError(f"All NTP servers failed, last error: {last_error}")

def get_server_date():
    try:
        return _fetch_time_from_php(PHP_TIME_API_URL)
    except Exception as e:
        print(f"[WARN] Primary HTTP timeserver failed ({PHP_TIME_API_URL}): {e}")
    try:
        return _fetch_time_from_ntp(NTP_SERVERS)
    except Exception as e:
        print(f"[WARN] NTP fallback also failed: {e}")
        raise RuntimeError("No external timeserver available - Abbruch!")

def check_version_on_server():
    try:
        data_bytes = urllib.request.urlopen(CHECK_URL, timeout=10).read()
    except Exception as e:
        return (False, f"Server not reachable: {e}", "")

    lines = data_bytes.decode("utf-8", errors="replace").splitlines()

    for line in lines:
        line = line.strip()
        if not line or line.startswith("#"):
            continue

        parts = [p.strip() for p in line.split(";")]
        if len(parts) < 3:
            continue

        version_str, status_str, expiry_str = parts[0], parts[1], parts[2]

        if version_str == LOCAL_VERSION:
            if status_str.upper() == "DISABLE":
                return (False, f"Version {LOCAL_VERSION} is deactivated!", expiry_str)

            try:
                today = get_server_date()
            except RuntimeError as err:
                return (False, f"Timeserver-Fehler: {err}", "")

            try:
                dt_expire = datetime.datetime.strptime(expiry_str, "%Y-%m-%d").date()
            except ValueError:
                return (False, f"Invalid date '{expiry_str}' in versioninfo.txt", expiry_str)

            if today > dt_expire:
                return (False, f"Version {LOCAL_VERSION} is expired (Deadline: {expiry_str})", expiry_str)

            return (True, "", expiry_str)

    return (False, f"Version {LOCAL_VERSION} expired! Please install a valid Version!", "")

def clear_temp_segments_dir():
    if os.path.exists(MY_GLOBAL_TMP_DIR):
        try:
            shutil.rmtree(MY_GLOBAL_TMP_DIR)
        except Exception as e:
            print(f"[WARN] Could not remove temp directory: {e}")
    os.makedirs(MY_GLOBAL_TMP_DIR, exist_ok=True)
    
    
def center_mainwindow(window):
    frame_geo = window.frameGeometry()
    center_point = window.screen().availableGeometry().center()
    frame_geo.moveCenter(center_point)
    window.move(frame_geo.topLeft())

def check_ffmpeg_and_vlc_or_exit():
    import shutil
    ffmpeg_path = shutil.which("ffmpeg")
    vlc_path    = shutil.which("vlc")

    if not ffmpeg_path or not os.path.exists(ffmpeg_path):
        return False, "ffmpeg"
   
    return True, ""

def main():
    QGuiApplication.setAttribute(Qt.AA_UseSoftwareOpenGL)
    app = QApplication(sys.argv)
    parent = QWidget()
    parent.hide()
    
    system = platform.system()
    if system == "Windows":
        icon_path = os.path.join(base_dir, "icon", "icon_icon.ico")
        app.setWindowIcon(QIcon(icon_path))  # Taskbar Icon
        trayIcon = QSystemTrayIcon(QIcon(icon_path), parent=None)
        trayIcon.show()
    
    
    new_version_started = config.check_app_version_and_reset_if_necessary()
    if new_version_started:
        QMessageBox.warning(
            None, 
            "New Version Detected",
            f"A new version ({config.APP_VERSION}) was launched. "
            "All your previous settings have been reset."
        )

    # 2) Lokale Lizenz nur prüfen, WENN wir NICHT im "Nur Server-Check"-Modus sind
    if not config.SERVER_VERSION_CHECK_ONLY:
        # (A) Falls konfiguriert -> Fingerprint-Check
        if config.FINGERPRINT_CHECK_ENABLED:
            local_fp = fingerprint_collect.get_fingerprint_universal()
            if local_fp != config.HARDCODED_FINGERPRINT:
                QMessageBox.warning(None, "Demo Mode",
                    "Warning: You are running in DEMO mode, because the license\n"
                    "does not match this PC! The 'Save Buttons' function will be disabled."
                )
                config.DEMO_MODE = True
                

    else:
        # (B) Nur Server-Check-Modus!
        # => keine lokale license.lic - wir gehen direkt weiter
        # => Und wir können optional hier DEMO_MODE auf False erzwingen,
        #    damit wir auf keinen Fall im Demo-Modus sind, wenn nur der Server okay sagt
        config.DEMO_MODE = False
       

    # 3) SERVER-Versions-Check
    ok, msg, expiry_str = check_version_on_server()
    if not ok:
        QMessageBox.critical(None, "Version gesperrt oder abgelaufen", msg)
        sys.exit(1)

    config.EXPIRE_DATE = expiry_str

    # ffmpeg sicherstellen (bzw. Path-Manager check)
    if not path_manager.ensure_ffmpeg(parent):
        QMessageBox.critical(parent, "Missing FFmpeg", "Cannot proceed without FFmpeg.")
        sys.exit(1)
    print("[DEBUG] After ensure_ffmpeg =>", shutil.which("ffmpeg"))
    ok, msg, expiry_str = check_version_on_server()
    if not ok:
        QMessageBox.critical(None, "Version gesperrt oder abgelaufen", msg)
        sys.exit(1)
        
    config.EXPIRE_DATE = expiry_str    

    # Zusätzlicher Check ffmpeg & VLC
    parent_widget = QWidget()
    parent_widget.hide()

    ok2, missing = check_ffmpeg_and_vlc_or_exit()
    if not ok2:
        msg_box = QMessageBox(parent_widget)
        msg_box.setIcon(QMessageBox.Warning)
        msg_box.setWindowTitle("Missing Dependency")
        msg_box.setText(
            f"Could not find '{missing}'!\n"
            "Please install it (or provide it) and restart the program.\n\n"
            "Be sure it's in your PATH-Variable."
        )
        msg_box.setStandardButtons(QMessageBox.Ok)
        msg_box.exec()
        sys.exit(0)

    if not is_disclaimer_accepted():
        dlg_disclaimer = DisclaimerDialog()
        dlg_disclaimer.show()
        app.processEvents()
        dlg_disclaimer.raise_()
        dlg_disclaimer.activateWindow()

        result = dlg_disclaimer.exec()
        if result == QDialog.Accepted:
            set_disclaimer_accepted()
        else:
            sys.exit(0)

    clear_temp_segments_dir()

    user_wants_editing = False
    
    if user_wants_editing:
        if os.path.exists(TMP_KEYFRAME_DIR):
            shutil.rmtree(TMP_KEYFRAME_DIR)
        os.makedirs(TMP_KEYFRAME_DIR, exist_ok=True)

    window = MainWindow(user_wants_editing=user_wants_editing)

    screen = app.primaryScreen()
    geometry = screen.availableGeometry()
    
   
    target_ratio = 16 / 9
    screen_ratio = geometry.width() / geometry.height()

    # Lege fest, ob die Breite oder die Höhe das 'limitierende' Maß ist.
    # Wir nehmen hier z.B. 90% vom verfügbaren Platz.
    # Wenn du stattdessen 95% möchtest, ändere einfach die 0.9 auf 0.95.
    if screen_ratio >= target_ratio:
        # Bildschirm ist eher breit => Höhe bestimmt unsere Fenstergröße
        new_height = int(geometry.height() * 0.9)
        new_width  = int(new_height * target_ratio)
    else:
        # Bildschirm ist schmal => Breite bestimmt unsere Fenstergröße
        new_width  = int(geometry.width() * 0.9)
        new_height = int(new_width / target_ratio)

    window.resize(new_width, new_height)
    

    window.show()
    app.processEvents()
    center_mainwindow(window)
    window.raise_()
    window.activateWindow()

    sys.exit(app.exec())

if __name__ == "__main__":
    main()

```
import os
import sys
import platform
import subprocess
import shutil
import stat
import importlib.util

BASE_DIR = os.path.dirname(os.path.abspath(__file__))

# Pfade anpassen, falls deine Projektstruktur anders aussieht
LOCAL_FFMPEG = os.path.join(BASE_DIR, "ffmpeg")  # erwartet ffmpeg/bin darin
LOCAL_MPV    = os.path.join(BASE_DIR, "mpv")     # erwartet mpv/lib darin

EXTRA_FILES = [
    "map_page.html",
    "ol.js",
    "ol.css",
]

EXTRA_FOLDERS = [
    "icon",  # Icon-Ordner hinzufügen
    "doc",   # <-- Neu dazu, damit PDF und evtl. weitere Dateien kopiert werden
]

def load_app_version():
    """
    Lädt config.py dynamisch und liest daraus die Variable APP_VERSION.
    Erwartet: config.py im selben Verzeichnis wie dieses Skript.
    """
    config_path = os.path.join(BASE_DIR, "config.py")
    if not os.path.isfile(config_path):
        print("[ERROR] config.py nicht gefunden! Bitte sicherstellen, dass config.py existiert.")
        sys.exit(1)

    # Dynamisch das config-Modul laden
    spec = importlib.util.spec_from_file_location("config", config_path)
    config_module = importlib.util.module_from_spec(spec)
    spec.loader.exec_module(config_module)

    # Prüfen, ob APP_VERSION in config vorhanden ist
    if not hasattr(config_module, "APP_VERSION"):
        print("[ERROR] In config.py wurde keine Variable APP_VERSION gefunden!")
        sys.exit(1)

    return config_module.APP_VERSION

def run_cmd(cmd_list):
    print("[RUN]", " ".join(cmd_list))
    subprocess.check_call(cmd_list)

def copy_tree_all(src_dir, dst_dir):
    """Kopiert rekursiv alle Dateien und Verzeichnisse von src_dir nach dst_dir."""
    if not os.path.isdir(src_dir):
        print("[WARN] Quellverzeichnis fehlt:", src_dir)
        return
    os.makedirs(dst_dir, exist_ok=True)
    for root, dirs, files in os.walk(src_dir):
        rel = os.path.relpath(root, src_dir)
        tgt_sub = os.path.join(dst_dir, rel)
        os.makedirs(tgt_sub, exist_ok=True)
        for f in files:
            sfile = os.path.join(root, f)
            dfile = os.path.join(tgt_sub, f)
            print("[COPY]", sfile, "->", dfile)
            shutil.copy2(sfile, dfile)

def build_windows():
    # Zuerst Versionsstring laden
    app_version = load_app_version()
    print(f"[INFO] Gefundene APP_VERSION: {app_version}")

    print("[INFO] Nuitka-Build für Windows")
    cmd = [
        sys.executable, "-m", "nuitka",
        "--standalone",
        "--enable-plugin=pyside6",
        "--windows-icon-from-ico=icon_icon.ico",  # Anpassen oder entfernen, wenn kein Icon
        "--output-dir=dist",
        "app.py"
    ]
    run_cmd(cmd)

    # Nuitka legt app.exe evtl. in dist\app.exe ODER dist\app.dist\app.exe ab
    exe_candidates = [
        os.path.join("dist", "app.exe"),
        os.path.join("dist", "app.dist", "app.exe"),
    ]
    exe_path = None
    for c in exe_candidates:
        if os.path.isfile(c):
            exe_path = c
            break
    if not exe_path:
        raise RuntimeError("app.exe nicht gefunden. Prüfe Nuitka-Ausgabe in dist.")

    # Zielordner wird aus der Version gebildet, z.B. "VGSync_1.2.3"
    target_dirname = f"VGSync_{app_version}"
    target_dir = os.path.join("dist", target_dirname)
    os.makedirs(target_dir, exist_ok=True)

    # Verschieben der EXE nach VGSync_<APP_VERSION>
    # Du kannst die EXE-Datei auch umbenennen, wenn gewünscht (z.B. "VGSync.exe").
    shutil.move(exe_path, os.path.join(target_dir, "VGSync.exe"))

    # Falls Nuitka ein dist\app.dist-Verzeichnis angelegt hat, dessen Inhalt nach VGSync_<APP_VERSION> kopieren
    app_dist_dir = os.path.join("dist", "app.dist")
    if os.path.isdir(app_dist_dir):
        for item in os.listdir(app_dist_dir):
            s = os.path.join(app_dist_dir, item)
            d = os.path.join(target_dir, item)
            if os.path.isdir(s):
                shutil.copytree(s, d)
            else:
                shutil.copy2(s, d)

    # --- ffmpeg kopieren ---
    # Beispiel: ffmpeg/bin in VGSync_<APP_VERSION>\ffmpeg\bin
    ffmpeg_bin_dir = os.path.join(target_dir, "ffmpeg", "bin")
    src_ffmpeg_bin = os.path.join(LOCAL_FFMPEG, "bin")  # ggf. anpassen
    copy_tree_all(src_ffmpeg_bin, ffmpeg_bin_dir)

    # --- mpv kopieren ---
    # Beispiel: mpv/lib in VGSync_<APP_VERSION>\mpv\lib
    mpv_lib_dir = os.path.join(target_dir, "mpv", "lib")
    src_mpv_lib = os.path.join(LOCAL_MPV, "lib")  # ggf. anpassen
    copy_tree_all(src_mpv_lib, mpv_lib_dir)

    # Extra-Dateien kopieren
    for f in EXTRA_FILES:
        src_f = os.path.join(BASE_DIR, f)
        if os.path.isfile(src_f):
            shutil.copy2(src_f, target_dir)
            print("[EXTRA]", f, "->", target_dir)
        else:
            print("[WARN] Datei fehlt:", f)
            
    for folder in EXTRA_FOLDERS:
        src_folder = os.path.join(BASE_DIR, folder)
        dst_folder = os.path.join(target_dir, folder)
        copy_tree_all(src_folder, dst_folder)        

    print(f"[INFO] Windows-Build fertig => dist/{target_dirname}/")

def main():
    s = platform.system()
    if s == "Windows":
        build_windows()
    else:
        print("[WARN]", s, "nicht unterstützt.")
        sys.exit(1)

if __name__ == "__main__":
    main()

```
import os
import sys
import platform
import subprocess
import shutil
import importlib.util

BASE_DIR = os.path.dirname(os.path.abspath(__file__))

LOCAL_FFMPEG = os.path.join(BASE_DIR, "ffmpeg")  # erwartet ffmpeg/bin
LOCAL_MPV    = os.path.join(BASE_DIR, "mpv")     # erwartet mpv/lib

EXTRA_FILES = [
    "map_page.html",
    "ol.js",
    "ol.css",
]

EXTRA_FOLDERS = [
    "icon",
    "doc",
]

def load_app_version():
    """
    Lädt config.py dynamisch und liest daraus die Variable APP_VERSION.
    Erwartet: config.py im selben Verzeichnis wie dieses Skript.
    """
    config_path = os.path.join(BASE_DIR, "config.py")
    if not os.path.isfile(config_path):
        print("[ERROR] config.py nicht gefunden! Bitte sicherstellen, dass config.py existiert.")
        sys.exit(1)

    spec = importlib.util.spec_from_file_location("config", config_path)
    config_module = importlib.util.module_from_spec(spec)
    spec.loader.exec_module(config_module)

    if not hasattr(config_module, "APP_VERSION"):
        print("[ERROR] In config.py wurde keine Variable APP_VERSION gefunden!")
        sys.exit(1)

    return config_module.APP_VERSION

def run_cmd(cmd_list):
    print("[RUN]", " ".join(cmd_list))
    subprocess.check_call(cmd_list)

def copy_tree_all(src_dir, dst_dir):
    """Kopiert rekursiv alle Dateien und Verzeichnisse von src_dir nach dst_dir."""
    if not os.path.isdir(src_dir):
        print("[WARN] Quellverzeichnis fehlt:", src_dir)
        return
    os.makedirs(dst_dir, exist_ok=True)
    for root, dirs, files in os.walk(src_dir):
        rel = os.path.relpath(root, src_dir)
        tgt_sub = os.path.join(dst_dir, rel)
        os.makedirs(tgt_sub, exist_ok=True)
        for f in files:
            sfile = os.path.join(root, f)
            dfile = os.path.join(tgt_sub, f)
            print("[COPY]", sfile, "->", dfile)
            shutil.copy2(sfile, dfile)

def build_windows():
    # Versionsstring laden
    app_version = load_app_version()
    print(f"[INFO] Gefundene APP_VERSION: {app_version}")

    print("[INFO] PyInstaller-Build für Windows")

    # Name des Ausgabe-Unterordners / EXE
    exe_name = "app"

    # Pfad zu ffmpeg/bin/*.*
    ffmpeg_bin_glob = os.path.join(LOCAL_FFMPEG, "bin", "*.*")
    # Pfad zu mpv/lib/*.*
    mpv_lib_glob    = os.path.join(LOCAL_MPV,    "lib", "*.*")

    # PyInstaller-Befehl
    # Hier: --add-binary sorgt dafür, dass alle Dateien (DLL, EXE ...) aus ffmpeg/bin und mpv/lib
    # direkt in das gleiche Verzeichnis wie app.exe kopiert werden. So kann Windows sie sofort laden.
    cmd = [
        sys.executable, "-m", "PyInstaller",
        "--noconfirm",
        "--onedir",
        f"--name={exe_name}",
        "--icon=icon_icon.ico",  # ggf. anpassen/entfernen
        "--add-binary", f"{ffmpeg_bin_glob};.",  # alles aus ffmpeg/bin in Hauptordner
        "--add-binary", f"{mpv_lib_glob};.",     # alles aus mpv/lib in Hauptordner
        "app.py"
    ]
    run_cmd(cmd)

    # PyInstaller legt exe hierhin: dist/app/app.exe
    exe_path = os.path.join("dist", exe_name, f"{exe_name}.exe")
    if not os.path.isfile(exe_path):
        raise RuntimeError(f"{exe_name}.exe nicht gefunden. Prüfe PyInstaller-Ausgabe in dist/{exe_name}.")

    # Zielordner = VGSync_<APP_VERSION>
    target_dirname = f"VGSync_{app_version}"
    target_dir = os.path.join("dist", target_dirname)
    os.makedirs(target_dir, exist_ok=True)

    # EXE umbenennen
    new_exe_path = os.path.join(target_dir, "VGSync.exe")
    shutil.move(exe_path, new_exe_path)

    # Restliche Dateien aus dist/app nach dist/VGSync_<APP_VERSION> kopieren
    app_dist_dir = os.path.join("dist", exe_name)
    for item in os.listdir(app_dist_dir):
        src_item = os.path.join(app_dist_dir, item)
        dst_item = os.path.join(target_dir, item)
        if os.path.basename(src_item) == f"{exe_name}.exe":
            # Die Original-exe ist bereits verschoben
            continue

        if os.path.isdir(src_item):
            shutil.copytree(src_item, dst_item)
        else:
            shutil.copy2(src_item, dst_item)

    # Extra-Dateien ins Ziel kopieren
    for f in EXTRA_FILES:
        src_f = os.path.join(BASE_DIR, f)
        if os.path.isfile(src_f):
            shutil.copy2(src_f, target_dir)
            print("[EXTRA]", f, "->", target_dir)
        else:
            print("[WARN] Datei fehlt:", f)

    # Extra-Ordner ins Ziel kopieren
    for folder in EXTRA_FOLDERS:
        src_folder = os.path.join(BASE_DIR, folder)
        dst_folder = os.path.join(target_dir, folder)
        copy_tree_all(src_folder, dst_folder)

    print(f"[INFO] Windows-Build fertig => dist/{target_dirname}/")

def main():
    s = platform.system()
    if s == "Windows":
        build_windows()
    else:
        print("[WARN]", s, "nicht unterstützt.")
        sys.exit(1)

if __name__ == "__main__":
    main()

```
# config.py

import os
import sys
import platform
import tempfile
import shutil
from PySide6.QtCore import QSettings

from license_check import load_license  # <-- dein cryptography-basiertes Script


##############################################################################
# 1) Versions-Konfiguration & Modus
##############################################################################

APP_VERSION = "3.242"

# Falls du nur über den Server prüfen willst, ob diese APP_VERSION freigegeben ist,
# setze das hier auf True.
# => Dann wird KEINE license.lic geladen (egal ob vorhanden).
SERVER_VERSION_CHECK_ONLY = False

##############################################################################
# 2) Hilfsfunktionen/Pfade
##############################################################################

def _get_app_base_dir() -> str:
    """
    Gibt den Verzeichnis-Pfad zurück, in dem deine *laufende* Executable liegt.
    Unterscheidet dabei nach Betriebssystem:
    
    - Windows OneFile => sys._MEIPASS
    - Windows OneFolder => sys._MEIPASS oder sys.executable
    - macOS => sys.executable
    - Linux => sys.executable
    - normaler Python => __file__
    """
    if getattr(sys, 'frozen', False):
        # Gefrorene App (PyInstaller, Nuitka, etc.)
        current_system = platform.system()
        if current_system == 'Windows':
            if hasattr(sys, '_MEIPASS'):
                return sys._MEIPASS
            else:
                return os.path.dirname(sys.executable)
        elif current_system == 'Darwin':  # macOS
            return os.path.dirname(sys.executable)
        else:
            return os.path.dirname(sys.executable)
    else:
        return os.path.dirname(os.path.abspath(__file__))


def _get_license_path() -> str:
    """
    Baut den Pfad zu 'license.lic' auf, basierend auf dem von _get_app_base_dir().
    """
    base_dir = _get_app_base_dir()
    return os.path.join(base_dir, "license.lic")


##############################################################################
# 3) Globale Variablen & Defaults
##############################################################################

# Ob wir einen Lizenz-Fingerprint abgleichen sollen (alter Mechanismus).
FINGERPRINT_CHECK_ENABLED = True

# Zum Umschalten ins Demo-Mode.
DEMO_MODE = False  # Wird ggf. im Hauptprogramm oder hier auf True gesetzt.

# Temp-Ordner
base_temp = tempfile.gettempdir()
TMP_KEYFRAME_DIR = os.path.join(base_temp, "my_vgsync_keyframes")
MY_GLOBAL_TMP_DIR = os.path.join(base_temp, "my_cut_segments_global")

LICENSE_FILE = _get_license_path()

HARDCODED_FINGERPRINT = ""
LOCAL_VERSION = ""
REGISTERED_NAME = ""
REGISTERED_EMAIL = ""

##############################################################################
# 4) Lizenz-Daten laden oder ignorieren - inkl. Demo-Fallback
##############################################################################

def _init_license_data():
    """
    Lädt (falls SERVER_VERSION_CHECK_ONLY=False) die license.lic
    und setzt globale Variablen. Schlägt das Laden fehl und 
    FINGERPRINT_CHECK_ENABLED=True, gehen wir in den DEMO_MODE.
    """
    global HARDCODED_FINGERPRINT, LOCAL_VERSION
    global REGISTERED_NAME, REGISTERED_EMAIL, DEMO_MODE

    if SERVER_VERSION_CHECK_ONLY:
        # Nur Servercheck => license.lic ignorieren
        LOCAL_VERSION = APP_VERSION
        HARDCODED_FINGERPRINT = ""
        REGISTERED_NAME = "ServerCheckUser"
        REGISTERED_EMAIL = "unknown@example.com"
    else:
        # Normale Vorgehensweise: license.lic laden, aber Demo-Fallback falls nicht möglich.
        try:
            licdata = load_license(LICENSE_FILE)
            HARDCODED_FINGERPRINT = licdata["fingerprint"]
            LOCAL_VERSION         = licdata["version"]
            REGISTERED_NAME       = licdata["registered_name"]
            REGISTERED_EMAIL      = licdata["registered_email"]

        except Exception as e:
            print(f"[WARN] License invalid or file missing: {e}")
            if FINGERPRINT_CHECK_ENABLED:
                # => Demomodus erzwingen
                #print("[INFO] FINGERPRINT_CHECK_ENABLED = True => We switch to DEMO_MODE because no valid license was found.")
                DEMO_MODE = True
                # Setze LOCAL_VERSION = APP_VERSION, damit der Servercheck dennoch auf die 
                # in APP_VERSION eingestellte Version geht.
                LOCAL_VERSION = APP_VERSION
                HARDCODED_FINGERPRINT = ""
                REGISTERED_NAME = "DemoUser"
                REGISTERED_EMAIL = "unknown@example.com"
            else:
                # Falls Fingerprint-Check abgeschaltet ist, kannst du hier 
                # entscheiden, was passieren soll. Evtl. kein Demo-Modus?
                print("[INFO] FINGERPRINT_CHECK_ENABLED = False => We'll just run without license.")
                LOCAL_VERSION = APP_VERSION
                HARDCODED_FINGERPRINT = ""
                REGISTERED_NAME = "NoLicenseFile"
                REGISTERED_EMAIL = "unknown@example.com"


_init_license_data()

##############################################################################
# 5) Zusatz-Funktionen für QSettings usw.
##############################################################################

def is_disclaimer_accepted() -> bool:
    """
    Liest aus QSettings (Firma=VGSync, App=VGSync) den Bool-Wert 'disclaimerAccepted'.
    Default = False, falls nicht vorhanden.
    """
    s = QSettings("VGSync", "VGSync")
    val = s.value("disclaimerAccepted", False, type=bool)
    return val


def set_disclaimer_accepted():
    """
    Setzt in QSettings => 'disclaimerAccepted' = True.
    """
    s = QSettings("VGSync", "VGSync")
    s.setValue("disclaimerAccepted", True)


def reset_config():
    """
    Löscht alle in QSettings gespeicherten Werte
    (z. B. disclaimersAccepted, maptilerKey, etc.).
    """
    s = QSettings("VGSync", "VGSync")
    s.clear()


def is_edit_video_enabled() -> bool:
    """
    Beispiel-Funktion: Liest aus QSettings, ob 'video/editEnabled' True/False ist.
    """
    s = QSettings("VGSync", "VGSync")
    val = s.value("video/editEnabled", False, type=bool)
    return val


def set_edit_video_enabled(enabled: bool):
    """
    Schreibt in QSettings, ob 'video/editEnabled' True/False ist.
    """
    s = QSettings("VGSync", "VGSync")
    s.setValue("video/editEnabled", enabled)


def check_app_version_and_reset_if_necessary():
    """
    Überprüft, ob die gespeicherte Version in QSettings der aktuellen APP_VERSION
    entspricht. Falls nicht, werden sämtliche QSettings gelöscht und anschließend
    die neue APP_VERSION eingetragen.

    Gibt True zurück, wenn ein Reset durchgeführt wurde, sonst False.
    """
    s = QSettings("VGSync", "VGSync")
    stored_version = s.value("appVersion", "", type=str)
    if stored_version != APP_VERSION:
        s.clear()
        s.setValue("appVersion", APP_VERSION)
        return True
    else:
        return False
        
        
def clear_temp_directories():
    """Löscht alle Inhalte in den temporären Verzeichnissen."""
    for tmp_dir in [TMP_KEYFRAME_DIR, MY_GLOBAL_TMP_DIR]:
        if os.path.exists(tmp_dir):
            try:
                shutil.rmtree(tmp_dir)
                print(f"[INFO] Temp-Verzeichnis geleert: {tmp_dir}")
            except Exception as e:
                print(f"[WARN] Konnte {tmp_dir} nicht löschen: {e}")
        os.makedirs(tmp_dir, exist_ok=True)  # Neu anlegen, falls nötig        

```

# fingerprint_collect.py

import platform
import subprocess
import re
import uuid
import hashlib

def get_fingerprint_windows():
    hostname = platform.node()
    cpu_id = "CPU_UNKNOWN"
    board_sn = "BOARD_UNKNOWN"
    try:
        cpu_output = subprocess.check_output(["wmic", "cpu", "get", "ProcessorId"], text=True)
        lines = cpu_output.split()
        for token in lines:
            if re.match(r"^[0-9A-Fa-f]{16,}$", token):
                cpu_id = token.upper()
                break
    except:
        pass
    try:
        board_output = subprocess.check_output(["wmic", "baseboard", "get", "SerialNumber"], text=True)
        lines = board_output.split()
        for token in lines:
            if len(token) >= 4 and token.upper() != "SERIALNUMBER":
                board_sn = token.upper()
                break
    except:
        pass
    raw_str = f"{hostname}-{cpu_id}-{board_sn}"
    h = hashlib.sha256(raw_str.encode("utf-8")).hexdigest().upper()
    return h[:16]

def get_fingerprint_linux():
    hostname = platform.node()
    vendor = "UNKNOWN_VENDOR"
    serial = "UNKNOWN_SERIAL"
    try:
        with open("/proc/cpuinfo", "r") as f:
            for line in f:
                line = line.strip()
                if line.startswith("vendor_id"):
                    vendor = line.split(":")[1].strip()
                elif line.startswith("Serial"):
                    serial = line.split(":")[1].strip()
    except:
        pass

    mac_int = uuid.getnode()
    mac_hex = f"{mac_int:012X}"
    raw_str = f"{hostname}-{vendor}-{serial}-{mac_hex}"
    h = hashlib.sha256(raw_str.encode("utf-8")).hexdigest().upper()
    return h[:16]

def get_fingerprint_universal():
    os_name = platform.system().lower()
    if os_name.startswith("win"):
        return get_fingerprint_windows()
    elif os_name.startswith("linux"):
        return get_fingerprint_linux()
    else:
        # fallback => Hostname + MAC
        hostname = platform.node()
        mac_int = uuid.getnode()
        mac_hex = f"{mac_int:012X}"
        raw_str = f"{hostname}-{mac_hex}"
        h = hashlib.sha256(raw_str.encode("utf-8")).hexdigest().upper()
        return h[:16]

```
#!/usr/bin/env python3
"""
generate_keys_rsa.py
Erzeugt ein 2048-Bit RSA-Schlüsselpaar im PEM-Format:
  - my_private_key.pem (unverschlüsselt)
  - my_public_key.pem
"""

from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.backends import default_backend

def main():
    # 1) Privaten Schlüssel erzeugen (2048 Bit RSA)
    private_key = rsa.generate_private_key(
        public_exponent=65537,
        key_size=2048,
        backend=default_backend()
    )

    # 2) Öffentlichen Schlüssel ableiten
    public_key = private_key.public_key()

    # 3) Private Key speichern (PEM, unverschlüsselt)
    with open("my_private_key.pem", "wb") as f:
        f.write(
            private_key.private_bytes(
                encoding=serialization.Encoding.PEM,
                format=serialization.PrivateFormat.TraditionalOpenSSL,
                encryption_algorithm=serialization.NoEncryption()
            )
        )

    # 4) Public Key speichern (PEM)
    with open("my_public_key.pem", "wb") as f:
        f.write(
            public_key.public_bytes(
                encoding=serialization.Encoding.PEM,
                format=serialization.PublicFormat.SubjectPublicKeyInfo
            )
        )

    print("Fertig: my_private_key.pem und my_public_key.pem erzeugt.")

if __name__ == "__main__":
    main()

```
import json
import base64

from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.asymmetric import padding, rsa
from cryptography.hazmat.primitives.ciphers.aead import AESGCM
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from cryptography.hazmat.backends import default_backend

# --------------------------------------------------------------------------------
# Dein öffentlicher RSA-Key (PEM) als Byte-String:
# --------------------------------------------------------------------------------
PUBLIC_KEY_PEM = b"""\
-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAsqnbaTea/9uO/Xo3i153
TmQWz1IMzZ/vuAz6BaCcCQrfvIInSxsu1Ofc80tEkajlDZE7HSRE6+bnTOI44fLm
9igIZbRAiSq8Tw5oISRjwKRbrCVLEvJbl6+Dh3dHJ4y7Yhn/OhCnF7/LAWduymAK
FF+Sqyf7SOS1YfjnNp0pjgsOpeWIGf2hpM3lHS1Jprnj8LJQaVPr09u+y2sX8K8t
81ST4DE3qpQm4SrCt/WDZ4sKTzGasPcDgnZJjbvKJ6KTWmQ3zG0A7/PmIQ9+ZbaP
23qQ7plykw2vdAdR5A9ApuASvX/9xHXxB8QpMODToCx9QsjnJAaWLi5aamfLvDPX
IQIDAQAB
-----END PUBLIC KEY-----
"""

SYM_PASSPHRASE = "kLm1(bksmelIkmeM;p$-kslpw28612535"
SALT           = b"meloennsLWNF"

def load_license(license_file_path: str):
    """
    Liest 'license.lic', entschlüsselt sie (AES-GCM) und prüft die RSA-Signatur (PSS).
    Gibt ein Dictionary mit den Feldern "fingerprint", "version", "registered_name", ...
    """
    # 1) Datei laden (JSON)
    with open(license_file_path, "r", encoding="utf-8") as f:
        content = json.load(f)  # => { "nonce": "...", "cipher": "..." }

    nonce_b  = base64.b64decode(content["nonce"])
    cipher_b = base64.b64decode(content["cipher"])

    # 2) AES-Key aus Passphrase (PBKDF2)
    kdf = PBKDF2HMAC(
        algorithm=hashes.SHA256(),
        length=32,
        salt=SALT,
        iterations=100_000,
        backend=default_backend()
    )
    aes_key = kdf.derive(SYM_PASSPHRASE.encode("utf-8"))

    # 3) AES-GCM decrypt
    aesgcm = AESGCM(aes_key)
    plaintext = aesgcm.decrypt(nonce_b, cipher_b, None)

    # => { "license": {...}, "signature": "..." }
    combined_obj = json.loads(plaintext)

    # 4) Felder extrahieren
    license_data = combined_obj["license"]
    sig_b64      = combined_obj["signature"]
    signature    = base64.b64decode(sig_b64)

    # 5) Public Key laden
    public_key = serialization.load_pem_public_key(
        PUBLIC_KEY_PEM,
        backend=default_backend()
    )

    # 6) Original-Klartext war der JSON-String von "license_data"
    lic_json_str = json.dumps(license_data, ensure_ascii=False)

    # 7) Signatur prüfen (RSA-PSS, SHA256)
    try:
        public_key.verify(
            signature,
            lic_json_str.encode("utf-8"),
            padding.PSS(
                mgf=padding.MGF1(hashes.SHA256()),
                salt_length=padding.PSS.MAX_LENGTH
            ),
            hashes.SHA256()
        )
    except Exception as e:
        raise ValueError(f"Signature invalid! {e}")

    # => Alles OK
    return license_data

```
#!/usr/bin/env python3
import json
import base64
import os

from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.asymmetric import ec, utils
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from cryptography.hazmat.primitives.ciphers.aead import AESGCM

# -------------------------------------------------------
# Konfiguration
# -------------------------------------------------------
PRIVATE_KEY_PATH = "my_private_key.pem"  # Dein privater Key (EC oder RSA)
SYM_PASSPHRASE   = "mySuperSymKey_123"   # Wird in der App hartkodiert
SALT             = b"mySalt123"          # Für PBKDF2 (unbedingt gleich in der App)

# -------------------------------------------------------
# Lizendaten, z.B. wie gehabt
# -------------------------------------------------------
license_data = {
    "fingerprint":     "EAE3277B40E7910E",
    "version":         "2.2.0-BE",
    "registered_name": "Bernd Ellera",
    "registered_email":"max@muster.com",
    "expire_date":     "2024-12-31"
}

def main():
    # 1) Privaten Key laden
    with open(PRIVATE_KEY_PATH, "rb") as f:
        private_key = serialization.load_pem_private_key(
            f.read(),
            password=None,  # Falls dein Key passwortgeschützt ist, hier Bytes eingeben
            backend=default_backend()
        )

    # 2) JSON-String erzeugen
    license_json = json.dumps(license_data, ensure_ascii=False)

    # 3) Signatur berechnen (EC-Signatur in diesem Beispiel)
    signature = private_key.sign(
        license_json.encode("utf-8"),
        ec.ECDSA(hashes.SHA256())
    )
    # => raw signature bytes

    # 4) Ein JSON-Objekt draus bauen: { "license": ..., "signature": ... }
    #    So können wir beides zusammen verschlüsseln
    combined_obj = {
        "license":   license_data,
        "signature": base64.b64encode(signature).decode("utf-8")
    }
    combined_json = json.dumps(combined_obj, ensure_ascii=False).encode("utf-8")

    # 5) Symmetrische Verschlüsselung (AES-GCM)
    #    a) PBKDF2, um aus Passphrase -> AES-Schlüssel zu generieren
    kdf = PBKDF2HMAC(
        algorithm=hashes.SHA256(),
        length=32,  # 256 bit
        salt=SALT,
        iterations=100_000,
        backend=default_backend()
    )
    aes_key = kdf.derive(SYM_PASSPHRASE.encode("utf-8"))

    #    b) AES-GCM mit zufälligem Nonce (12 Byte)
    nonce = os.urandom(12)
    aesgcm = AESGCM(aes_key)
    ciphertext = aesgcm.encrypt(nonce, combined_json, None)  # "Associated Data" = None

    # 6) Datei-Format: wir speichern { nonce, ciphertext } Base64-codiert
    #    Du kannst es natürlich auch anders strukturieren.
    final_obj = {
        "nonce":     base64.b64encode(nonce).decode("utf-8"),
        "cipher":    base64.b64encode(ciphertext).decode("utf-8")
    }
    final_json = json.dumps(final_obj)

    with open("license.lic", "w", encoding="utf-8") as f:
        f.write(final_json)

    print("License file 'license.lic' erstellt.")

if __name__ == "__main__":
    main()


```
#!/usr/bin/env python3
"""
license_generator_rsa.py
Interaktives Skript, um eine lizenz.lic-Datei zu erstellen:
 - Die eingegebenen Felder werden als JSON gespeichert,
 - Dann mit RSA-Signatur (PSS) signiert,
 - Dann symmetrisch (AES-GCM) verschlüsselt,
 - Abschließend in license.lic abgelegt.
 - Zusätzlich wird eine Versioninfo-Zeile ausgegeben.
"""

import json
import base64
import os

from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.asymmetric import padding, rsa
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from cryptography.hazmat.primitives.ciphers.aead import AESGCM

# -----------------------------------------------------------------------
# Konfiguration: RSA-Privater Key (PEM) + SymPass + SALT
# -----------------------------------------------------------------------
PRIVATE_KEY_PATH = "my_private_key.pem"      # Pfad zum RSA-Privatkey (PEM)
SYM_PASSPHRASE = "kLm1(bksmelIkmeM;p$-kslpw28612535"
SALT           = b"meloennsLWNF"

def main():
    print("****************************************************")
    print("* Interaktiver License Generator (AES + RSA-PSS)   *")
    print("****************************************************\n")

    # 1) Lizenzdaten interaktiv abfragen
    fingerprint      = input("Fingerprint (z.B. EAE3277B40E7910E): ")
    version          = input("Version (z.B. 2.2.0-BE): ")
    registered_name  = input("Registered Name (z.B. Bernd Eller): ")
    registered_email = input("Registered E-Mail (z.B. max@muster.com): ")
    expire_date      = input("Expire-Date (YYYY-MM-DD, z.B. 2025-12-31): ")

    license_data = {
        "fingerprint":      fingerprint.strip(),
        "version":          version.strip(),
        "registered_name":  registered_name.strip(),
        "registered_email": registered_email.strip(),
        "expire_date":      expire_date.strip()
    }

    # 2) Privaten Key laden
    try:
        with open(PRIVATE_KEY_PATH, "rb") as f:
            private_key = serialization.load_pem_private_key(
                f.read(),
                password=None,  # Falls dein Key passwortgeschützt ist, hier Bytes eingeben
                backend=default_backend()
            )
    except Exception as e:
        print(f"[ERROR] Konnte Private Key '{PRIVATE_KEY_PATH}' nicht laden:", e)
        return

    # 3) JSON-String
    license_json = json.dumps(license_data, ensure_ascii=False)
    
    # 4) RSA-Signatur (PSS + SHA256)
    try:
        signature = private_key.sign(
            license_json.encode("utf-8"),
            padding.PSS(
                mgf=padding.MGF1(hashes.SHA256()),
                salt_length=padding.PSS.MAX_LENGTH
            ),
            hashes.SHA256()
        )
    except Exception as e:
        print("[ERROR] Fehler beim Signieren:", e)
        return

    # 5) Gemeinsames JSON-Objekt (Lizenz + Signatur)
    combined_obj = {
        "license":   license_data,
        "signature": base64.b64encode(signature).decode("utf-8")
    }
    combined_json_bytes = json.dumps(combined_obj, ensure_ascii=False).encode("utf-8")

    # 6) Symmetrische Verschlüsselung (AES-GCM)
    #    a) Key aus Passphrase via PBKDF2
    kdf = PBKDF2HMAC(
        algorithm=hashes.SHA256(),
        length=32,           # 256 bit
        salt=SALT,
        iterations=100_000,
        backend=default_backend()
    )
    aes_key = kdf.derive(SYM_PASSPHRASE.encode("utf-8"))

    #    b) Nonce + AESGCM
    nonce = os.urandom(12)
    aesgcm = AESGCM(aes_key)
    ciphertext = aesgcm.encrypt(nonce, combined_json_bytes, None)

    # 7) In JSON verpacken + Base64 => "license.lic"
    final_obj = {
        "nonce":  base64.b64encode(nonce).decode("utf-8"),
        "cipher": base64.b64encode(ciphertext).decode("utf-8")
    }
    final_json_str = json.dumps(final_obj)

    output_filename = "license.lic"
    try:
        with open(output_filename, "w", encoding="utf-8") as f:
            f.write(final_json_str)
        print(f"\nFertig: '{output_filename}' wurde erstellt!")
    except Exception as e:
        print("[ERROR] Konnte Datei nicht schreiben:", e)
        return

    # 8) Zeile für serverseitige versioninfo.txt
    server_line = f"{license_data['version']} ; ENABLE ; {license_data['expire_date']}"
    print("\nBitte füge folgende Zeile in deine 'versioninfo.txt' ein und lade sie hoch:")
    print(f"   {server_line}")

if __name__ == "__main__":
    main()

```
# path_manager.py

import os
import platform
import shutil
from PySide6.QtWidgets import QFileDialog, QMessageBox
from PySide6.QtCore import QSettings
import ctypes

def add_to_process_path(path_str: str):
    if not path_str:
        return
    old_path = os.environ.get("PATH", "")
    new_path = path_str + os.pathsep + old_path
    os.environ["PATH"] = new_path

def is_ffmpeg_in_folder(folder: str) -> bool:
    if not folder or not os.path.isdir(folder):
        return False
    exe_name = "ffmpeg.exe" if platform.system().lower().startswith("win") else "ffmpeg"
    path_exe = os.path.join(folder, exe_name)
    return os.path.isfile(path_exe)

def find_ffmpeg_folder() -> str:
    """
    1) QSettings
    2) Standard Windows paths
    3) which("ffmpeg")
    Returns a folder path or "" if none found.
    """
    # 1) QSettings
    s = QSettings("VGSync", "VGSync")
    stored_folder = s.value("paths/ffmpeg", "", type=str)
    if is_ffmpeg_in_folder(stored_folder):
        return stored_folder

    base_dir = os.path.dirname(os.path.abspath(__file__))
    local_path = os.path.join(base_dir, "ffmpeg", "bin")
    if is_ffmpeg_in_folder(local_path):
        return local_path


    # 2) Windows standard paths
    if platform.system().lower().startswith("win"):
        possible_paths = [
            r"C:\Program Files\FFmpeg\bin",
            r"C:\Program Files (x86)\FFmpeg\bin",
            r"C:\ffmpeg\bin"
        ]
        for p in possible_paths:
            if is_ffmpeg_in_folder(p):
                return p

    # 3) which("ffmpeg")
    ffmpeg_exec = shutil.which("ffmpeg")
    if ffmpeg_exec:
        return os.path.dirname(ffmpeg_exec)

    return ""

def ensure_ffmpeg(parent_widget) -> bool:
    """
    Ensures ffmpeg is available. 
    If a folder is auto-detected (standard path or which), 
    we store it in QSettings so it shows up in "Show current path".
    If not found -> prompt user to pick a folder.
    """
    s = QSettings("VGSync", "VGSync")
    folder = find_ffmpeg_folder()

    if folder and is_ffmpeg_in_folder(folder):
        # => falls QSettings leer oder ungültig war, aber wir 
        #    jetzt einen standard Pfad gefunden haben => in QSettings packen
        stored_in_settings = s.value("paths/ffmpeg", "", type=str)
        if stored_in_settings != folder:
            s.setValue("paths/ffmpeg", folder)

        add_to_process_path(folder)
        return True
    else:
        # => Show info BEFORE opening folder dialog
        QMessageBox.information(
            parent_widget,
            "FFmpeg Required",
            "Please select the folder where FFmpeg is installed.\n"
            "Example (Windows):\n"
            "  C:\\ffmpeg\\bin\n"
            "  C:\\Program Files\\FFmpeg\\bin\n\n"
            "This is needed for video cutting and export."
        )
        chosen = QFileDialog.getExistingDirectory(parent_widget, "Select FFmpeg Folder")
        if not chosen:
            return False
        if not is_ffmpeg_in_folder(chosen):
            QMessageBox.critical(
                parent_widget,
                "FFmpeg Missing",
                f"No valid ffmpeg executable found in:\n{chosen}"
            )
            return False

        # => store
        s.setValue("paths/ffmpeg", chosen)
        add_to_process_path(chosen)
        return True
        
    def get_license_path():
        """
        Ermittelt license.lic neben app.py (bzw. dist/app).
        """
        base_dir = get_base_dir()
        return os.path.join(base_dir, "license.lic")
        
        
def is_valid_mpv_folder(folder: str) -> bool:
    """
    Prüft, ob in dem Ordner 'folder' eine libmpv-2.dll vorhanden ist 
    und ob sie sich via ctypes laden lässt.
    Gibt True zurück, falls ja.
    """
    if not folder or not os.path.isdir(folder):
        return False
    dll_path = os.path.join(folder, "libmpv-2.dll")
    if not os.path.isfile(dll_path):
        return False

    # Optional: Test via ctypes
    try:
        _ = ctypes.cdll.LoadLibrary(dll_path)
        return True
    except Exception as e:
        print(f"[WARN] libmpv-2.dll in {folder} konnte nicht geladen werden: {e}")
        return False


def ensure_mpv_library(parent_widget, base_dir: str) -> None:
    """
    Liest aus QSettings ("paths/mpv") den Ordnerpfad. 
    Falls valide -> nutzt diesen. 
    Sonst -> fallback auf mitgelieferte DLL im Ordner mpv/lib.
    
    Richtet dann `os.environ["MPV_LIBRARY_PATH"]` und PATH entsprechend ein.
    """
    s = QSettings("VGSync", "VGSync")
    stored_folder = s.value("paths/mpv", "", type=str)

    # Default (mitgeliefert):
    mpv_default_dir = os.path.join(base_dir, "mpv", "lib")
    mpv_default_dll = os.path.join(mpv_default_dir, "libmpv-2.dll")

    if stored_folder and is_valid_mpv_folder(stored_folder):
        # User hat einen eigenen Pfad angegeben und er ist gültig
        chosen_dir = stored_folder
    else:
        # Fallback: unsere mitgelieferte DLL
        chosen_dir = mpv_default_dir

    # MPV_LIBRARY_PATH + PATH setzen:
    os.environ["MPV_LIBRARY_PATH"] = os.path.join(chosen_dir, "libmpv-2.dll")
    old_path = os.environ.get("PATH", "")
    new_path = chosen_dir + os.pathsep + old_path
    os.environ["PATH"] = new_path

    print("[DEBUG] Final MPV folder =", chosen_dir)
    print("[DEBUG] MPV_LIBRARY_PATH =", os.environ["MPV_LIBRARY_PATH"])    
```
import os

# Pfad zum Verzeichnis
directory = "."

# Ausgabedatei
output_file = "alle_dateien.txt"
trenner = "```"

with open(output_file, "w", encoding="utf-8") as outfile:
    for root, dirs, files in os.walk(directory):
        for file in files:
            if file.endswith(".py"):
                filepath = os.path.join(root, file)
                #outfile.write(f"Datei: {filepath}\n")
                with open(filepath, "r", encoding="utf-8") as infile:
                    outfile.write(infile.read())
                outfile.write(f"\n{trenner}\n")
                
print(f"Fertig! Alle Dateien wurden in {output_file} geschrieben.")


```
# core/gpx_parser.py

import math
import uuid
import xml.etree.ElementTree as ET
from datetime import datetime
from dateutil.parser import parse as dateutil_parse


    



def parse_gpx(gpx_file_path):
    
    """
    Liest eine GPX-Datei ein, extrahiert lat, lon, ele (Höhe) und time.
    Zusätzlich berechnet die Funktion distance, speed, gradient etc.
    Rückgabe: Liste von Dicts mit Feldern: 
        lat, lon, ele, time, delta_m, speed_kmh, gradient, rel_s
    """
    tree = ET.parse(gpx_file_path)
    root = tree.getroot()

    ns = {"default": "http://www.topografix.com/GPX/1/1"}
    trkpts = root.findall(".//default:trkpt", ns)
    if not trkpts:
        print("[DEBUG] Keine <trkpt> Elemente gefunden!")
        return []

    parsed_points = []
    for pt in trkpts:
        lat = float(pt.attrib["lat"])
        lon = float(pt.attrib["lon"])
        ele_el = pt.find("default:ele", ns)
        ele = float(ele_el.text) if ele_el is not None else 0.0
        time_el = pt.find("default:time", ns)
        if time_el is not None:
            time_str = time_el.text
            try:
                dt = dateutil_parse(time_str)
            except ValueError:
                dt = None
        else:
            dt = None

        parsed_points.append({
            "lat": lat,
            "lon": lon,
            "ele": ele,
            "time": dt
        })

    # (A) => Hier berechnen wir rel_s ab dem ersten Punkt
    if len(parsed_points) > 0:
        first_dt = parsed_points[0]["time"]
        if first_dt is not None:
            for p in parsed_points:
                if p["time"] is not None:
                    p["rel_s"] = (p["time"] - first_dt).total_seconds()
                else:
                    p["rel_s"] = 0.0
        else:
            # Falls der erste Punkt gar kein dt hat, alle rel_s = 0.0
            for p in parsed_points:
                p["rel_s"] = 0.0

    # Haversine etc.
    def haversine_m(lat1, lon1, lat2, lon2):
        R = 6371000
        d_lat = math.radians(lat2 - lat1)
        d_lon = math.radians(lon2 - lon1)
        a = (math.sin(d_lat/2)**2
             + math.cos(math.radians(lat1))
             * math.cos(math.radians(lat2))
             * math.sin(d_lon/2)**2)
        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))
        return R * c

    results = []
    total_distance_m = 0.0
    for i in range(len(parsed_points)):
        p = parsed_points[i]
        if i == 0:
            data = {
                "lat": p["lat"], 
                "lon": p["lon"],
                "ele": p["ele"], 
                "time": p["time"],
                "delta_m": 0.0, 
                "speed_kmh": 0.0, 
                "gradient": 0.0,
                # (B) NEU => rel_s
                "rel_s": p.get("rel_s", 0.0)
            }
        else:
            p_prev = parsed_points[i-1]
            dist_2d = haversine_m(p_prev["lat"], p_prev["lon"], p["lat"], p["lon"])
            elev_diff = p["ele"] - p_prev["ele"]
            dist_3d = math.sqrt(dist_2d**2 + elev_diff**2)
            time_diff_s = 0
            if p["time"] and p_prev["time"]:
                time_diff_s = (p["time"] - p_prev["time"]).total_seconds()
            delta_m = dist_3d
            total_distance_m += delta_m
            speed_kmh = 0.0
            if time_diff_s > 0:
                speed_kmh = (dist_3d / time_diff_s) * 3.6
            gradient = 0.0
            if dist_2d > 0:
                gradient = (elev_diff / dist_2d) * 100

            data = {
                "lat": p["lat"], 
                "lon": p["lon"],
                "ele": p["ele"], 
                "time": p["time"],
                "delta_m": delta_m,
                "speed_kmh": speed_kmh,
                "gradient": gradient,
                # (B) NEU => rel_s
                "rel_s": p.get("rel_s", 0.0)
            }

        results.append(data)
    return results


def recalc_gpx_data(gpx_data: list[dict]):
    
    """
    Aktualisiert delta_m, speed_kmh, gradient und rel_s,
    basierend auf bereits eingelesenen (u. U. modifizierten) gpx_data-Einträgen.
    """
    
    
    if not gpx_data:
        return
    
    # A) Ersten Zeitstempel
    first_time = gpx_data[0].get("time", None)
    if not first_time:
        first_time = datetime(2000,1,1,0,0,0)

    # B) rel_s
    for pt in gpx_data:
        dt = pt.get("time")
        if dt:
            pt["rel_s"] = (dt - first_time).total_seconds()
        else:
            pt["rel_s"] = 0.0

    # C) Hilfsfunktion Haversine
    def haversine_m(lat1, lon1, lat2, lon2):
        R = 6371000
        d_lat = math.radians(lat2 - lat1)
        d_lon = math.radians(lon2 - lon1)
        a = (math.sin(d_lat/2)**2
             + math.cos(math.radians(lat1))
             * math.cos(math.radians(lat2))
             * math.sin(d_lon/2)**2)
        c = 2*math.atan2(math.sqrt(a), math.sqrt(1-a))
        return R*c

    # D) Alle Punkte durchgehen
    for i, pt in enumerate(gpx_data):
        if i == 0:
            pt["delta_m"]   = 0.0
            pt["speed_kmh"] = 0.0
            pt["gradient"]  = 0.0
        else:
            prev = gpx_data[i-1]
            lat1, lon1 = prev["lat"], prev["lon"]
            lat2, lon2 = pt["lat"],   pt["lon"]

            dist_2d = haversine_m(lat1, lon1, lat2, lon2)
            elev_diff = pt["ele"] - prev["ele"]
            dist_3d = math.sqrt(dist_2d*dist_2d + elev_diff*elev_diff)

            pt["delta_m"] = dist_3d

            time_diff_s = 0.0
            if pt["time"] and prev["time"]:
                time_diff_s = (pt["time"] - prev["time"]).total_seconds()

            if time_diff_s > 0:
                pt["speed_kmh"] = (dist_3d / time_diff_s)*3.6
            else:
                pt["speed_kmh"] = 0.0

            if dist_2d > 0:
                pt["gradient"] = (elev_diff/dist_2d)*100
            else:
                pt["gradient"] = 0.0

    # Keine Rückgabe, weil gpx_data in-place aktualisiert wird
    
def ensure_gpx_stable_ids(gpx_data: list[dict]):
    """
    Weist jedem GPX-Punkt ein 'stable_id' zu, falls nicht vorhanden.
    Bleibt unverändert, selbst wenn Index / Reihenfolge sich ändert.
    """
    for pt in gpx_data:
        if not pt.get("stable_id"):
            pt["stable_id"] = str(uuid.uuid4())

```


```
# managers/cut_manager.py
from PySide6.QtWidgets import QMessageBox
from PySide6.QtCore import QObject, QTimer, Signal

class VideoCutManager(QObject):
    cutsChanged = Signal(float)

    def __init__(self, video_editor, timeline, parent=None):
        super().__init__(parent)
        self.video_editor = video_editor
        self.timeline = timeline
        self.markB_time_s = -1.0
        self.markE_time_s = -1.0
        self._cut_intervals = []
        self._skip_timer = QTimer(self)
        self._skip_timer.timeout.connect(self._check_cut_skip)
        self._skip_timer.start(200)

        self.video_durations = []
        self._last_skip_target = None
        self._orig_marker_func = None
        
        
    def stop_skip_timer(self):
        """Stoppt den 200ms-Timer, sodass _check_cut_skip nicht mehr aufgerufen wird."""
        if self._skip_timer.isActive():
            self._skip_timer.stop()

    def start_skip_timer(self):
        """Startet den Timer wieder, damit _check_cut_skip erneut aktiv wird."""
        if not self._skip_timer.isActive():
            self._skip_timer.start(200)
            

    def set_video_durations(self, durations_list):
        self.video_durations = durations_list

    def on_markB_clicked(self):
        current_global_s = self._get_current_global_time()
        if self.markE_time_s >= 0 and current_global_s >= self.markE_time_s:
            QMessageBox.warning(
                None,
                "Invalid MarkB",
                f"You cannot set MarkB ({current_global_s:.2f}s) behind MarkE ({self.markE_time_s:.2f}s)!"
            )
            return  # Abbrechen, gar nicht setzen
            
        self.markB_time_s = current_global_s
        self.timeline.set_markB_time(current_global_s)

    def on_markE_clicked(self):
        current_global_s = self._get_current_global_time()
        if self.markB_time_s >= 0 and current_global_s <= self.markB_time_s:
            QMessageBox.warning(
                None,
                "Invalid MarkE",
                f"You cannot set MarkE ({current_global_s:.2f}s) in front of MarkB ({self.markB_time_s:.2f}s)!"
            )
            return
        
        self.markE_time_s = current_global_s
        self.timeline.set_markE_time(current_global_s)

    def on_cut_clicked(self):
        if self.markB_time_s < 0 or self.markE_time_s < 0:
            return
        start_s = min(self.markB_time_s, self.markE_time_s)
        end_s   = max(self.markB_time_s, self.markE_time_s)
        video_total = sum(self.video_durations)
        start_s = max(0.0, start_s)
        end_s   = min(end_s, video_total)
        if (end_s - start_s) < 0.01:
            print("[DEBUG] Cut-Bereich zu klein, Abbruch.")
            return
        print(f"[DEBUG] CUT hinzugefügt: ({start_s:.3f}, {end_s:.3f})")
        self._cut_intervals.append((start_s, end_s))
        self.timeline.add_cut_interval(start_s, end_s)
        self.markB_time_s = -1
        self.markE_time_s = -1
        self.timeline.set_markB_time(-1)
        self.timeline.set_markE_time(-1)
        self._emit_cuts_changed()
        self.video_editor.set_cut_intervals(self._cut_intervals)

    def on_undo_clicked(self):
        if not self._cut_intervals:
            return
        self._cut_intervals.pop()
        self.timeline.remove_last_cut_interval()
        self._emit_cuts_changed()
        self.video_editor.set_cut_intervals(self._cut_intervals)

    def on_markClear_clicked(self):
        if self.markB_time_s >= 0 or self.markE_time_s >= 0:
            self.markB_time_s = -1.0
            self.markE_time_s = -1.0
            self.timeline.set_markB_time(-1)
            self.timeline.set_markE_time(-1)

    def get_total_cuts(self) -> float:
        total_cut = 0.0
        for (start_s, end_s) in self._cut_intervals:
            total_cut += (end_s - start_s)
        print(f"[DEBUG] get_total_cuts => {total_cut:.3f}")
        return total_cut

    def get_cut_intervals(self):
        return self._cut_intervals
    
   
    def _check_cut_skip(self):
        # 1) Prüfen, ob mpv überhaupt ein File abspielt
        if not self._has_active_file():
            return  # => Kein Skip, da kein aktives Video

        current_global_s = self._get_current_global_time()
        skip_target = self._find_skip_target(current_global_s)
        
        if skip_target is not None:
            if self._is_repeated_skip_target(skip_target):
                return
        
            was_playing = self.video_editor.is_playing
            self._set_global_time_s(skip_target)
            self._last_skip_target = skip_target

            # NUR wenn wir wirklich vorher gespielt haben, wieder abspielen
            if was_playing:
                self._play_after_skip()
        else:
            self._last_skip_target = None


    def _has_active_file(self) -> bool:
        """Prüft, ob mpv noch eine gültige Datei (playlist/current_index) geladen hat."""
        # 1) Hat der VideoEditor eine Playlist?
        if not self.video_editor.playlist:
            return False

        # 2) current_index darf nicht außerhalb liegen
        idx = self.video_editor.get_current_index()
        if idx < 0 or idx >= len(self.video_editor.playlist):
            return False

        # 3) mpv-Filename (sofern mpv.py das unterstützt)
        fname = self.video_editor._player.filename
        if not fname:
            return False

        return True
    
    

    def _find_skip_target(self, current_s: float):
        """
        Falls current_s in einem cut-Intervall liegt (start_s <= current_s < end_s),
        soll direkt ans Ende (end_s) gesprungen werden.
        """
        for (start_s, end_s) in self._cut_intervals:
            if start_s <= current_s < end_s:
                return end_s
        return None

    def _is_repeated_skip_target(self, skip_target: float) -> bool:
        """
        Verhindert doppeltes Springen an dieselbe Stelle in schneller Folge.
        """
        if self._last_skip_target is None:
            return False
        return abs(skip_target - self._last_skip_target) < 0.001
    
    
    def _get_current_global_time(self) -> float:
        return self.video_editor.get_current_position_s()
    
    def _set_global_time_s(self, new_global_s: float):
        """
        Springt in die Timeline => new_global_s, 
        macht sofort Pause, so dass 1 Frame sichtbar ist.
        """
        was_playing = self.video_editor.is_playing  # Merke, ob das Video vorher lief
        # 1) mpv-Seeking
        self.video_editor._jump_to_global_time(new_global_s)
        if not was_playing:
            # 2) Pause => Freeze
            self.video_editor._player.pause = True
            self.video_editor.is_playing = False
        else:
            self._play_after_skip()    
            
        # 3) Timeline-Update blocken
        self._block_timeline_marker()
    
    

    def _play_after_skip(self):
        """
        Wird nach dem Setzen der neuen Zeit aufgerufen, 
        um (leicht verzögert) weiterzuspielen.
        """
        #return
        
        def _ensure_playing():
            """Prüft, ob das Video läuft, und startet es falls nötig."""
            if not self.video_editor.is_playing:
                self.video_editor._player.pause = False
                self.video_editor.is_playing = True


        from PySide6.QtCore import QTimer
        #QTimer.singleShot(50, self._really_force_play)
        # 1) Normale Verzögerung für Sprünge innerhalb desselben Videos
        QTimer.singleShot(50, _ensure_playing)

        # 2) Falls ein Video-Wechsel stattfand, nochmals nachprüfen
        QTimer.singleShot(500, _ensure_playing)

    def _really_force_play(self):
        """
        Analog zum alten Code: Startet MPV-Wiedergabe wirklich neu
        (statt 'media_list_player.play()').
        """
        self.video_editor._player.pause = False
        self.video_editor.is_playing = True

    def _block_timeline_marker(self):
        if self._orig_marker_func is not None:
            return
        self._orig_marker_func = self.timeline.set_marker_position

        def dummy_marker_position(pos: float):
            pass

        self.timeline.set_marker_position = dummy_marker_position

        from PySide6.QtCore import QTimer
        QTimer.singleShot(50, self._restore_timeline_marker)

    def _restore_timeline_marker(self):
        if self._orig_marker_func is not None:
            self.timeline.set_marker_position = self._orig_marker_func
            self._orig_marker_func = None

    def _emit_cuts_changed(self):
        total_cut = self.get_total_cuts()
        self.cutsChanged.emit(total_cut)
    
    def is_in_cut_segment(self, time_s: float) -> bool:
        """
        Returns True, wenn 'time_s' innerhalb eines vorhandenen 
        Schnittbereichs (start_s <= time_s < end_s) liegt.
        """
        for (start_s, end_s) in self._cut_intervals:
            if start_s <= time_s < end_s:
                return True
        return False

```
# managers/end_manager.py

import os
import tempfile
from PySide6.QtCore import QObject, QTimer
from PySide6.QtWidgets import QDialog, QVBoxLayout, QLabel, QPushButton, QMessageBox
from PySide6.QtGui import QPixmap

class EndManager(QObject):
    def __init__(self, video_editor, timeline, cut_manager, mainwindow, parent=None):
        super().__init__(parent)
        self.video_editor = video_editor
        self.timeline = timeline
        self.cut_manager = cut_manager           # <-- NEU
        self.mainwindow = mainwindow            # <-- NEU
        #print("[DEBUG] EndManager wurde erstellt.")

    def go_to_end(self):
        """
        Wird aufgerufen, wenn man den >>| -Button anklickt.
        Bisher hat man hier ans letzte Frame gesprungen. 
        Neu: Wir prüfen, ob MarkB gesetzt ist. 
             Falls nein => Warnung.
             Falls ja => MarkE = komplettes Video-Ende,
                         und wenn AutoSyncVideo=ON => 
                         markiere auch in GPX-Liste von B..Ende.
        """
        print("[DEBUG] go_to_end() wurde aufgerufen")

        if not self.video_editor.multi_durations:
            print("[DEBUG] keine Videos geladen (multi_durations ist leer)")
            return

        # 1) Haben wir überhaupt MarkB?
        if self.cut_manager.markB_time_s < 0:
            QMessageBox.warning(
                None,
                "MarkB not set",
                "Please set MarkB first, before cutting the End of the video."
            )
            return

        # 2) Komplettes Ende des Videos errechnen
        total_duration = sum(self.video_editor.multi_durations)
        print(f"[DEBUG] Gesamtdauer: {total_duration:.2f} s")
        if total_duration <= 0:
            print("[DEBUG] Video hat keine positive Gesamtdauer.")
            return

        # 3) MarkE = Video-Ende setzen
        self.cut_manager.markE_time_s = total_duration
        self.timeline.set_markE_time(total_duration)
        print(f"[DEBUG] MarkE automatisch gesetzt auf {total_duration:.3f}s")

        # 4) Falls AutoSyncVideo ON => im GPX von B..Ende rot markieren
        if self.mainwindow._autoSyncVideoEnabled:
            print("[DEBUG] AutoSyncVideo ist an => auch in GPX den Bereich bis zum Schluss markieren.")
            gpx_list = self.mainwindow.gpx_widget.gpx_list
            if gpx_list._markB_idx is None or gpx_list._markB_idx < 0:
                print("[DEBUG] Im GPX ist allerdings kein MarkB gesetzt => wir lassen es so.")
            else:
                row_count = gpx_list.table.rowCount()
                if row_count > 0:
                    e_idx = row_count - 1
                    gpx_list.set_markE_row(e_idx)
                    print(f"[DEBUG] GPX => E = letzte Zeile (Index={e_idx})")

        # 5) Optional: Du kannst hier noch eine Info-Box anzeigen,
        #    damit der User weiß, er braucht jetzt nur noch "cut" zu drücken.
        QMessageBox.information(
            None,
            "Marked the End",
            "The End of the video is now automatically marked (B..E).\n"
            "Please press 'cut' if you want to remove it!"
        )

        
        
    def _set_global_time_s(self, new_global_s: float):
        """
        Versetzt den Player (media_list_player) an die globale Zeit new_global_s,
        pausiert dann sofort. So bleiben wir garantiert am letzten Frame stehen.
        """
        durations = self.video_editor.multi_durations
        if not durations:
            return

        boundaries = []
        offset = 0.0
        for dur in durations:
            offset += dur
            boundaries.append(offset)

        total_all = boundaries[-1]
        if new_global_s < 0:
            new_global_s = 0
        if new_global_s > total_all:
            new_global_s = total_all

        new_idx = 0
        offset_prev = 0.0
        if abs(new_global_s - total_all) < 0.0001:
            new_idx = len(boundaries) - 1
            if new_idx > 0:
                offset_prev = boundaries[new_idx - 1]
        else:
            for i, bnd in enumerate(boundaries):
                if new_global_s <= bnd:
                    new_idx = i
                    break
                offset_prev = bnd

        local_s = new_global_s - offset_prev
        if local_s < 0:
            local_s = 0

        self.video_editor.media_list_player.stop()
        self.video_editor.is_playing = False
        self.video_editor._current_index = new_idx
        self.video_editor.media_list_player.play_item_at_index(new_idx)

        def after_switch():
            self.video_editor.media_player.set_time(int(local_s * 1000))
            self.video_editor.media_player.set_pause(True)
            self.video_editor.is_playing = False

        QTimer.singleShot(50, after_switch)

    def _take_snapshot(self, out_file: str):
        w = self.video_editor.video_frame.width()
        h = self.video_editor.video_frame.height()
        self.video_editor.media_player.video_take_snapshot(0, out_file, w, h)

    def _show_snapshot_dialog(self, path_to_image: str):
        dlg = QDialog()
        dlg.setWindowTitle("Schnappschuss – letztes Frame")

        vbox = QVBoxLayout(dlg)
        lbl = QLabel()
        pix = QPixmap(path_to_image)
        lbl.setPixmap(pix)
        vbox.addWidget(lbl)

        btn = QPushButton("OK")
        btn.clicked.connect(dlg.close)
        vbox.addWidget(btn)

        dlg.exec()

```

# managers/import_export_manager.py
import subprocess
import os
import sys
import json
from PySide6.QtWidgets import QMessageBox

class ImportExportManager:
    """
    Dient dazu, Videos zu importieren (ffprobe-Aufrufe, Keyframes-Index),
    und am Ende exportieren (Concat-Skripte, etc.).
    """
    def __init__(self, mainwindow):
        self.mw = mainwindow  # Referenz auf dein MainWindow oder ein 'context'
        
    def start_indexing_process(self, video_path):
        dlg = _IndexingDialog(video_path, parent=self)
        dlg.indexing_extracted.connect(self.on_extract_finished)
        dlg.start_indexing()
        dlg.exec()  

    def on_extract_finished(self, video_path, temp_dir):
        print("[DEBUG] on_extract_finished => rufe run_merge an ...")
        base_name = os.path.splitext(os.path.basename(video_path))[0]
        csv_file = os.path.join(temp_dir, f"keyframes_{base_name}_ffprobe.csv")
        self.run_merge(video_path, csv_file, temp_dir)
        
    def run_merge(self, video_path, csv_file, temp_dir):
        print("[DEBUG] run_merge => optionaler code hier ...")
        offset_value = self._get_offset_for_filepath(video_path)
        
        
        
    def on_indexing_finished(self, temp_dir):
        merged_json = os.path.join(temp_dir, "merged_keyframes.json")
        if not os.path.exists(merged_json):
            print("[DEBUG] merged_keyframes.json nicht gefunden in", temp_dir)
            return

        try:
            with open(merged_json, "r", encoding="utf-8") as f:
                data = json.load(f)

            new_kfs = []
            for entry in data:
                try:
                    gt = float(entry.get("global_time", 0.0))
                    new_kfs.append(gt)
                except:
                    pass
            new_kfs.sort()

            self.global_keyframes.extend(new_kfs)
            self.global_keyframes = sorted(set(self.global_keyframes))
            print("[DEBUG] %d Keyframes global geladen (gesamt)." % len(self.global_keyframes))

        except Exception as e:
            print("[DEBUG] Fehler beim Laden der JSON:", e)
    
    
```
# managers/safe_manager.py

import subprocess
import re
import os
import tempfile

from PySide6.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QPushButton,
    QProgressBar, QLabel, QMessageBox
)
from PySide6.QtCore import Qt, QProcess, QTimer

class SafeManager(QDialog):
    def __init__(self, cmd_list, total_duration_s: float, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Safe Manager – ffmpeg in QProcess")
        self.setModal(True)
        self.setMinimumWidth(400)

        layout = QVBoxLayout(self)
        self.label_status = QLabel("Starte ...", self)
        layout.addWidget(self.label_status)

        self.progress_bar = QProgressBar(self)
        self.progress_bar.setRange(0, 100)
        self.progress_bar.setValue(0)
        layout.addWidget(self.progress_bar)

        row_btn = QHBoxLayout()
        self.btn_cancel = QPushButton("Abbrechen", self)
        self.btn_cancel.clicked.connect(self._on_cancel_clicked)
        row_btn.addStretch()
        row_btn.addWidget(self.btn_cancel)
        layout.addLayout(row_btn)

        self.setLayout(layout)

        self.cmd_list = cmd_list
        self.total_duration_s = total_duration_s
        self.ffmpeg_process = None

    def start_saving(self):
        if not self.cmd_list or len(self.cmd_list) < 2:
            QMessageBox.critical(self, "Fehler", "Ungültiges ffmpeg-Kommando!")
            self.close()
            return
        self._start_ffmpeg()

    def _start_ffmpeg(self):
        self.label_status.setText("Starte ffmpeg ...")
        self.progress_bar.setValue(0)

        self.ffmpeg_process = QProcess(self)
        self.ffmpeg_process.setProgram(self.cmd_list[0])
        self.ffmpeg_process.setArguments(self.cmd_list[1:])

        self.ffmpeg_process.readyReadStandardError.connect(self._on_read_stderr)
        self.ffmpeg_process.finished.connect(self._on_process_finished)
        self.ffmpeg_process.start()
        if not self.ffmpeg_process.waitForStarted(3000):
            QMessageBox.critical(self, "Fehler", "Konnte ffmpeg nicht starten!")
            self.close()

    def _on_read_stderr(self):
        if not self.ffmpeg_process:
            return
        data = self.ffmpeg_process.readAllStandardError().data().decode("utf-8", errors="replace")
        lines = data.split("\n")
        for line in lines:
            line = line.strip()
            if "time=" in line:
                m = re.search(r"time=(\d+:\d+:\d+\.\d+)", line)
                if m:
                    cur_time_str = m.group(1)
                    cur_s = self._hms_to_seconds(cur_time_str)
                    pct = 0
                    if self.total_duration_s > 0:
                        pct = (cur_s / self.total_duration_s) * 100
                        if pct > 100:
                            pct = 100
                    self.progress_bar.setValue(int(pct))
                    hms_total = self._seconds_to_hms(self.total_duration_s)
                    self.label_status.setText(f"Verarbeite: {cur_time_str} / {hms_total}")

    def _on_process_finished(self, exit_code, exit_status):
        if exit_code == 0:
            self.progress_bar.setValue(100)
            self.label_status.setText("Fertig!")
        else:
            self.label_status.setText(f"Fehler oder abgebrochen (exit={exit_code}).")
        QTimer.singleShot(1000, self.close)

    def _on_cancel_clicked(self):
        if self.ffmpeg_process and self.ffmpeg_process.state() == QProcess.Running:
            self.ffmpeg_process.kill()
            self.ffmpeg_process.waitForFinished()
        self.close()

    def _hms_to_seconds(self, hms_str: str) -> float:
        try:
            hh, mm, ss = hms_str.split(":")
            sec = float(ss)
            return int(hh)*3600 + int(mm)*60 + sec
        except:
            return 0.0

    def _seconds_to_hms(self, total_seconds: float) -> str:
        s = int(round(total_seconds))
        h = s // 3600
        s %= 3600
        m = s // 60
        s %= 60
        return f"{h:02d}:{m:02d}:{s:02d}"

```
# -*- coding: utf-8 -*-
"""
step_manager.py

Erweiterter StepManager für verschiedene Step-Modi:

- 's' (Sekunden-Schritte)
- 'm' (Minuten-Schritte)
- 'k' (Keyframe-Schritte)
- 'f' (Frame-Schritte) NEU

Mit Folgendem Verhalten:
1) s/m-Modus:
   - Bei Schritt ins Cut-Interval -> "Freeze" knapp vor/hinter dem Cut.
   - Beim nächsten Schritt -> Überspringe den Cut.

2) k-Modus:
   - Falls das Keyframe im Cut-Bereich liegt -> direkt drüber springen
     (also ohne Freeze).

3) f-Modus (Frame-Step):
   - Springt um ca. 1 Frame (bzw. step_multiplier Frames).
   - Vor jedem Step wird überprüft, ob wir ins Cut-Interval geraten würden;
     wenn ja, wird wie bei s/m ein Freeze gemacht.
   - ACHTUNG: Da MPV bei Rückwärts-Frame-Step eventuell keine exakte
     Einzelframe-Auflösung unterstützt (und VFR-Videos variieren können),
     ist dies nur ein Approx. Man nimmt (1 / fps).
"""

from PySide6.QtCore import QTimer

class StepManager(object):
    def __init__(self, video_editor):
        """
        :param video_editor: Referenz auf das VideoEditorWidget (enthaelt multi_durations, MPV player usw.)

        Mögliche step_mode:
        - 's' => Sekunden
        - 'm' => Minuten
        - 'k' => Keyframes
        - 'f' => Einzelbild (Frame) - NEU
        """
        self.video_editor = video_editor
        self.mainwindow = None
        self.cut_manager = None

        self.step_mode = "s"   # 's', 'm', 'k', 'f'
        self.step_multiplier = 1.0

        # Freeze-Logik fuer s/m/f
        self._freeze_mode = False
        self._frozen_cut_interval = None

        # Fuer Keyframe-Schritte
        self._last_skip_target = None

    def set_mainwindow(self, mw):
        """
        Damit wir z.B. auf mw.global_keyframes zugreifen können
        (fuer K-Mode).
        """
        self.mainwindow = mw

    def set_cut_manager(self, cm):
        """
        Uebergibt den VideoCutManager, damit wir auf dessen get_cut_intervals() zugreifen koennen.
        """
        self.cut_manager = cm

    def set_step_mode(self, new_mode):
        self.step_mode = new_mode
        print(f"[DEBUG] StepManager: step_mode set to '{self.step_mode}'")

    def set_step_multiplier(self, multiplier):
        self.step_multiplier = multiplier
        print(f"[DEBUG] StepManager: step_multiplier = {self.step_multiplier}")

    # ------------------------------------------------------------------------
    # Oeffentliche Step-Funktionen (werden per Buttons aufgerufen)
    # ------------------------------------------------------------------------
    def step_forward(self):
        # Falls das Video laeuft -> Pausieren
        if self.video_editor.is_playing:
            self.video_editor._player.pause = True
            self.video_editor.is_playing = False

        # (1) Freeze-Modus schon aktiv?
        if self._freeze_mode:
            self._handle_freeze_forward()
            return

        # (2) Normaler Step, je nach Mode
        if self.step_mode == 'k':
            self._step_keyframe_forward()
        elif self.step_mode in ('s', 'm'):
            self._step_time_forward()
        elif self.step_mode == 'f':  # *** F-Mode START ***
            self._step_frame_forward() 
        else:
            print(f"[DEBUG] step_mode='{self.step_mode}'? Unbekannter Modus.")

    def step_backward(self):
        # Falls das Video laeuft -> Pausieren
        if self.video_editor.is_playing:
            self.video_editor._player.pause = True
            self.video_editor.is_playing = False

        # (1) Freeze aktiv?
        if self._freeze_mode:
            self._handle_freeze_backward()
            return

        # (2) Normaler Step
        if self.step_mode == 'k':
            self._step_keyframe_backward()
        elif self.step_mode in ('s', 'm'):
            self._step_time_backward()
        elif self.step_mode == 'f':  # *** F-Mode START ***
            self._step_frame_backward()
        else:
            print(f"[DEBUG] step_mode='{self.step_mode}'? Unbekannter Modus.")

    # ------------------------------------------------------------------------
    # Freeze-Logik entkoppelt, damit wir keinen Code-Duplikat haben.
    # ------------------------------------------------------------------------
    def _handle_freeze_forward(self):
        """
        Falls wir schon eingefroren sind und nochmal step_forward rufen,
        überspringen wir direkt das Cut-Ende.
        """
        self._freeze_mode = False
        if self._frozen_cut_interval:
            start_s, end_s = self._frozen_cut_interval
            self._frozen_cut_interval = None
            jump_s = end_s + 0.001
            print(f"[DEBUG] War eingefroren - Ueberspringe Cut => gehe zu {jump_s:.3f}")
            self.video_editor._jump_to_global_time(jump_s)
        else:
            print("[DEBUG] War eingefroren, aber _frozen_cut_interval=None => normal step forward")

    def _handle_freeze_backward(self):
        """
        Falls wir schon eingefroren sind und nochmal step_backward rufen,
        überspringen wir direkt das Cut-Start.
        """
        self._freeze_mode = False
        if self._frozen_cut_interval:
            start_s, end_s = self._frozen_cut_interval
            self._frozen_cut_interval = None
            jump_s = max(start_s - 0.001, 0.0)
            print(f"[DEBUG] War eingefroren - Ueberspringe Cut rueckwaerts => gehe zu {jump_s:.3f}")
            self.video_editor._jump_to_global_time(jump_s)
        else:
            print("[DEBUG] War eingefroren, aber _frozen_cut_interval=None => normal step backward")

    # ------------------------------------------------------------------------
    # s-/m-Modus => Zeit-Schritte + Freeze-Logik
    # ------------------------------------------------------------------------
    def _step_time_forward(self):
        cur_s = self._get_current_global_time()
        delta_s = self._compute_time_step_s()
        new_s = cur_s + delta_s

        # Check, ob new_s im Cut => freeze
        if self._check_and_freeze_if_stepping_into_cut(cur_s, new_s, forward=True):
            return

        print(f"[DEBUG] (time-forward): {cur_s:.3f} => {new_s:.3f} (dt={delta_s:.3f})")
        self.video_editor._jump_to_global_time(new_s)

    def _step_time_backward(self):
        cur_s = self._get_current_global_time()
        delta_s = self._compute_time_step_s()
        new_s = cur_s - delta_s
        if new_s < 0.0:
            new_s = 0.0

        if self._check_and_freeze_if_stepping_into_cut(cur_s, new_s, forward=False):
            return

        print(f"[DEBUG] (time-backward): {cur_s:.3f} => {new_s:.3f} (dt={delta_s:.3f})")
        self.video_editor._jump_to_global_time(new_s)

    def _compute_time_step_s(self):
        if self.step_mode == 'm':
            return 60.0 * self.step_multiplier
        elif self.step_mode == 's':
            return 1.0 * self.step_multiplier
        else:
            # Falls man hier landet (k/f) => normal 1.0
            return 1.0

    # ------------------------------------------------------------------------
    # *** F-Mode START *** => Frame-Step + Freeze
    # ------------------------------------------------------------------------
    def _step_frame_forward(self):
        """
        Einzelbild vorwärts, mit Freeze-Check.
        Wir approximieren die nächste Zeit als current + (step_multiplier / fps).
        """
        cur_s = self._get_current_global_time()
        fps = self._get_current_fps()
        # step_multiplier = '2x' => 2 Frames?
        frame_delta = (1.0 * self.step_multiplier) / fps  
        next_s = cur_s + frame_delta

        # Freeze-Check
        if self._check_and_freeze_if_stepping_into_cut(cur_s, next_s, forward=True):
            return

        print(f"[DEBUG] (frame-forward): {cur_s:.3f} => ~{next_s:.3f} (+{frame_delta:.5f}s)")
        self.video_editor.frame_step_forward()

    def _step_frame_backward(self):
        """
        Einzelbild rückwärts, mit Freeze-Check.
        Achtung: MPV kann rückwärts-frame-step nur eingeschränkt.
        """
        cur_s = self._get_current_global_time()
        fps = self._get_current_fps()
        frame_delta = (1.0 * self.step_multiplier) / fps
        next_s = cur_s - frame_delta
        if next_s < 0.0:
            next_s = 0.0

        if self._check_and_freeze_if_stepping_into_cut(cur_s, next_s, forward=False):
            return

        print(f"[DEBUG] (frame-backward): {cur_s:.3f} => ~{next_s:.3f} (-{frame_delta:.5f}s)")
        self.video_editor.frame_step_backward()

    def _get_current_fps(self):
        """
        Lese das aktuelle FPS aus MPV (falls verfügbar).
        Fallback = 25.0 bei unbekannter Framerate.
        """
        try:
            fps = self.video_editor._player.video_params["fps"]
            if fps and fps > 0:
                return float(fps)
        except:
            pass
        return 25.0

    # ------------------------------------------------------------------------
    # k-Modus => Keyframe-Schritte (ohne Freeze, direkter Skip)
    # ------------------------------------------------------------------------
    def _step_keyframe_forward(self):
        kfs = self._get_kfs_list()
        if not kfs:
            print("[DEBUG] (k-forward): Keine Keyframes vorhanden.")
            from PySide6.QtWidgets import QMessageBox
            QMessageBox.warning(None, "No Keyframes Loaded",
                "No keyframes loaded! Please index your videos or switch off 'k' mode.")
            return

        cur_s = self._get_current_global_time()
        mul = max(1.0, self.step_multiplier)
        n = int(mul)

        EPS = 0.005
        idx = None
        for i, t in enumerate(kfs):
            if t > (cur_s + EPS):
                idx = i
                break
        if idx is None:
            print("[DEBUG] (k-forward): bereits am letzten Keyframe.")
            return

        idx_n = idx + (n - 1)
        if idx_n >= len(kfs):
            idx_n = len(kfs) - 1

        target_s = kfs[idx_n]
        skip_s = self._maybe_skip_cut(target_s, forward=True)
        if skip_s is not None:
            print(f"[DEBUG] (k-forward): Keyframe {target_s:.3f} im Cut => springe {skip_s:.3f}")
            self.video_editor._jump_to_global_time(skip_s)
            return

        print(f"[DEBUG] (k-forward): current={cur_s:.3f} => {target_s:.3f} (idx={idx_n})")
        self.video_editor._jump_to_global_time(target_s)

    def _step_keyframe_backward(self):
        kfs = self._get_kfs_list()
        if not kfs:
            print("[DEBUG] (k-backward): Keine Keyframes vorhanden.")
            from PySide6.QtWidgets import QMessageBox
            QMessageBox.warning(None, "No Keyframes Loaded",
                "No keyframes loaded! Please index your videos or switch off 'k' mode.")
            return

        cur_s = self._get_current_global_time()
        mul = max(1.0, self.step_multiplier)
        n = int(mul)

        EPS = 0.005
        idx = None
        # Rueckwaerts => den naechsten Keyframe UNTERHALB cur_s
        for i in reversed(range(len(kfs))):
            if kfs[i] < (cur_s - EPS):
                idx = i
                break
        if idx is None:
            print("[DEBUG] (k-backward): Vor erstem Keyframe.")
            return

        idx_n = idx - (n - 1)
        if idx_n < 0:
            idx_n = 0

        target_s = kfs[idx_n]
        skip_s = self._maybe_skip_cut(target_s, forward=False)
        if skip_s is not None:
            print(f"[DEBUG] (k-backward): Keyframe {target_s:.3f} im Cut => springe {skip_s:.3f}")
            self.video_editor._jump_to_global_time(skip_s)
            return

        print(f"[DEBUG] (k-backward): current={cur_s:.3f} => {target_s:.3f} (idx={idx_n})")
        self.video_editor._jump_to_global_time(target_s)

    # ------------------------------------------------------------------------
    # Gemeinsame Hilfsfunktionen
    # ------------------------------------------------------------------------
    def _maybe_skip_cut(self, target_s: float, forward: bool) -> float | None:
        """
        Prueft, ob target_s in einem geschnittenen Bereich liegt.
        Falls ja => "Cut-Ende+0.001" (forward) oder "Cut-Start-0.001" (backward).
        Sonst None => normal.
        """
        if not self.cut_manager:
            return None

        for (start_s, end_s) in self.cut_manager.get_cut_intervals():
            if start_s <= target_s < end_s:
                if forward:
                    return min(end_s + 0.001, self._get_total_duration())
                else:
                    return max(start_s - 0.001, 0.0)
        return None

    def _check_and_freeze_if_stepping_into_cut(self, cur_s, next_s, forward: bool) -> bool:
        """
        Falls wir in einen geschnittenen Bereich gelangen, freeze knapp davor.
        Nächster Step => actual skip.
        """
        if not self.cut_manager:
            return False

        for (start_s, end_s) in self.cut_manager.get_cut_intervals():
            # check if [cur_s, next_s] => in den Cut-Bereich läuft
            # forward => next_s > cur_s
            # backward => next_s < cur_s
            if forward:
                # wir wollen von cur_s nach next_s
                if (start_s <= next_s < end_s):
                    freeze_s = max(start_s - 0.001, 0.0)
                    print(f"[DEBUG] Step => freeze @ {freeze_s:.3f}")
                    self._frozen_cut_interval = (start_s, end_s)
                    self._freeze_mode = True
                    self.video_editor._jump_to_global_time(freeze_s)
                    return True
            else:
                if (start_s < next_s <= end_s):
                    freeze_s = min(end_s + 0.001, self._get_total_duration())
                    print(f"[DEBUG] Step => freeze @ {freeze_s:.3f}")
                    self._frozen_cut_interval = (start_s, end_s)
                    self._freeze_mode = True
                    self.video_editor._jump_to_global_time(freeze_s)
                    return True

        return False

    def _get_current_global_time(self) -> float:
        """
        Index => local => global
        """
        idx = self.video_editor._current_index
        local_s = self.video_editor.get_current_position_s()
        total_before = sum(self.video_editor.multi_durations[:idx])
        return total_before + local_s

    def _get_total_duration(self) -> float:
        return sum(self.video_editor.multi_durations)

    def _get_kfs_list(self):
        """
        Aus dem MainWindow => global_keyframes
        """
        if not self.mainwindow:
            return []
        return self.mainwindow.global_keyframes or []

```


```
#!/usr/bin/env python3
# tools/extract_keyframes.py

import argparse
import subprocess
import csv
import os
import sys

def extract_keyframes(ffprobe_path, input_file):
    cmd = [
        ffprobe_path,
        "-v", "error",
        "-select_streams", "v:0",
        "-skip_frame", "nokey",
        "-show_entries", "frame=pts_time,pict_type,key_frame",
        "-of", "csv=p=0",
        input_file
    ]
    try:
        completed_process = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, check=True)
    except FileNotFoundError:
        print(f"Fehler: ffprobe wurde unter '{ffprobe_path}' nicht gefunden.", file=sys.stderr)
        sys.exit(1)
    except subprocess.CalledProcessError as e:
        print(f"Fehler bei der ffprobe-Ausführung:\n{e.stderr}", file=sys.stderr)
        sys.exit(1)

    lines = completed_process.stdout.strip().split('\n')
    keyframes = []
    for line in lines:
        parts = line.split(',')
        if len(parts) == 3:
            d = {
                "pts_time": parts[0],
                "pict_type": parts[1],
                "key_frame": parts[2]
            }
            keyframes.append(d)
    return keyframes

def save_keyframes_to_csv(keyframes, output_file):
    with open(output_file, mode='w', encoding='utf-8', newline='') as f:
        writer = csv.DictWriter(f, fieldnames=["pts_time", "pict_type", "key_frame"])
        writer.writeheader()
        for kf in keyframes:
            writer.writerow(kf)

def main():
    parser = argparse.ArgumentParser(description="Extrahiert Keyframes aus einem MP4-Video.")
    parser.add_argument("--input", required=True)
    parser.add_argument("--output", required=True)
    parser.add_argument("--ffprobe", default="ffprobe")
    args = parser.parse_args()

    if not os.path.isfile(args.input):
        print(f"Fehler: Eingabedatei '{args.input}' nicht gefunden.")
        sys.exit(1)

    keyframes = extract_keyframes(args.ffprobe, args.input)
    if not keyframes:
        print("Keine Keyframes gefunden oder Fehler bei ffprobe.")
        sys.exit(1)

    save_keyframes_to_csv(keyframes, args.output)
    print(f"Keyframes erfolgreich in '{args.output}' gespeichert.")

if __name__ == "__main__":
    main()

```
import csv
import json
import os

def merge_keyframes_incremental(csv_file, json_file, label=None, offset=0.0, do_sort=True):
    """
    Liest Keyframes aus 'csv_file' (welches KEINEN Header hat, sondern direkt:
       1,0.000000,I
       1,1.001000,I
       ...
    also Reihenfolge: [key_frame, pts_time, pict_type]

    Lädt vorhandene Keyframes aus 'json_file' (falls existiert), merged beide
    und speichert das Ergebnis wieder in 'json_file'.
    """

    print(f"[DEBUG] merge_keyframes_incremental => csv_file: {csv_file}, json_file: {json_file}, label={label}, offset={offset}")

    # 1) Prüfen, ob CSV existiert
    if not os.path.isfile(csv_file):
        print(f"[WARN] CSV '{csv_file}' existiert nicht. Abbruch.")
        return

    # 2) CSV einmal öffnen, um Zeilen zu zählen (optional, nur für Debug)
    with open(csv_file, 'r', encoding='utf-8') as f:
        all_lines = f.read().splitlines()
    print(f"[DEBUG] CSV '{csv_file}' => enthält {len(all_lines)} Gesamtzeilen (ohne Header).")

    # 3) Jetzt nochmal öffnen für DictReader, mit festen fieldnames
    with open(csv_file, 'r', encoding='utf-8') as f:
        reader = csv.DictReader(f, fieldnames=["key_frame", "pts_time", "pict_type"])
        csv_keyframes = []
        for row in reader:
            # row = {"key_frame": "1", "pts_time": "0.000000", "pict_type": "I"}
            try:
                # KEYFRAME (Spalte 1)
                kf_str = row["key_frame"].strip()

                # PTS_TIME (Spalte 2)
                pts_str = row["pts_time"].strip()
                pts_val = float(pts_str)

                # PICT_TYPE (Spalte 3)
                pict_type = row["pict_type"].strip()

            except (KeyError, AttributeError, ValueError) as e:
                print(f"[WARN] Zeile ungültig: {row} => {e}")
                continue

            # Dictionary erstellen
            entry = {
                "pts_time":    f"{pts_val:.6f}",   # z.B. "0.000000"
                "pict_type":   pict_type,          # z.B. "I"
                "key_frame":   kf_str,            # z.B. "1"
                "global_time": f"{pts_val + offset:.6f}"
            }
            if label:
                entry["video"] = label

            csv_keyframes.append(entry)

    print(f"[DEBUG] CSV '{csv_file}' => {len(csv_keyframes)} gültige Keyframes eingelesen.")

    # 4) Existierendes JSON laden
    existing_data = []
    if os.path.isfile(json_file):
        try:
            with open(json_file, 'r', encoding='utf-8') as f:
                existing_data = json.load(f)
                if not isinstance(existing_data, list):
                    print(f"[WARN] '{json_file}' enthielt kein Array. Überschreibe es.")
                    existing_data = []
        except Exception as e:
            print(f"[WARN] Konnte '{json_file}' nicht laden ({e}). Starte mit leerer Liste.")
            existing_data = []

    print(f"[DEBUG] Im JSON '{json_file}' lagen bereits {len(existing_data)} Keyframes.")

    # 5) Merge (Liste zusammenfügen)
    merged_data = existing_data + csv_keyframes

    # 6) Sortieren
    if do_sort:
        def safe_float(val):
            try:
                return float(val)
            except:
                return 0.0
        merged_data.sort(key=lambda x: safe_float(x.get("global_time", "0.0")))

    # 7) Speichern
    try:
        with open(json_file, 'w', encoding='utf-8') as f:
            json.dump(merged_data, f, indent=2, ensure_ascii=False)
    except Exception as e:
        print(f"[ERROR] Konnte '{json_file}' nicht schreiben: {e}")
        return

    print(f"[DEBUG] Merge fertig. Neu enthalten: {len(merged_data)} Keyframes in '{json_file}'.")

```


```
# views/dialogs.py

import os
import shutil

from PySide6.QtWidgets import QDialog, QLabel, QVBoxLayout, QPushButton, QProgressBar, \
    QHBoxLayout, QMessageBox, QTextEdit
    
from PySide6.QtCore import QTimer, QProcess, Signal, Qt
from PySide6.QtCore import QEvent


from config import TMP_KEYFRAME_DIR
from config import MY_GLOBAL_TMP_DIR            

class _IndexingDialog(QDialog):
    indexing_extracted = Signal(str, str)  # (video_path, temp_dir)

    def __init__(self, video_path, parent=None):
        super().__init__(parent)
        self.video_path = video_path
        self.process = None
        self._outfile = None
        self._line_count = 0
        
        
        base_name = os.path.splitext(os.path.basename(self.video_path))[0]
        self.output_csv = os.path.join(TMP_KEYFRAME_DIR, f"keyframes_{base_name}_ffprobe.csv")

        self.setWindowTitle("Indexing Keyframes")
        self.setModal(True)
        self.setMinimumWidth(380)

        layout = QVBoxLayout(self)
        info_text = f"Indexing {base_name} -> {self.output_csv}"
        self.label_info = QLabel(info_text, self)
        layout.addWidget(self.label_info)

        more_info_text = "Please wait patiently. Large files can take 5–10 minutes!"
        self.label_more_info = QLabel(more_info_text, self)
        layout.addWidget(self.label_more_info)

        self.progress_bar = QProgressBar(self)
        self.progress_bar.setRange(0, 0)
        layout.addWidget(self.progress_bar)

        self.label_linecount = QLabel("Read Keyframe:", self)
        layout.addWidget(self.label_linecount)

        self._bounce_timer = QTimer(self)
        self._bounce_timer.timeout.connect(self._on_bounce_timer)
        self._bounce_timer.start(80)
        self._bounce_value = 0

        row_btn = QHBoxLayout()
        self.btn_cancel = QPushButton("Cancel", self)
        self.btn_cancel.clicked.connect(self.on_cancel)
        row_btn.addStretch()
        row_btn.addWidget(self.btn_cancel)
        layout.addLayout(row_btn)

    def _on_bounce_timer(self):
        self._bounce_value += 2
        if self._bounce_value > 100:
            self._bounce_value = 0
        self.progress_bar.setValue(self._bounce_value)

    def start_indexing(self):
        self.run_ffprobe_direct()

    def run_ffprobe_direct(self):
        cmd = [
            "ffprobe",
            "-v", "error",
            "-select_streams", "v:0",
            "-skip_frame", "nokey",
            "-show_entries", "frame=pts_time,pict_type,key_frame",
            "-of", "csv=p=0",
            self.video_path
        ]
        print("[DEBUG] ffprobe cmd:", cmd)

        self.process = QProcess(self)
        self.process.setProcessChannelMode(QProcess.MergedChannels)
        self.process.readyReadStandardOutput.connect(self._on_process_stdout)
        self.process.finished.connect(self._on_process_finished)

        os.makedirs(os.path.dirname(self.output_csv), exist_ok=True)
        self._outfile = open(self.output_csv, "w", encoding="utf-8")

        self.process.setProgram(cmd[0])
        self.process.setArguments(cmd[1:])
        self.process.start()

        if not self.process.waitForStarted(-1):
            QMessageBox.critical(self, "Fehler", f"Konnte ffprobe nicht starten:\n{cmd}")
            self.reject()

    def _on_process_stdout(self):
        if not self.process:
            return
        data = self.process.readAllStandardOutput().data().decode("utf-8", "replace")
        if data:
            lines = data.split("\n")
            for line in lines:
                line = line.strip()
                if line:
                    self._line_count += 1
                    self._outfile.write(line + "\n")
            self._outfile.flush()
            self.label_linecount.setText(f"Read Keyframe: {self._line_count}")

    def _on_process_finished(self, exit_code, exit_status):
        self._bounce_timer.stop()
        self.progress_bar.setValue(100)

        if self._outfile:
            self._outfile.close()
            self._outfile = None

        if exit_code != 0:
            QMessageBox.warning(self, "Indexing Error", "Extract step failed.")
            self.reject()
            return

        print("[DEBUG] ffprobe fertig => CSV:", self.output_csv)
        self.indexing_extracted.emit(self.video_path, os.path.dirname(self.output_csv))
        self.accept()

    def on_cancel(self):
        if self.process and self.process.state() == QProcess.Running:
            self.process.kill()
        self._bounce_timer.stop()
        if self._outfile:
            self._outfile.close()
            self._outfile = None
        self.reject()


class _SafeExportDialog(QDialog):
    export_finished = Signal(str)
    export_canceled = Signal()

    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Exporting Video – This may take a while…")
        self.setModal(True)
        self.setMinimumWidth(500)

        
        layout = QVBoxLayout(self)
        self.label_info = QLabel("Please wait while segments are being cut…")
        layout.addWidget(self.label_info)

        self.progress_bar = QProgressBar(self)
        self.progress_bar.setRange(0, 0)
        layout.addWidget(self.progress_bar)

        self.text_log = QTextEdit(self)
        self.text_log.setReadOnly(True)
        layout.addWidget(self.text_log)

        row_btn = QHBoxLayout()
        row_btn.addStretch()
        self.btn_cancel = QPushButton("Cancel", self)
        self.btn_cancel.clicked.connect(self._on_cancel)
        row_btn.addWidget(self.btn_cancel)
        layout.addLayout(row_btn)

        
        self._bounce_timer = QTimer(self)
        self._bounce_timer.timeout.connect(self._on_bounce)
        self._bounce_value = 0
        self._bounce_timer.start(100)

        self._process = QProcess(self)
        self._process.finished.connect(self._on_process_finished)
        self._process.readyReadStandardError.connect(self._on_read_stderr)
        self._process.readyReadStandardOutput.connect(self._on_read_stdout)
        self._commands = []
        self._current_index = 0
        self._concat_cmd = None
        self._out_file = None
        self._cancel_requested = False

    def set_commands(self, commands_list: list, concat_cmd: list, out_file: str):
        self._commands = commands_list
        self._concat_cmd = concat_cmd
        self._out_file = out_file

    def start_export(self):
        if not self._commands:
            self._start_concat()
            return
        self._run_next_command()

    def _run_next_command(self):
        if self._cancel_requested:
            return
        if self._current_index >= len(self._commands):
            self._start_concat()
            return
        cmd = self._commands[self._current_index]
        self._append_text(f"Cut Segment #{self._current_index+1}: {cmd}")
        self._process.setProgram(cmd[0])
        self._process.setArguments(cmd[1:])
        self._process.start()

    def _on_process_finished(self, exit_code, exit_status):
        if self._cancel_requested:
            return
        if exit_code != 0:
            self._append_text("Error while processing segment!")
            
            QMessageBox.critical(self, "Error", "A segment failed.")
            self.reject()
            return
        self._append_text(f"Segment #{self._current_index+1} done!\n")
        self._current_index += 1
        self._run_next_command()

    def _start_concat(self):
        if self._cancel_requested:
            return
        if not self._concat_cmd:
            self._finish_up()
            return
        self._append_text("All segments done! Now concatenating…")
        self._process.setProgram(self._concat_cmd[0])
        self._process.setArguments(self._concat_cmd[1:])
        self._process.finished.disconnect(self._on_process_finished)
        self._process.finished.connect(self._on_concat_finished)
        self._process.start()

    def _on_concat_finished(self, exit_code, exit_status):
        if exit_code != 0:
            self._append_text("Concat failed.")
            QMessageBox.critical(self, "Error", "Concat step failed.")
            self.reject()
            return
        self._finish_up()

    def _finish_up(self):
        self._append_text("Export finished successfully!")
        QMessageBox.information(self, "Done", "Video exported successfully!")
        self._clear_segments()
        self.accept()

    def _clear_segments(self):
        
        e = "done"
        if os.path.exists(MY_GLOBAL_TMP_DIR):
            try:
                shutil.rmtree(MY_GLOBAL_TMP_DIR)
                print("[DEBUF] Temp deleted", e)
            except Exception as err:
                print("[WARN]", err)
                e = err
        os.makedirs(MY_GLOBAL_TMP_DIR, exist_ok=True)

    def _append_text(self, txt):
        self.text_log.append(txt)

    def _on_read_stderr(self):
        data = self._process.readAllStandardError().data().decode("utf-8", "replace")
        if data:
            self._append_text(data.strip())

    def _on_read_stdout(self):
        data = self._process.readAllStandardOutput().data().decode("utf-8", "replace")
        if data:
            self._append_text(data.strip())

    def _on_bounce(self):
        self._bounce_value = (self._bounce_value + 2) % 100
        self.progress_bar.setValue(self._bounce_value)

    def _on_cancel(self):
        self._append_text("User canceled export.")
        self._cancel_requested = True
        if self._process.state() == 2:
        #if self._process.state() == self._process.Running:
            self._process.kill()
            
        self.export_canceled.emit()
        self.reject()

class DetachDialog(QDialog):
    requestPlus = Signal()
    requestMinus = Signal()
    requestReattach = Signal()

    def keyPressEvent(self, event):
        key = event.key()
        txt = event.text()
        if key == Qt.Key_Plus or txt == '+':
            self.requestPlus.emit()
            event.accept()
        elif key == Qt.Key_Minus or txt == '-':
            self.requestMinus.emit()
            event.accept()
        else:
            super().keyPressEvent(event)

    def changeEvent(self, event):
        super().changeEvent(event)
        if event.type() == QEvent.WindowStateChange:
            if self.windowState() & Qt.WindowMinimized:
                self.requestReattach.emit()

    def closeEvent(self, event):
        self.requestReattach.emit()
        super().closeEvent(event)



```
# views/disclaimer_dialog.py

from PySide6.QtWidgets import (
    QDialog, QVBoxLayout, QLabel, QCheckBox, QDialogButtonBox
)
from PySide6.QtCore import Qt, QUrl
from PySide6.QtGui import QDesktopServices

class DisclaimerDialog(QDialog):
    """
    Zeigt einen Haftungsausschluss (Disclaimer) mit anklickbarem Link.
    Der User muss ein Häkchen setzen, dann wird OK aktiv.
    """

    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Disclaimer – Important Notice")

        layout = QVBoxLayout(self)

        # (1) HTML-Text mit Link
        # Achtung: openExternalLinks=True alleine kann buggy sein,
        # deshalb setzen wir openExternalLinks=False und fangen linkActivated ab.
        """
        disclaimer_html = (
            "<p><b>IMPORTANT:</b><br><br>"
            "You use this software at your own risk. We provide no warranty<br>"
            "and cannot be held liable for any damage or loss.<br>"
            "Commercial usage is strictly prohibited. Redistributio<br>"
            "of this application is also strictly prohibited.</p>"

            "<p>By clicking OK, you confirm acceptance of these terms.</p>"

            "<p>Additionally, by sending the fingerprint to our address,<br> "
            "you confirm that you accept our "
            "<a href='http://vgsync.casa-eller.de/vgsync_eula.pdf'>EULA</a> "
            "(opens in your default browser).</p><br>"
        )
        """
        disclaimer_html = (
            "<p><b>IMPORTANT NOTICE:</b><br><br>"
            "You use this software at your own risk. We provide no warranty<br>"
            "and cannot be held liable for any damage or loss.<br>"
            "Commercial usage is strictly prohibited. Redistribution<br>"
            "of this application is also strictly prohibited.</p>"

            "<p>By clicking OK, you confirm acceptance of these terms.</p>"

            "<p><b>Third-Party Libraries:</b><br>"
            "This application uses open-source software:</p>"
            
            "<ul>"
            "<li><b>FFmpeg</b> - <a href='https://ffmpeg.org'>ffmpeg.org</a> (LGPL v2.1 or later)</li>"
            "<li><b>mpv</b> - <a href='https://mpv.io'>mpv.io</a> (LGPL v2.1 or later)</li>"
            "</ul>"

            "<p>The full license texts can be found in the <code>LICENSES</code> inside the mpv and ffmpeg directories.</p>"

            "<p>Additionally, by sending the fingerprint to our address,<br> "
            "you confirm that you accept our "
            "<a href='http://vgsync.casa-eller.de/vgsync_eula.pdf'>EULA</a> "
            "(opens in your default browser).</p><br>"
        )


        self.label_info = QLabel()
        self.label_info.setTextFormat(Qt.RichText)
        self.label_info.setOpenExternalLinks(False)  # Wir handeln das selbst
        self.label_info.setTextInteractionFlags(Qt.TextBrowserInteraction | Qt.LinksAccessibleByMouse)
        self.label_info.setText(disclaimer_html)
        layout.addWidget(self.label_info)

        # (2) Signal abfangen ⇒ Linkklick
        self.label_info.linkActivated.connect(self._on_link_clicked)

        # (3) CheckBox
        self.chkConfirm = QCheckBox("I confirm I have read and accept these terms.", self)
        layout.addWidget(self.chkConfirm)

        # (4) ButtonBox => OK / Cancel
        btn_box = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel, self)
        layout.addWidget(btn_box)

        self.btn_ok = btn_box.button(QDialogButtonBox.Ok)
        self.btn_ok.setEnabled(False)

        self.chkConfirm.stateChanged.connect(self.on_checkbox_changed)
        btn_box.accepted.connect(self.accept)
        btn_box.rejected.connect(self.reject)

    def on_checkbox_changed(self, state):
        self.btn_ok.setEnabled(self.chkConfirm.isChecked())

    def _on_link_clicked(self, url: str):
        """
        Wird aufgerufen, wenn der User auf den HTML-Link klickt.
        Öffnet die URL im Standardbrowser.
        """
        QDesktopServices.openUrl(QUrl(url))

```
# views/mainwindow.py


import os
import sys
import subprocess
import json
import shutil
import base64
import config
import path_manager  # your module above
import urllib.request

# NEU: QAction und QActionGroup aus PySide6.QtGui
from PySide6.QtGui import QAction, QActionGroup

# Restliche Widgets aus QtWidgets

from PySide6.QtWidgets import (
    QMainWindow, QWidget, QGridLayout, QFrame,
    QFileDialog, QMessageBox, QVBoxLayout,
    QLabel, QProgressBar, QHBoxLayout, QPushButton, QDialog,
    QApplication, QInputDialog, QSplitter, QSystemTrayIcon
)
from PySide6.QtCore import Qt, QTimer

from PySide6.QtWidgets import QDialog, QVBoxLayout, QLabel, QLineEdit, QDialogButtonBox
from PySide6.QtCore import QSettings
from PySide6.QtGui import QIcon




from config import TMP_KEYFRAME_DIR, MY_GLOBAL_TMP_DIR
from widgets.video_editor_widget import VideoEditorWidget
from widgets.video_timeline_widget import VideoTimelineWidget
from widgets.video_control_widget import VideoControlWidget
from widgets.chart_widget import ChartWidget
from widgets.map_widget import MapWidget
from widgets.gpx_widget import GPXWidget
from widgets.gpx_control_widget import GPXControlWidget

from managers.step_manager import StepManager
from managers.end_manager import EndManager
from managers.cut_manager import VideoCutManager
from core.gpx_parser import parse_gpx  # Hier hinzufügen!

# ggf. import_export_manager, safe_manager etc.
from .dialogs import _IndexingDialog, _SafeExportDialog, DetachDialog
from widgets.mini_chart_widget import MiniChartWidget
from config import is_edit_video_enabled, set_edit_video_enabled
from config import LOCAL_VERSION, REGISTERED_NAME, REGISTERED_EMAIL
from core.gpx_parser import parse_gpx, ensure_gpx_stable_ids  # <--- Achte auf diesen Import!
from core.gpx_parser import recalc_gpx_data
from tools.merge_keyframes_incremental import merge_keyframes_incremental
from config import APP_VERSION

import platform
import subprocess
import re
import uuid
import hashlib
import os
from datetime import timedelta

def _get_fingerprint_windows():
    """
    Liest unter Windows per wmic CPU-ID und Mainboard-SerialNumber aus 
    (plus Hostname) und erzeugt daraus einen SHA256-Hash.
    Gibt die ersten 16 Hex-Zeichen (Großbuchstaben) zurück.
    """
    hostname = platform.node()
    cpu_id = "CPU_UNKNOWN"
    board_sn = "BOARD_UNKNOWN"

    # CPU-ID
    try:
        cpu_output = subprocess.check_output(
            ["wmic", "cpu", "get", "ProcessorId"], text=True
        )
        lines = cpu_output.split()
        for token in lines:
            # CPU-IDs sind meist hexadezimal
            if re.match(r"^[0-9A-Fa-f]{16,}$", token):
                cpu_id = token.upper()
                break
    except:
        pass

    # Mainboard-Serial
    try:
        board_output = subprocess.check_output(
            ["wmic", "baseboard", "get", "SerialNumber"], text=True
        )
        lines = board_output.split()
        for token in lines:
            if len(token) >= 4 and token.upper() != "SERIALNUMBER":
                board_sn = token.upper()
                break
    except:
        pass

    raw_str = f"{hostname}-{cpu_id}-{board_sn}"
    h = hashlib.sha256(raw_str.encode("utf-8")).hexdigest().upper()
    return h[:16]


def _get_fingerprint_linux():
    """
    Liest unter Linux Hostname, CPU-Vendor/Serial aus /proc/cpuinfo, 
    plus MAC-Adresse (uuid.getnode).
    Bildet daraus einen SHA256-Hash und gibt die ersten 16 Hex-Zeichen zurück.
    """
    hostname = platform.node()
    vendor = "UNKNOWN_VENDOR"
    serial = "UNKNOWN_SERIAL"

    # CPU-Info
    try:
        with open("/proc/cpuinfo", "r") as f:
            for line in f:
                line = line.strip()
                if line.startswith("vendor_id"):
                    vendor = line.split(":")[1].strip()
                elif line.startswith("Serial"):
                    serial = line.split(":")[1].strip()
    except:
        pass

    # MAC-Adresse
    mac_int = uuid.getnode()
    mac_hex = f"{mac_int:012X}"

    raw_str = f"{hostname}-{vendor}-{serial}-{mac_hex}"
    h = hashlib.sha256(raw_str.encode("utf-8")).hexdigest().upper()
    return h[:16]


def _get_fingerprint_universal():
    """
    Unterscheidet anhand von platform.system() zwischen 
    Windows, Linux und sonstigen OS. 
    - Windows: _get_fingerprint_windows()
    - Linux:   _get_fingerprint_linux()
    - Fallback: Hostname + MAC => Hash
    """
    os_name = platform.system().lower()
    if os_name.startswith("win"):
        return _get_fingerprint_windows()
    elif os_name.startswith("linux"):
        return _get_fingerprint_linux()
    else:
        # Fallback für macOS oder andere Systeme:
        hostname = platform.node()
        mac_int = uuid.getnode()
        mac_hex = f"{mac_int:012X}"

        raw_str = f"{hostname}-{mac_hex}"
        h = hashlib.sha256(raw_str.encode("utf-8")).hexdigest().upper()
        return h[:16]




class MainWindow(QMainWindow):
    def __init__(self, user_wants_editing=False):
        
        super().__init__()
        
        self._counter_url = "http://vgsync.casa-eller.de/project/counter.php"
        
        
        self._maptiler_key = ""
        self._bing_key     = ""
        self._mapbox_key   = ""
        
        self._load_map_keys_from_settings()
        
        
               
       
        self._userDeclinedIndexing = False
        
        #self._last_map_idx = None     
        # Edit B  CodeCheck
        #self.map_widget = MapWidget(mainwindow=self)        
        # Edit 
        self._video_at_end = False   # Merker, ob wir wirklich am Ende sind
        self._autoSyncVideoEnabled = False
        self.user_wants_editing = user_wants_editing
        
        
        if config.DEMO_MODE:
            # Demo
            
            self.setWindowTitle(f"VGSync v{APP_VERSION} - the simple Video and GPX-Sync Tool -----  DEMO ----- DEMO ----")
        else:
            self.setWindowTitle(f"VGSync v{APP_VERSION} - the simple Video and GPX-Sync Tool")
            
        
            
            
        
        
        
        self._map_floating_dialog = None
        self._map_placeholder = None
        
               
        self._gpx_data = []
        
        # Abkoppel-Dialoge
        self._video_area_floating_dialog = None
        self._video_placeholder = None
        

        # Playlist / Keyframe-Daten
        self.playlist = []
        self.video_durations = []
        self.playlist_counter = 0
        self.first_video_frame_shown = False
        self.real_total_duration = 0.0
        self.global_keyframes = []

        # Menüs
        menubar = self.menuBar()
        file_menu = menubar.addMenu("File")
        self.playlist_menu = menubar.addMenu("Playlist")
        view_menu = menubar.addMenu("Detach")
        
        load_gpx_action = QAction("Open GPX", self)
        load_gpx_action.triggered.connect(self.load_gpx_file)
        file_menu.addAction(load_gpx_action)


        load_mp4_action = QAction("Open MP4", self)
        load_mp4_action.triggered.connect(self.load_mp4_files)
        file_menu.addAction(load_mp4_action)
        

        dummy_action = QAction("New Project", self)
        file_menu.addAction(dummy_action)
        dummy_action.triggered.connect(self._on_new_project_triggered)
        
        
        
        setup_menu = menubar.addMenu("Config")
        
        self.action_edit_video = QAction("Edit Video", self)
        self.action_edit_video.setCheckable(True)
       
        self.action_edit_video.setChecked(False)
        set_edit_video_enabled(False)   # QSettings überschreibe
        
        self.action_edit_video.triggered.connect(self._on_toggle_edit_video)
        setup_menu.addAction(self.action_edit_video)
        
        
        self.action_auto_sync_video = QAction("AutoCutVideo+GPX", self)
        self.action_auto_sync_video.setCheckable(True)
        self.action_auto_sync_video.setChecked(False)  # Standard = OFF
        self.action_auto_sync_video.triggered.connect(self._on_auto_sync_video_toggled)
        setup_menu.addAction(self.action_auto_sync_video)
        
        
        timer_menu = setup_menu.addMenu("Time: Final/Glogal")

        self.timer_action_group = QActionGroup(self)
        self.timer_action_group.setExclusive(True)

        self.action_global_time = QAction("Global Time", self)
        self.action_global_time.setCheckable(True)

        self.action_final_time = QAction("Final Time", self)
        self.action_final_time.setCheckable(True)

        self.timer_action_group.addAction(self.action_global_time)
        self.timer_action_group.addAction(self.action_final_time)
        
       
        
        
        
        
        ffmpeg_menu = setup_menu.addMenu("FFmpeg")

        action_show_ffmpeg_path = QAction("Show current path", self)
        action_show_ffmpeg_path.triggered.connect(self._on_show_ffmpeg_path)
        ffmpeg_menu.addAction(action_show_ffmpeg_path)
        
        action_set_ffmpeg_path = QAction("Set ffmpeg Path...", self)
        action_set_ffmpeg_path.triggered.connect(self._on_set_ffmpeg_path)
        ffmpeg_menu.addAction(action_set_ffmpeg_path)
    
        action_clear_ffmpeg_path = QAction("Clear ffmpeg Path", self)
        action_clear_ffmpeg_path.triggered.connect(self._on_clear_ffmpeg_path)
        ffmpeg_menu.addAction(action_clear_ffmpeg_path)
        
        mpv_menu = setup_menu.addMenu("libmpv")
        action_show_mpv_path = QAction("Show current libmpv path", self)
        action_show_mpv_path.triggered.connect(self._on_show_mpv_path)
        mpv_menu.addAction(action_show_mpv_path)

        action_set_mpv_path = QAction("Set libmpv path...", self)
        action_set_mpv_path.triggered.connect(self._on_set_mpv_path)
        mpv_menu.addAction(action_set_mpv_path)

        action_clear_mpv_path = QAction("Clear libmpv path", self)
        action_clear_mpv_path.triggered.connect(self._on_clear_mpv_path)
        mpv_menu.addAction(action_clear_mpv_path)

        
        
        chart_menu = setup_menu.addMenu("Chart-Settings")
        limit_speed_action = QAction("Limit Speed...", self)
        chart_menu.addAction(limit_speed_action)
        limit_speed_action.triggered.connect(self._on_set_limit_speed)
        
        zero_speed_action = QAction("ZeroSpeed...", self)
        zero_speed_action.triggered.connect(self._on_zero_speed_action)
        chart_menu.addAction(zero_speed_action)
        
        
        action_mark_stops = QAction("Mark Stops...", self)
        action_mark_stops.triggered.connect(self._on_set_stop_threshold)
        chart_menu.addAction(action_mark_stops)
        
        map_setup_menu = setup_menu.addMenu("Map Setup")
        
        
        
        # Action 1: Size Yellow Point
        
         # Action 3: Size Black Point
        action_size_black = QAction("Size Black Point", self)
        action_size_black.triggered.connect(lambda: self._on_set_map_point_size("black"))
        map_setup_menu.addAction(action_size_black)
        
        action_size_red = QAction("Size Red Point", self)
        action_size_red.triggered.connect(lambda: self._on_set_map_point_size("red"))
        map_setup_menu.addAction(action_size_red)
        
        # Action 2: Size Cyan Point
        action_size_cyan = QAction("Size Cyan Point", self)
        action_size_cyan.triggered.connect(lambda: self._on_set_map_point_size("cyan"))
        map_setup_menu.addAction(action_size_cyan)
        
        
        action_size_yellow = QAction("Size Yellow Point", self)
        action_size_yellow.triggered.connect(lambda: self._on_set_map_point_size("yellow"))
        map_setup_menu.addAction(action_size_yellow)
        
        
        self._directions_enabled = False  # beim Start immer aus

        # 2) Eine neue Check-Action anlegen
        self.action_map_directions = QAction("Directions", self)
        self.action_map_directions.setCheckable(True)
        self.action_map_directions.setChecked(False)  # standard: aus
        

        # 3) Ins Menü einfügen
        map_setup_menu.addAction(self.action_map_directions)

        # 4) Signal verknüpfen
        self.action_map_directions.triggered.connect(self._on_map_directions_toggled)
        
        
        mapviews_menu = map_setup_menu.addMenu("MapViews")
        
        # --> About Keys
        about_keys_action = QAction("About Keys...", self)
        about_keys_action.triggered.connect(self._on_about_keys)
        mapviews_menu.addAction(about_keys_action)


        action_set_maptiler_key = QAction("Set MapTiler Key...", self)
        action_set_maptiler_key.triggered.connect(self._on_set_maptiler_key)
        mapviews_menu.addAction(action_set_maptiler_key)

       

        # --> Set Mapbox Key
        action_set_mapbox_key = QAction("Set Mapbox Key...", self)
        action_set_mapbox_key.triggered.connect(self._on_set_mapbox_key)
        mapviews_menu.addAction(action_set_mapbox_key)
        

                
        
        reset_config_action = QAction("Reset Config", self)
        reset_config_action.triggered.connect(self._on_reset_config_triggered)
        setup_menu.addAction(reset_config_action)
        
        info_menu = menubar.addMenu("Info")
        
        copyright_action = info_menu.addAction("Copyright + License")
        copyright_action.triggered.connect(self._show_copyright_dialog)
        
        dependencies_action = info_menu.addAction("Third-Party Libraries")
        dependencies_action.triggered.connect(self._show_dependencies_dialog)
        
        fingerprint_action = info_menu.addAction("Get Fingerprint")
        fingerprint_action.triggered.connect(self._on_get_fingerprint)
        
        
        help_menu = menubar.addMenu("Help")

        docs_action = QAction("Show Documentation...", self)
        docs_action.triggered.connect(self._on_show_documentation)
        help_menu.addAction(docs_action)
        
        
        self.action_global_time.setChecked(True)
        timer_menu.addAction(self.action_global_time)
        timer_menu.addAction(self.action_final_time)

        self.action_global_time.triggered.connect(self._on_timer_mode_changed)
        self.action_final_time.triggered.connect(self._on_timer_mode_changed)
        self._time_mode = "global"

        self.action_toggle_video = QAction("Video (detach)", self)
        self.action_toggle_video.triggered.connect(self._toggle_video)
        view_menu.addAction(self.action_toggle_video)

        self.action_toggle_map = QAction("Map (detach)", self)
        self.action_toggle_map.triggered.connect(self._toggle_map)
        view_menu.addAction(self.action_toggle_map)



        
        
        # ========================= Zentrales Layout =========================
        #
        central_widget = QWidget()
        self.setCentralWidget(central_widget)

        main_h_layout = QHBoxLayout(central_widget)  
        main_h_layout.setContentsMargins(0, 0, 0, 0)
        main_h_layout.setSpacing(0)

        #
        # ============== Linke Spalte (Video + Map) ==============
        #
        left_column_widget = QWidget()
        self.left_v_layout = QVBoxLayout(left_column_widget)
        self.left_v_layout.setContentsMargins(0, 0, 0, 0)
        self.left_v_layout.setSpacing(0)
        
        # Video-Bereich
        self.video_area_widget = QWidget()
        video_area_layout = QVBoxLayout(self.video_area_widget)
        video_area_layout.setContentsMargins(0, 0, 0, 0)
        video_area_layout.setSpacing(0)
    
        # 1)     Video Editor oben (85% der Höhe dieses Blocks)
        self.video_editor = VideoEditorWidget()
        video_area_layout.addWidget(self.video_editor, stretch=85)
        
        # 2) Timeline + Control + Blaues Widget (15% der Höhe)
        timeline_control_widget = QWidget()
        timeline_control_layout = QHBoxLayout(timeline_control_widget)
        timeline_control_layout.setContentsMargins(0, 0, 0, 0)
        timeline_control_layout.setSpacing(0)
        
        # Linke Seite (70%): Timeline + Control übereinander
        left_timeline_control_layout = QVBoxLayout()
        left_timeline_control_layout.setContentsMargins(0, 0, 0, 0)
        left_timeline_control_layout.setSpacing(0)
        
        self.timeline = VideoTimelineWidget()
        self.video_control = VideoControlWidget()
        
        left_timeline_control_layout.addWidget(self.timeline)
        left_timeline_control_layout.addWidget(self.video_control)
        
        timeline_control_layout.addLayout(left_timeline_control_layout, 7)
        
        # Rechte Seite (30%): Blaues Platzhalter-Widget
        self.mini_chart_widget = MiniChartWidget()
        timeline_control_layout.addWidget(self.mini_chart_widget, 3)
        
        # Fertig in den Video-Bereich
        video_area_layout.addWidget(timeline_control_widget, stretch=15)
        
        # Alles in den oberen Teil der linken Spalte
        self.left_v_layout.addWidget(self.video_area_widget, stretch=1)
        
        # Unten: Map (50%)
        self.map_widget = MapWidget(mainwindow=self, parent=None)
       
        
        self.left_v_layout.addWidget(self.map_widget, stretch=1)
        
        # ============== Rechte Spalte (Chart + GPX) ==============
        #
        right_column_widget = QWidget()
        right_v_layout = QVBoxLayout(right_column_widget)
        right_v_layout.setContentsMargins(0, 0, 0, 0)
        right_v_layout.setSpacing(0)
        
        # Oben: Chart (40%) => Stretch 2
        self.chart = ChartWidget()
        right_v_layout.addWidget(self.chart, stretch=2)
        
                
        
        # Unten: 60% => gpx_control (10%), gpx_list (50%)
        bottom_right_widget = QWidget()
        bottom_right_layout = QVBoxLayout(bottom_right_widget)
        bottom_right_layout.setContentsMargins(0, 0, 0, 0)
        bottom_right_layout.setSpacing(0)
        
        self.gpx_control = GPXControlWidget()
        bottom_right_layout.addWidget(self.gpx_control, stretch=1)
        
        
        self.gpx_widget = GPXWidget()
        
        
        
        bottom_right_layout.addWidget(self.gpx_widget, stretch=5)
        right_v_layout.addWidget(bottom_right_widget, stretch=3)
        
        #
        # ============== QSplitter (horizontal) ==============
        #
        splitter = QSplitter(Qt.Horizontal, central_widget)
        splitter.addWidget(left_column_widget)
        splitter.addWidget(right_column_widget)
        
        # Optional: Startverhältnis (z.B. Pixel oder Stretch)
        splitter.setStretchFactor(0, 1)
        splitter.setStretchFactor(1, 1)
        
        #
        # ============== Splitter ins Haupt-Layout ==============
        #
        main_h_layout.addWidget(splitter)
        
        
        
        
        
    
        #   Layout Ende
        ################################################################
        
        
        
        
        # ==    ============ Signale / z.B. chart, gpx_widget, etc. ==============
               
        #
        self.chart.markerClicked.connect(self._on_chart_marker_clicked)
        self.chart.set_gpx_data([])
        s = QSettings("VGSync", "VGSync")
        speed_cap = s.value("chart/speedCap", 70.0, type=float)
        self.chart.set_speed_cap(speed_cap)
        
        # GpxControl -> GpxList
        self.gpx_widget.gpx_list.markBSet.connect(self._on_markB_in_list)
        self.gpx_widget.gpx_list.markESet.connect(self._on_markE_in_list)
        self.gpx_widget.gpx_list.markRangeCleared.connect(self._on_clear_in_list)
        
        self.gpx_widget.gpx_list.markBSet.connect(self.gpx_control.highlight_markB_button)
        self.gpx_widget.gpx_list.markESet.connect(self.gpx_control.highlight_markE_button)

        # Wenn markRangeCleared (z.B. durch Deselect, Delete, Undo usw.) auftritt:
        self.gpx_widget.gpx_list.markRangeCleared.connect(self.gpx_control.reset_mark_buttons)
        
        self.gpx_control.deleteClicked.connect(self.gpx_control.on_delete_range_clicked)
        self.gpx_control.undoClicked.connect(self.gpx_control.on_undo_range_clicked)
        
        
        
        if not config.DEMO_MODE:
            # DEMO New
            self.gpx_control.saveClicked.connect(self.gpx_control.on_save_gpx_clicked)
            
        
        
        self.gpx_control.set_mainwindow(self)
        
        self.gpx_control.deleteWayErrorsClicked.connect(self.gpx_control.on_delete_way_errors_clicked)
        self.gpx_control.deleteTimeErrorsClicked.connect(self.gpx_control.on_delete_time_errors_clicked)
        self.gpx_control.closeGapsClicked.connect(self.gpx_control.on_close_gaps_clicked)
        self.gpx_control.minSpeedClicked.connect(self.gpx_control.on_min_speed_clicked)
        self.gpx_control.maxSpeedClicked.connect(self.gpx_control.on_max_speed_clicked)
        self.gpx_control.averageSpeedClicked.connect(self.gpx_control.on_average_speed_clicked)
        self.gpx_control.showMinSlopeClicked.connect(self.gpx_control._on_show_min_slope)
        self.gpx_control.showMaxSlopeClicked.connect(self.gpx_control._on_show_max_slope)







        
        
        # Ende Zentrales Layout
        ####################################################################################

        #
        # ============== StepManager, CutManager, EndManager, ... ==============
        #
        
        
        self.gpx_widget.gpx_list.rowClickedInPause.connect(self.on_user_selected_index)
        self.map_widget.pointClickedInPause.connect(self._on_map_pause_clicked)
        
        self.step_manager = StepManager(self.video_editor)
        self.step_manager.set_mainwindow(self)

        self.video_control.play_pause_clicked.connect(self.on_play_pause)
        self.video_control.stop_clicked.connect(self.on_stop)
        self.video_control.step_value_changed.connect(self.on_step_mode_changed)
        self.video_control.multiplier_value_changed.connect(self.on_multiplier_changed)
        self.video_control.backward_clicked.connect(self.step_manager.step_backward)
        self.video_control.forward_clicked.connect(self.step_manager.step_forward)

       
        self.cut_manager = VideoCutManager(self.video_editor, self.timeline, self)
        
        self.end_manager = EndManager(
            video_editor=self.video_editor,
            timeline=self.timeline,
            cut_manager=self.cut_manager,  # <-- NEU
            mainwindow=self,
            parent=self
        )

        self.video_control.goToEndClicked.connect(self.end_manager.go_to_end)
        self.video_control.markBClicked.connect(self.cut_manager.on_markB_clicked)
        self.video_control.markEClicked.connect(self.cut_manager.on_markE_clicked)
        self.video_control.cutClicked.connect(self.on_cut_clicked_video)
        self.video_control.undoClicked.connect(self.on_undo_clicked_video)
        
        self.video_control.markClearClicked.connect(self.cut_manager.on_markClear_clicked)
        self.cut_manager.cutsChanged.connect(self._on_cuts_changed)
        self.step_manager.set_cut_manager(self.cut_manager)
        self.video_control.syncClicked.connect(self.on_sync_clicked)
        
        self.gpx_control.markBClicked.connect(self.on_markB_clicked_gpx)
        self.gpx_control.deselectClicked.connect(self.on_deselect_clicked)
        
        self.video_control.markBClicked.connect(self.on_markB_clicked_video)
        self.video_control.markEClicked.connect(self._on_markE_from_video)
        self.gpx_control.markEClicked.connect(self._on_markE_from_gpx)
        self.video_control.markClearClicked.connect(self.on_deselect_clicked)
        
        
       
            
        if not config.DEMO_MODE:    
            self.video_control.safeClicked.connect(self.on_safe_clicked)

       

        # Geschwindigkeiten / Rate
        self.vlc_speeds = [0.5, 0.67, 1.0, 1.5, 2.0, 4.0, 8.0, 16.0, 32.0]
        self.speed_index = 2
        self.current_rate = self.vlc_speeds[self.speed_index]

        # Video-Abspiel-Ende
        self.video_editor.play_ended.connect(self.on_play_ended)

        # Marker Timer
        self.marker_timer = QTimer(self)
        self.marker_timer.timeout.connect(self.update_timeline_marker)
        self.marker_timer.start(200)

        self.timeline.markerMoved.connect(self._on_timeline_marker_moved)
        self.video_control.timeHMSSetClicked.connect(self.on_time_hms_set_clicked)
        
        self.gpx_widget.gpx_list.rowClickedInPause.connect(self._on_gpx_list_pause_clicked)
        self.map_widget.pointClickedInPause.connect(self._on_map_pause_clicked)
        
        self.gpx_control.chTimeClicked.connect(self.gpx_control.on_chTime_clicked_gpx)
        self.gpx_control.chEleClicked.connect(self.gpx_control.on_chEle_clicked)
        self.gpx_control.chPercentClicked.connect(self.gpx_control.on_chPercent_clicked)
        
        self.gpx_control.smoothClicked.connect(self.gpx_control.on_smooth_clicked)
        self.video_control.set_beginClicked.connect(self.on_set_begin_clicked)
        
        edit_on = is_edit_video_enabled()
        self.video_control.set_editing_mode(edit_on)
        self.map_widget.view.loadFinished.connect(self._on_map_page_loaded)
        self.video_editor.set_final_time_callback(self._compute_final_time)
        
       
    
    def _on_map_directions_toggled(self, checked: bool):
        """
        Wird aufgerufen, wenn im Menü 'Map Setup -> Directions' an/aus gehakt wird.
        """
        # Nur wenn der Nutzer das Häkchen setzt (checked=True) prüfen wir den Key
        if checked:
            # Nehmen wir an, self._mapbox_key hält den entschlüsselten Mapbox-Key
            if not self._mapbox_key or not self._mapbox_key.strip():
                # => Kein gültiger Key => Warnung und Abbruch
                from PySide6.QtWidgets import QMessageBox
                QMessageBox.warning(
                    self,
                    "Directions not available",
                    "This feature requires a valid Mapbox key.\n"
                    "Please set your Mapbox key first in the Config menu."
                )
                # Häkchen sofort zurücksetzen
                self.action_map_directions.setChecked(False)
                return

        # An dieser Stelle Key vorhanden oder Häkchen = False => fortfahren
        self._directions_enabled = checked
        if self.gpx_control:
            self.gpx_control.set_directions_mode(checked)

        # map_page.html aufrufen
        if self.map_widget and self.map_widget.view:
            page = self.map_widget.view.page()
            js_bool = "true" if checked else "false"
            code = f"setDirectionsEnabled({js_bool});"
            page.runJavaScript(code)

        print(f"[DEBUG] Directions enabled => {checked}")
        
    def _compute_final_time(self, g_s: float) -> float:
        return self.get_final_time_for_global(g_s)    
        
    def _on_show_documentation(self):
        # Pfad zum PDF ermitteln
        base_dir = os.path.dirname(os.path.dirname(__file__))
        pdf_path = os.path.join(base_dir, "doc", "Documentation.pdf")

        if not os.path.isfile(pdf_path):
            QMessageBox.warning(self, "Not found", f"File not found: {pdf_path}")
            return

        # => Im Standard-PDF-Reader öffnen
        from PySide6.QtCore import QUrl
        from PySide6.QtGui import QDesktopServices

        QDesktopServices.openUrl(QUrl.fromLocalFile(pdf_path))    
    
        
        
        
        
        
    def _on_show_mpv_path(self):
        s = QSettings("VGSync", "VGSync")
        path_stored = s.value("paths/mpv", "", type=str)
        if path_stored and os.path.isfile(os.path.join(path_stored, "libmpv-2.dll")):
            msg = f"Currently stored libmpv path:\n{path_stored}"
        else:
            msg = "No valid libmpv path stored in QSettings (or file not found)."
        QMessageBox.information(self, "libmpv Path", msg)


    def _on_set_mpv_path(self):
        """
        1) Dialog: User wählt Ordner
        2) Prüfen, ob dort eine libmpv-2.dll liegt und ob sie sich laden lässt
        3) Ggfs. in QSettings speichern
        4) Hinweis: "Bitte neustarten"
        """
        from path_manager import is_valid_mpv_folder
        folder = QFileDialog.getExistingDirectory(self, "Select folder containing libmpv-2.dll")
        if not folder:
            return  # abgebrochen

        if not is_valid_mpv_folder(folder):
            QMessageBox.warning(self, "Invalid libmpv folder",
                f"No valid 'libmpv-2.dll' found or library cannot be loaded:\n{folder}\n\n"
                "We will continue using the default library.")
            return
    
        # -> Okay, wir speichern es
        s = QSettings("VGSync", "VGSync")
        s.setValue("paths/mpv", folder)
        QMessageBox.information(self, "libmpv Path set",
            f"libmpv-2.dll path set to:\n{folder}\n\n"
            "Please restart the application to take effect.")


    def _on_clear_mpv_path(self):
        s = QSettings("VGSync", "VGSync")
        s.remove("paths/mpv")
        QMessageBox.information(self, "libmpv Path cleared",
            "The libmpv path has been removed from QSettings.\n"
            "We will fallback to the built-in mpv/lib.\n"
            "Please restart the application.")    
        
        
        
    def _increment_counter_on_server(self, mode: str):
        """
        Erhöht den Zähler auf dem Server (mode='video' oder 'gpx').
        Ruft z. B. https://.../counter.php?action=increment_video auf
        und gibt das Ergebnis (videoCount, gpxCount) als Tupel zurück.
        Bei Fehler -> None.
        """
        if mode not in ("video", "gpx"):
            print("[WARN] _increment_counter_on_server: Ungültiger mode=", mode)
            return None

        action = "increment_video" if mode == "video" else "increment_gpx"
        url = f"{self._counter_url}?action={action}"
        print("[DEBUG] increment request =>", url)
        
        try:
            with urllib.request.urlopen(url, timeout=5) as resp:
                data = resp.read().decode("utf-8")
                counts = json.loads(data)
                return (counts.get("video", 0), counts.get("gpx", 0))
        except Exception as e:
            print("[WARN] Fehler beim Serveraufruf increment:", e)
            return None


    def _fetch_counters_from_server(self):
        """
        Liest die aktuellen Zählerstände ohne Hochzählen.
        Ruft also https://.../counter.php auf (ohne action).
        Gibt bei Erfolg ein Dict { 'video': number, 'gpx': number } zurück,
        sonst None.
        """
        url = self._counter_url  # ohne ?action
        #print("[DEBUG] fetch counters =>", url)
        
        try:
            with urllib.request.urlopen(url, timeout=5) as resp:
                data = resp.read().decode("utf-8")
                counts = json.loads(data)
                return counts
        except Exception as e:
            print("[WARN] Fehler beim Serveraufruf fetch:", e)
            return None    
        
        
    def _load_map_keys_from_settings(self):
        """
        Liest aus QSettings:
         - mapTiler/key
         - bing/key
         - mapbox/key
        (jeweils Base64-kodiert) und schreibt sie in self._maptiler_key etc.
        """
        s = QSettings("VGSync", "VGSync")

        def decode(b64text):
            if not b64text:
                return ""
            try:
                return base64.b64decode(b64text.encode("utf-8")).decode("utf-8")
            except:
                return ""

        enc_mt = s.value("mapTiler/key", "", str)
        enc_bi = s.value("bing/key", "", str)
        enc_mb = s.value("mapbox/key", "", str)

        self._maptiler_key = decode(enc_mt)
        self._bing_key     = decode(enc_bi)
        self._mapbox_key   = decode(enc_mb)
    
    def _save_map_key_to_settings(self, provider: str, plain_key: str):
        """
        Speichert den Key in Base64, z. B. provider='mapTiler'|'bing'|'mapbox'.
        """
        s = QSettings("VGSync", "VGSync")
        enc = base64.b64encode(plain_key.encode("utf-8")).decode("utf-8")

        if provider == "mapTiler":
            s.setValue("mapTiler/key", enc)
            self._maptiler_key = plain_key
        elif provider == "bing":
            s.setValue("bing/key", enc)
            self._bing_key = plain_key
        elif provider == "mapbox":
            s.setValue("mapbox/key", enc)
            self._mapbox_key = plain_key

        # Jetzt sofort updaten => an map_page.html schicken
        self._update_map_page_keys()    
    
    def _update_map_page_keys(self):
        """
        Sendet die aktuellen Keys an map_page.html.
        Dort definieren wir setMapTilerKey(...), setBingKey(...), setMapboxKey(...).
        """
        if not self.map_widget or not self.map_widget.view:
            return

        page = self.map_widget.view.page()
        # JS-Aufrufe
        js_mt = f"setMapTilerKey('{self._maptiler_key}')"
        page.runJavaScript(js_mt)

        js_bi = f"setBingKey('{self._bing_key}')"
        page.runJavaScript(js_bi)

        js_mb = f"setMapboxKey('{self._mapbox_key}')"
        page.runJavaScript(js_mb)


    def _on_set_maptiler_key(self):
        self._show_key_dialog("mapTiler", self._maptiler_key)

    def _on_set_bing_key(self):
        self._show_key_dialog("bing", self._bing_key)

    def _on_set_mapbox_key(self):
        self._show_key_dialog("mapbox", self._mapbox_key)

    def _show_key_dialog(self, provider_name: str, current_val: str):
        """
        Generischer Dialog zum Eingeben des neuen Keys.
        """
        dlg = QDialog(self)
        dlg.setWindowTitle(f"Set {provider_name} Key")

        vbox = QVBoxLayout(dlg)
        lbl = QLabel(f"Enter your {provider_name} key:")
        vbox.addWidget(lbl)

        edit = QLineEdit()
        edit.setText(current_val)
        vbox.addWidget(edit)

        btns = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        vbox.addWidget(btns)

        def on_ok():
            new_key = edit.text().strip()
            self._save_map_key_to_settings(provider_name, new_key)
            dlg.accept()

        def on_cancel():
            dlg.reject()

        btns.accepted.connect(on_ok)
        btns.rejected.connect(on_cancel)

        dlg.exec()

    def _on_about_keys(self):
        """
        Zeigt einen Dialog, wofür die Keys sind, wo man sie bekommt usw.
        """
        msg_html = (
            "<h3>Map Keys Information</h3>"
            "<p>Mit diesem Tool kannst du verschiedene Kartendienste nutzen:</p>"
            "<ul>"
            "<li>MapTiler (Satelliten-Kacheln)</li>"
            "<li>Mapbox (Satellite)</li>"
            "</ul>"
            "<p>Bitte registriere dich bei jedem gewünschten Anbieter "
            "und füge hier deinen API-Key ein. Beachte jeweils die Limits (Free-Tier) "
            "und die Nutzungsbedingungen.</p>"
        )

        QMessageBox.information(self, "About Map Keys", msg_html)


    ###############################################################################
        
    def _on_about_keys(self):
        """
        Zeigt einen Hinweis, wozu die Keys da sind, Links zu den 
        Anbietern, Limits, etc. (Demo-Text).
        """
        msg = QMessageBox(self)
        msg.setWindowTitle("About Map Keys")
        msg.setTextFormat(Qt.RichText)
        msg.setText(
            "<h3>Information about Map Keys</h3>"
            "<p>You can use different satellite tile providers. "
            "Enter your own API keys for MapTiler or Mapbox. "
            "Each provider has its own usage limits and Terms of Service.</p>"
            "<ul>"
            "<li><b>MapTiler:</b> <a href='https://www.maptiler.com/'>maptiler.com</a></li>"
            "<li><b>Mapbox:</b> <a href='https://www.mapbox.com/'>mapbox.com</a></li>"
            "</ul>"
            "<p>Please ensure you comply with each provider's usage policies.</p>"
        )
        msg.setStandardButtons(QMessageBox.Ok)
        msg.exec()    
        
        
    def _on_set_stop_threshold(self):
        # Aktuellen Wert holen (z.B. aus chart._stop_threshold)
        current_val = self.chart._stop_threshold
    
        from PySide6.QtWidgets import QInputDialog
        new_val, ok = QInputDialog.getDouble(
            self,
            "Stop Threshold",
            "Mark stops greater than X seconds:",
            current_val,
            0.1,    # minimaler Wert
            1000.0, # maximaler Wert
            1       # 1 Nachkommastelle
        )
        if not ok:
            return

        # Im ChartWidget setzen
        self.chart.set_stop_threshold(new_val)    
        
        
    def _show_dependencies_dialog(self):
        """
        Zeigt einen Dialog mit den verwendeten Fremdbibliotheken und Lizenzen.
        """
        msg = QMessageBox(self)
        msg.setWindowTitle("Third-Party Libraries")
        msg.setTextFormat(Qt.RichText)
        msg.setTextInteractionFlags(Qt.TextBrowserInteraction | Qt.LinksAccessibleByMouse)
    
        msg.setText(
            "<h3>This application uses open-source software:</h3>"
            "<p><b>1. FFmpeg</b><br>"
            "License: GNU Lesser General Public License v2.1 or later<br>"
            "Source: <a href='https://ffmpeg.org'>ffmpeg.org</a><br>"
            "Original Source Code: <a href='https://github.com/FFmpeg/FFmpeg'>GitHub Repository</a></p>"
            
            "<p><b>2. mpv</b><br>"
            "License: GNU Lesser General Public License v2.1 or later<br>"
            "Source: <a href='https://mpv.io'>mpv.io</a><br>"
            "Original Source Code: <a href='https://github.com/mpv-player/mpv'>GitHub Repository</a></p>"
            
            "<p>The full license texts can be found in the <code>LICENSES/</code> folder inside the mpv and ffmpeg directories.</p>"
        )
    
        msg.setStandardButtons(QMessageBox.Ok)
        msg.exec()    
        
    def _on_map_page_loaded(self, ok: bool):
        """
        Wird aufgerufen, sobald deine map.html im QWebEngineView fertig geladen ist.
        Dann existieren erst die JS-Funktionen.
        """
        if not ok:
            print("[WARN] Karte konnte nicht geladen werden.")
            return
        #print("[DEBUG] Karte ist geladen ⇒ wende jetzt die Größen aus QSettings an.")
        self._apply_map_sizes_from_settings()  # ruft erst hier de    
        self._update_map_page_keys()
        # NEU: Directions-Status an JS geben
        js_bool = "true" if self._directions_enabled else "false"
        js_code = f"setDirectionsEnabled({js_bool});"
        self.map_widget.view.page().runJavaScript(js_code)

    def _apply_map_sizes_from_settings(self):
        s = QSettings("VGSync", "VGSync")
        for col in ["yellow", "cyan", "black"]:
            size_val = s.value(f"mapSize/{col}", 6, type=int)
            # => Map updaten
            self._update_map_points_of_color(col, size_val)    
        
        
    from PySide6.QtWidgets import QInputDialog, QMessageBox
    from PySide6.QtCore import QSettings

    def _on_set_map_point_size(self, color_str: str):
        """
        Öffnet ein Dialogfenster, in dem der Nutzer die Größe
        der Map-Punkte für 'color_str' (z.B. 'yellow', 'cyan', 'black') eingeben kann.
        Speichert den Wert in QSettings und aktualisiert sofort die Map.
        """
        # 1) Settings-Objekt
        s = QSettings("VGSync", "VGSync")  # oder deine Domain/App
    
        # 2) Aktuellen Wert aus QSettings laden (default z.B. 6)
        default_val = s.value(f"mapSize/{color_str}", 6, type=int)
    
        # 3) QInputDialog => int
        new_val, ok = QInputDialog.getInt(
            self,
            f"Set Map Size for {color_str}",
            f"Current size = {default_val}. Enter new size (1..20):",
            default_val,
            1, 20
        )
        if not ok:
            return  # abgebrochen

        # 4) Speichern in QSettings
        s.setValue(f"mapSize/{color_str}", new_val)

        # 5) Map aktualisieren
        self._update_map_points_of_color(color_str, new_val)

        QMessageBox.information(self, "Map Size Updated",
            f"{color_str.capitalize()} points changed to size={new_val}.")
            
    
    def _update_map_points_of_color(self, color_str: str, new_size: int):
        """
        Ruft in map_page.html => updateAllPointsByColor(js_color, new_size) auf,
        wobei js_color das exakte String‐Matching zur Feature‐Farbe ermöglicht.
        """
        if not self.map_widget:
            return

        # Mapping: "yellow" => "#FFFF00" usw.
        color_map = {
            "yellow": "#FFFF00",
            "cyan":   "#0000FF",
            "black":  "#000000",
            # Hier analog zu deinem JS: mark_range_in_red(...) setzt "red"
            "red":    "red"  
            # oder "#FF0000" – aber dann musst du in JS auch "f.set("color","#FF0000")" machen
        }

        # Fallback = #000000, falls irgendwas unbekanntes reinkommt
        js_color = color_map.get(color_str.lower(), "#000000")

        js_code = f"updateAllPointsByColor('{js_color}', {new_size});"
        self.map_widget.view.page().runJavaScript(js_code)
    
    
    # views/mainwindow.py (Ausschnitt aus deiner MainWindow-Klasse)

    from PySide6.QtWidgets import QMessageBox, QLabel
    from PySide6.QtCore import Qt, QUrl
    from PySide6.QtGui import QDesktopServices

    

    def _on_get_fingerprint(self):
        """
        Zeigt den Fingerprint in einer MessageBox an, mit anklickbarem Link.
        Wir leiten das linkActivated-Signal selbst auf QDesktopServices.openUrl(...)
        """

        # 1) Fingerprint erzeugen
        fp = _get_fingerprint_universal()
    
        # 2) In Datei speichern
        filename = "VGSync_Fingerprint.txt"
        try:
            with open(filename, "w", encoding="utf-8") as f:
                f.write(fp + "\n")
        except Exception as e:
            QMessageBox.critical(
                self,
                "Error",
                f"Error writing file: '{filename}':\n{e}"
            )
            return
    
        # 3) MessageBox als Objekt erstellen
        msg_box = QMessageBox(self)
        msg_box.setIcon(QMessageBox.Information)
        msg_box.setWindowTitle("Fingerprint Created")
    
        # Wichtig: RichText + Link-Verhalten
        msg_box.setTextFormat(Qt.RichText)
        #msg_box.setOpenExternalLinks(False)  # wir fangen linkActivated selbst ab
        msg_box.setTextInteractionFlags(Qt.TextBrowserInteraction | Qt.LinksAccessibleByMouse)
    
        # 4) HTML-Text
        msg_html = (
            f"<p>Fingerprint was created successfully.<br>"
            f"<b>Fingerprint:</b> {fp}</p>"
            f"<p>The file '{filename}' was saved in the current directory. "
            "Please send this file to the software provider if necessary.</p>"
    
            "<p><b>NOTE:</b> By sending the fingerprint to us, you explicitly accept our "
            "<a href='http://vgsync.casa-eller.de/vgsync_eula.pdf'>EULA</a> "
            "(opens in your default browser).</p>"
            )
        msg_box.setText(msg_html)
    
        # 5) Standardbuttons
        msg_box.setStandardButtons(QMessageBox.Ok)
    
        # 6) Link-Aktivierung => QDesktopServices
        #    In einer QMessageBox ist der Text in einem untergeordneten QLabel namens "qt_msgbox_label"
        label = msg_box.findChild(QLabel, "qt_msgbox_label")
        if label is not None:
            label.linkActivated.connect(self._on_fingerprint_link_clicked)
    
        # 7) Anzeigen
        msg_box.exec()
    
    def _on_fingerprint_link_clicked(self, url: str):
        """
        Öffnet den Link (EULA.pdf) im Standardbrowser.
        """
        QDesktopServices.openUrl(QUrl(url))
    
    
     


    def _highlight_index_everywhere(self, idx: int):
        # Map
        self.map_widget.show_blue(idx, do_center=True)
        # Chart
        self.chart.highlight_gpx_index(idx)
        # GpxList
        self.gpx_widget.gpx_list.select_row_in_pause(idx)
        # MiniChart
        if self.mini_chart_widget:
            self.mini_chart_widget.set_current_index(idx)    
        
        
    def _on_zero_speed_action(self):
        """
        Wird aufgerufen, wenn der Nutzer im Menü "Config -> Chart-Settings -> ZeroSpeed..." klickt.
        Öffnet einen Dialog, in dem der Anwender die 'Zero-Speed-Grenze' in km/h eingeben kann.
        """
        # Aktuellen Wert holen (z.B. 1.0 km/h als Default)
        current_value = self.chart.zero_speed_threshold()

        # QInputDialog für einen float-Wert
        #   Titel: Zero Speed Threshold
        #   Label: "Enter km/h"
        #   Default-Wert: current_value
        #   Min: 0.0 / Max: 200.0 / Schrittweite: 1 Stelle nach dem Komma
        new_value, ok = self.QInputDialog.getDouble(
            self,
            "Zero Speed Threshold",
            "Enter km/h:",
            current_value,
            0.0,
            200.0,
            1
        )

        if ok:
            # Den Wert ans ChartWidget weitergeben
            self.chart.set_zero_speed_threshold(new_value)    
            self._update_gpx_overview()
        
        
    from PySide6.QtWidgets import QInputDialog

    def _on_set_limit_speed(self):
        """
        Wird aufgerufen, wenn der Menüpunkt 'Limit Speed...' angeklickt wird.
        Fragt per QInputDialog den Speed-Limit-Wert ab und wendet ihn an.
        """
        # 1) Aktuellen Wert vom Chart holen
        current_limit = self.chart._speed_cap  # Oder self.chart.get_speed_cap() falls du eine Getter-Methode hast

        # 2) QInputDialog: Eingabe eines float-Wertes
        new_val, ok = self.QInputDialog.getDouble(
            self,
            "Set Speed Limit",
            "Enter max. speed (km/h):",
            current_limit,
            0.0,    # min
            9999.0, # max
            1       # decimals
        )
        if not ok:
            return  # User hat abgebrochen

        # 3) Wert im ChartWidget setzen
        self.chart.set_speed_cap(new_val)

        # 4) Optional: in QSettings speichern
        from PySide6.QtCore import QSettings
        s = QSettings("VGSync", "VGSync")
        s.setValue("chart/speedCap", new_val)
    
        
    def _on_show_ffmpeg_path(self):
        from PySide6.QtCore import QSettings
        import os

        s = QSettings("VGSync", "VGSync")
        path_stored = s.value("paths/ffmpeg", "", type=str)
        if path_stored and os.path.isdir(path_stored):
            msg = f"Currently stored FFmpeg path:\n{path_stored}"
        else:
            msg = "No FFmpeg path stored in QSettings (or path is invalid)."
        QMessageBox.information(self, "FFmpeg Path", msg)

    def _on_set_ffmpeg_path(self):
        """
        Manually pick a folder with ffmpeg.exe
        """
        from PySide6.QtWidgets import QFileDialog, QMessageBox
        from PySide6.QtCore import QSettings
        import platform, os

        QMessageBox.information(
            self,
            "Set FFmpeg Path",
            "Please select the folder where ffmpeg is installed.\n"
            "e.g. C:\\ffmpeg\\bin"
        )

        folder = QFileDialog.getExistingDirectory(self, "Select FFmpeg Folder")
        if not folder:
            return
        
        exe_name = "ffmpeg.exe" if platform.system().lower().startswith("win") else "ffmpeg"
        path_exe = os.path.join(folder, exe_name)
        if not os.path.isfile(path_exe):
            QMessageBox.critical(self, "Invalid FFmpeg",
                f"No {exe_name} found in:\n{folder}")
            return
    
        # store in QSettings
        s = QSettings("VGSync", "VGSync")
        s.setValue("paths/ffmpeg", folder)
    
        # optionally add to PATH
        old_path = os.environ.get("PATH", "")
        new_path = folder + os.pathsep + old_path
        os.environ["PATH"] = new_path
        
        QMessageBox.information(
            self,
            "FFmpeg Path updated",
            f"FFmpeg path set to:\n{folder}\n\n"
            "Please restart the application to ensure the new setting takes effect."
        )

        

    def _on_clear_ffmpeg_path(self):
        """
        Removes ffmpeg path from QSettings, 
        so that next time it might auto-detect or prompt again.
        """
        from PySide6.QtCore import QSettings
        s = QSettings("VGSync", "VGSync")
        s.remove("paths/ffmpeg")
    
        QMessageBox.information(self, "FFmpeg Path cleared",
            "The FFmpeg path has been removed from QSettings.")
            
        QMessageBox.information(
            self,
            "FFmpeg Path cleared",
            "Please restart the application to ensure the new setting takes effect."
        )    
        
            
        
        
    def _on_toggle_edit_video(self, checked: bool):
        """
        Wird aufgerufen, wenn man im Menü 'Edit Video' an-/ab-hakt.
        Wir speichern den Wert in QSettings. Falls True => fragen wir den User
        nach Indexierung der aktuell geladenen Videos.
        """
        print(f"[DEBUG] _on_toggle_edit_video => {checked}")
        #set_edit_video_enabled(checked)

        # => Buttons im VideoControl an-/abschalten
        self.video_control.set_editing_mode(checked)
        self.video_editor.edit_status_label.setText("Edit: On")
        self.video_editor.edit_status_label.setStyleSheet(
            "background-color: rgba(0,0,0,120); "
            "color: red; "
            "font-size: 14px; "
            "font-weight: bold;"
            "padding: 2px 1px;"
            )
        if checked:
            
            # 1) Nachfrage: "Do you want to index all currently loaded videos now?"
            from PySide6.QtWidgets import QMessageBox
            answer = QMessageBox.question(
                self,
                "Index Videos?",
                "Do you want to index all currently loaded videos now?\n\n"
                "Any new video you load from now on will also be indexed automatically.",
                QMessageBox.Yes | QMessageBox.No,
                QMessageBox.No
            )
            if answer == QMessageBox.Yes:
                # 2) Indexieren aller vorhandenen
                for video_path in self.playlist:
                    self.start_indexing_process(video_path)
            else:
                self._userDeclinedIndexing = True  
                

            # Info: Neu geladene Videos werden im add_to_playlist(...) automatisch indexiert,
            # falls 'Edit Video' = True.

        else:
            self.video_editor.edit_status_label.setText("")
            #self.video_editor.edit_status_label.setText("Edit:  Off")
            #self.video_editor.edit_status_label.setStyleSheet(
            #    "background-color: rgba(0,0,0,120); "
            #    "color: grey; "
            #    "font-size: 14px; "
            #    "padding: 2px 1px;"
            #    "font-weight: normal; "
            #)

            # Wurde auf false gestellt => wir machen nichts weiter,
            # ab jetzt werden neue Videos NICHT mehr indexiert.
            pass
            
        if self.gpx_control:
            # Aktion: Synchronisieren
            self.gpx_control.update_set_gpx2video_state(
                video_edit_on=checked,
                auto_sync_on=self._autoSyncVideoEnabled
            )    
    
    
    
        
        
    from PySide6.QtWidgets import QMessageBox
    import copy
    from core.gpx_parser import recalc_gpx_data

    def on_set_begin_clicked(self):
        from PySide6.QtWidgets import QMessageBox
        
        ret = QMessageBox.question(
            self,
            "Confirm Cut Begin",
            "Have you set the video exactly to the same crossing/place\n"
            "as the corresponding GPX point?\n"
            "Press Yes to proceed, No to abort.",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No
        )
        if ret != QMessageBox.Yes:
            # => Abbrechen
            return
        
        """
        'Set Begin' – überarbeitete Version mit korrektem Undo für AutoVideoSync=OFF
    
        CASE A) OFF
        - Falls global_video_s == 0 => cut in GPX am markierten Punkt
        - Falls global_video_s > 0 => wir behalten global_video_s Sekunden 
            vor dem markierten GPX-Punkt. 
            Falls (rel_s_marked - global_video_s) < 0 => Fehlermeldung 
            => keine Undo-Snapshot anlegen => Abbruch
            Sonst => wir legen Undo-Snapshot an, entfernen < cut_start, SHIFT => 0
            Kein Video-Cut.

        CASE B) ON
        - Schneiden GPX am markierten Punkt => SHIFT => 0
        - Video => cut 0..global_video_s
        - Undo wie gehabt

        => Hinterher: Chart / Map / MiniChart updaten.
        """

        from PySide6.QtWidgets import QMessageBox
        import copy
        from core.gpx_parser import recalc_gpx_data

        # 1) Markierten GPX-Punkt
        row_idx = self.gpx_widget.gpx_list.table.currentRow()
        if row_idx < 0:
            QMessageBox.warning(self, "No GPX Selection", 
                "Please select a GPX point first!")
            return

        # 2) Videozeit => global_video_s
        current_local_s = self.video_editor.get_current_position_s()
        if current_local_s < 0:
            current_local_s = 0.0
        vid_idx = self.video_editor.get_current_index()
        offset_s = sum(self.video_durations[:vid_idx])
        global_video_s = offset_s + current_local_s
        print(f"[DEBUG] set_begin => global_video_s={global_video_s:.2f}")
    
        # 3) GPX => rel_s_marked
        gpx_data = self.gpx_widget.gpx_list._gpx_data
        if not gpx_data or row_idx >= len(gpx_data):
            QMessageBox.warning(self, "GPX Error", "Invalid row in GPX data.")
            return
    
        rel_s_marked = gpx_data[row_idx].get("rel_s", 0.0)
        print(f"[DEBUG] set_begin => row_idx={row_idx}, rel_s_marked={rel_s_marked:.2f}")

        # ----------------------------------------------
        # FALL A) AutoVideoSync=OFF
        # ----------------------------------------------
        if not self._autoSyncVideoEnabled:
            print("[DEBUG] set_begin => CASE A (OFF)")
    
            if abs(global_video_s) < 0.01:
                # => Videozeit ~0 => wir schneiden GPX am markierten Punkt
                cut_start = rel_s_marked
                if cut_start < 0:
                    cut_start = 0.0
    
                # => Erstellen wir Undo-Snapshot => JETZT, weil wir sicher was ändern
                old_data = copy.deepcopy(gpx_data)
                self.gpx_widget.gpx_list._history_stack.append(old_data)
    
                i0 = 0
                while i0 < len(gpx_data):
                    if gpx_data[i0].get("rel_s", 0.0) >= cut_start:
                        break
                    i0 += 1
    
                if i0 > 0:
                    self.gpx_widget.gpx_list.set_markB_row(0)
                    self.gpx_widget.gpx_list.set_markE_row(i0 - 1)
                    self.gpx_widget.gpx_list.delete_selected_range()
    
                new_data = self.gpx_widget.gpx_list._gpx_data
                if new_data:
                    shift_s = new_data[0].get("rel_s", 0.0)
                    if shift_s > 0:
                        for pt in new_data:
                            pt["rel_s"] -= shift_s
                        recalc_gpx_data(new_data)
                    self.gpx_widget.set_gpx_data(new_data)
    
                QMessageBox.information(
                    self,
                    "Set Begin (OFF / Video=0s)",
                    "Cut GPX at the marked point.\n"
                    "Undo possible in GPX-liste."
                )
    
            else:
                # => global_video_s>0 => wir behalten global_video_s sek. vor markiertem
                cut_start = rel_s_marked - global_video_s
                if cut_start < 0:
                    # => Fehlermeldung => ABBRUCH => KEIN Undo
                    QMessageBox.warning(
                        self,
                        "Not enough GPX data",
                        f"You want to keep {global_video_s:.2f}s before {rel_s_marked:.2f}s,\n"
                        f"that starts at {cut_start:.2f}s < 0 => impossible.\n"
                        "Operation canceled."
                    )
                    return
    
                # => JETZT erst Undo-Snapshot => weil wir sicher etwas löschen
                old_data = copy.deepcopy(gpx_data)
                self.gpx_widget.gpx_list._history_stack.append(old_data)
    
                i0 = 0
                while i0 < len(gpx_data):
                    if gpx_data[i0].get("rel_s", 0.0) >= cut_start:
                        break
                    i0 += 1
    
                if i0 > 0:
                    self.gpx_widget.gpx_list.set_markB_row(0)
                    self.gpx_widget.gpx_list.set_markE_row(i0 - 1)
                    self.gpx_widget.gpx_list.delete_selected_range()
    
                new_data = self.gpx_widget.gpx_list._gpx_data
                if new_data:
                    shift_s = new_data[0].get("rel_s", 0.0)
                    if shift_s > 0:
                        for pt in new_data:
                            pt["rel_s"] -= shift_s
                        recalc_gpx_data(new_data)
                    self.gpx_widget.set_gpx_data(new_data)
    
                QMessageBox.information(
                    self,
                    "Set Begin (OFF / keepVideoTime)",
                    f"Kept {global_video_s:.2f}s before the marked GPX point.\n"
                    "Video remains unchanged.\n"
                    "Undo possible in GPX-liste."
                )
    
        # ----------------------------------------------
        # FALL B) AutoVideoSync=ON
        # ----------------------------------------------
        else:
            print("[DEBUG] set_begin => CASE B (ON)")
    
            # => wir schneiden in GPX am markierten Punkt => SHIFT => 0
            cut_start = rel_s_marked
            if cut_start < 0:
                cut_start = 0.0
    
            # => Undo-Snapshot => wir ändern definitiv was
            old_data = copy.deepcopy(gpx_data)
            self.gpx_widget.gpx_list._history_stack.append(old_data)
    
            i0 = 0
            while i0 < len(gpx_data):
                if gpx_data[i0].get("rel_s", 0.0) >= cut_start:
                    break
                i0 += 1
    
            if i0 > 0:
                self.gpx_widget.gpx_list.set_markB_row(0)
                self.gpx_widget.gpx_list.set_markE_row(i0 - 1)
                self.gpx_widget.gpx_list.delete_selected_range()
    
            new_data = self.gpx_widget.gpx_list._gpx_data
            if new_data:
                shift_s = new_data[0].get("rel_s", 0.0)
                if shift_s > 0:
                    for pt in new_data:
                        pt["rel_s"] -= shift_s
                    recalc_gpx_data(new_data)
                self.gpx_widget.set_gpx_data(new_data)
    
            # => Video => cut 0..global_video_s
            if global_video_s <= 0.01:
                QMessageBox.information(
                    self, "Set Begin (ON)",
                    "Video near 0s => no cut.\n"
                    "GPX cut at the point.\n"
                    "Undo in GPX-liste + Video possible."
                )
            else:
                self.cut_manager.markB_time_s = 0.0
                self.cut_manager.markE_time_s = global_video_s
                self.timeline.set_markB_time(0.0)
                self.timeline.set_markE_time(global_video_s)
                self.cut_manager.on_cut_clicked()
    
                QMessageBox.information(
                    self, "Set Begin (ON)",
                    f"Video cut at {global_video_s:.2f}s.\n"
                    f"GPX cut at {rel_s_marked:.2f}s.\n"
                    "Undo in GPX-liste + Video possible."
                )
    
        # -------------------------------------------
        #  (3) Chart / Map / MiniChart aktualisieren
        # -------------------------------------------
        final_data = self.gpx_widget.gpx_list._gpx_data
        if final_data:
            # chart
            self.chart.set_gpx_data(final_data)
            # mini chart
            if self.mini_chart_widget:
                self.mini_chart_widget.set_gpx_data(final_data)
            # map
            route_geojson = self._build_route_geojson_from_gpx(final_data)
            self.map_widget.loadRoute(route_geojson, do_fit=False)
        else:
            self.chart.set_gpx_data([])
            if self.mini_chart_widget:
                self.mini_chart_widget.set_gpx_data([])
            self.map_widget.loadRoute(None, do_fit=False)
    
        print("[DEBUG] on_set_begin_clicked => done.")
    
    def on_new_gpx_point_inserted(self, lat: float, lon: float, idx: int):
        """
        Wird aufgerufen, wenn aus dem map_page.html-JavaScript
        channelObj.newPointInserted(lat, lon, idx) getriggert wurde.
        
        - lat, lon: Koordinaten des neu eingefügten Punktes
        - idx: Kann sein:
            - -2 => Punkt VOR dem ersten
            - -1 => Punkt HINTER dem letzten
            - >=0 => Punkt zwischen idx und idx+1 (also 'zwischen zwei vorhandenen GPX-Punkten').

        NEU/ERWEITERT:
        Wenn Directions aktiviert sind (self._directions_enabled=True) und
        in der GPX-Liste aktuell der erste oder letzte Punkt selektiert ist,
        überschreiben wir das idx-Verhalten:

        1) Falls letzter Punkt selektiert => idx = -1 (Ans Ende anhängen)
        2) Falls erster Punkt selektiert  => idx = -2 (Vorne einfügen)

        Dadurch wird die Route – je nach gewähltem Startpunkt (B/E) – vorn oder hinten angefügt.
        """
        from datetime import datetime, timedelta
        import copy
        from core.gpx_parser import recalc_gpx_data

        gpx_data = self._gpx_data
        if not gpx_data:
            gpx_data = []
    
        # --- NEU: Falls Directions aktiv und es ist eindeutig "erster" oder "letzter" Punkt selektiert ---
        if self._directions_enabled:
            # Prüfen, welcher GPX-Punkt in der Liste selektiert ist
            row_selected = self.gpx_widget.gpx_list.table.currentRow()
            n = len(gpx_data)

            if row_selected >= 0 and n > 0:
                is_first = (row_selected == 0)
                is_last  = (row_selected == n-1)

                if is_last:
                    # => Wir wollen unbedingt ans Ende anfügen
                    idx = -1
                    # (markB=letzter, markE=neuer => B->E => "append")
                elif is_first:
                    # => Vor dem ersten einfügen
                    idx = -2
                    # (markE=erster, markB=neuer => B->E => "prepend")
                # Falls weder erster noch letzter => idx bleibt wie vom JS gesendet (z.B. -1 oder "zwischen")
    
        # --- Nun das "alte" Einfüge-Verhalten ---
        # Undo-Snapshot
        old_data = copy.deepcopy(gpx_data)
        self.gpx_widget.gpx_list._history_stack.append(old_data)

        now = datetime.now()  # Fallback, falls Zeit gar nicht existiert

        if idx == -2:
            # =============== Punkt VOR dem ersten einfügen ===============
            if not gpx_data:
                # Noch gar nichts drin => erster Punkt
                new_pt = {
                    "lat": lat,
                    "lon": lon,
                    "ele": 0.0,
                    "time": now,
                    "delta_m": 0.0,
                    "speed_kmh": 0.0,
                    "gradient": 0.0,
                    "rel_s": 0.0
                }
                gpx_data.append(new_pt)
            else:
                t_first = gpx_data[0]["time"]
                if not t_first:
                    t_first = now
                # NEUEN Punkt "vorne" einfügen => 
                # wir geben ihm dieselbe Zeit wie den alten ersten oder 1s davor
                new_time = t_first  # oder t_first - timedelta(seconds=1)
                new_pt = {
                    "lat": lat,
                    "lon": lon,
                    "ele": gpx_data[0].get("ele", 0.0),
                    "time": new_time,
                    "delta_m": 0.0,
                    "speed_kmh": 0.0,
                    "gradient": 0.0,
                    "rel_s": 0.0
                }
                gpx_data.insert(0, new_pt)
    
                # jetzt alle nachfolgenden +1s verschieben
                for i in range(1, len(gpx_data)):
                    oldt = gpx_data[i]["time"]
                    if oldt:
                        gpx_data[i]["time"] = oldt + timedelta(seconds=1)

        elif idx == -1:
            # =============== Punkt NACH dem letzten einfügen ===============
            if not gpx_data:
                # ganz leer => erster Punkt
                new_pt = {
                    "lat": lat,
                    "lon": lon,
                    "ele": 0.0,
                    "time": now,
                    "delta_m": 0.0,
                    "speed_kmh": 0.0,
                    "gradient": 0.0,
                    "rel_s": 0.0
                }
                gpx_data.append(new_pt)
            else:
                last_pt = gpx_data[-1]
                t_last = last_pt.get("time")
                if not t_last:
                    t_last = now
                new_time = t_last + timedelta(seconds=1)
                new_pt = {
                    "lat": lat,
                    "lon": lon,
                    "ele": last_pt.get("ele", 0.0),
                    "time": new_time,
                    "delta_m": 0.0,
                    "speed_kmh": 0.0,
                    "gradient": 0.0,
                    "rel_s": 0.0
                }
                gpx_data.append(new_pt)
    
        else:
            # =============== Punkt "zwischen" idx..idx+1 einfügen ===============
            if idx < 0:
                idx = 0
            if idx >= len(gpx_data):
                idx = len(gpx_data) -1  # safety

            if not gpx_data:
                # Falls wirklich nix da => wie "ende"
                new_pt = {
                    "lat": lat,
                    "lon": lon,
                    "ele": 0.0,
                    "time": now,
                    "delta_m": 0.0,
                    "speed_kmh": 0.0,
                    "gradient": 0.0,
                    "rel_s": 0.0
                }
                gpx_data.append(new_pt)
            else:
                base_pt = gpx_data[idx]
                t_base = base_pt.get("time")
                if not t_base:
                    t_base = now
                new_time = t_base + timedelta(seconds=1)

                new_pt = {
                    "lat": lat,
                    "lon": lon,
                    "ele": base_pt.get("ele", 0.0),
                    "time": new_time,
                    "delta_m": 0.0,
                    "speed_kmh": 0.0,
                    "gradient": 0.0,
                    "rel_s": 0.0
                }
                insert_pos = idx + 1
                if insert_pos > len(gpx_data):
                    insert_pos = len(gpx_data)
                gpx_data.insert(insert_pos, new_pt)

                # alle folgenden => +1s
                for j in range(insert_pos+1, len(gpx_data)):
                    t_old = gpx_data[j].get("time")
                    if t_old:
                        gpx_data[j]["time"] = t_old + timedelta(seconds=1)

        #  => recalc
        recalc_gpx_data(gpx_data)
        self.gpx_widget.set_gpx_data(gpx_data)
        self._gpx_data = gpx_data
    
        # Chart, Mini-Chart usw. aktualisieren
        self.chart.set_gpx_data(gpx_data)
        if self.mini_chart_widget:
            self.mini_chart_widget.set_gpx_data(gpx_data)

        # Map neu laden
        route_geojson = self._build_route_geojson_from_gpx(gpx_data)
        self.map_widget.loadRoute(route_geojson, do_fit=False)

        print(f"[INFO] Inserted new GPX point (DirectionsEnabled={self._directions_enabled}); total now {len(gpx_data)} pts.")

                
            
    ####################################################################
    def _on_reset_config_triggered(self):
        from PySide6.QtWidgets import QMessageBox
        from config import reset_config
    
        answer = QMessageBox.question(
            self,
            "Reset Config",
            "Do you really want to reset all QSettings?\n"
            "This will remove disclaimers, keys etc.\n"
            "You may have to restart the application.",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No
        )
        if answer == QMessageBox.Yes:
            reset_config()  # ruft s.clear()
            QMessageBox.information(
                self,
                "Reset done",
                "All config settings have been removed.\n"
                "Please restart the application."
            )
    
        
        
    
    def on_undo_clicked_video(self):
        """
        Wird aufgerufen, wenn im VideoControlWidget 'undo' geklickt wird.
        1) Video-Cut-Undo via cut_manager
        2) Falls autoSyncVideo=ON => GPX-Liste => undo_delete()
        """
        # 1) Video-Undo:
        self.map_widget.view.page().runJavaScript("showLoading('Undo GPX-Range...');")
        self.cut_manager.on_undo_clicked()

        # 2) Falls autosync ON => GPX-Liste => undo_delete
        if self._autoSyncVideoEnabled:
            print("[DEBUG] on_undo_clicked_video => autoSyncVideo=ON => gpx_list.undo_delete()")
            self.gpx_widget.gpx_list.undo_delete()
    
        # ggf. Chart, Map updaten => du machst das schon in on_undo_range_clicked ?
        self._update_gpx_overview()
        self._gpx_data = self.gpx_widget.gpx_list._gpx_data
        route_geojson = self._build_route_geojson_from_gpx(self._gpx_data)
        self.map_widget.loadRoute(route_geojson, do_fit=False)
        self.chart.set_gpx_data(self._gpx_data)
        if self.mini_chart_widget:
            self.mini_chart_widget.set_gpx_data(self._gpx_data)
    
        self.map_widget.view.page().runJavaScript("hideLoading();")
        
    def on_cut_clicked_video(self):
        """
        Wird aufgerufen, wenn der 'cut'-Button im VideoControlWidget gedrückt wird.
        1) Führt den normalen Video-Cut via cut_manager durch
        2) Falls autoSyncVideo ON => Löschen wir im GPXList ebenfalls B..E
        """
        # 1) Video-Cut
        self.cut_manager.on_cut_clicked()
        

        # 2) autoSyncVideo?
        if self._autoSyncVideoEnabled and self.action_edit_video.isChecked():
            self.map_widget.view.page().runJavaScript("showLoading('Deleting GPX-Range...');")
            print("[DEBUG] autoSyncVideo=ON => rufe gpx_list.delete_selected_range()")
            self.gpx_widget.gpx_list.delete_selected_range()
            self.map_widget.clear_marked_range()
        
            self._update_gpx_overview()  
            self._gpx_data = self.gpx_widget.gpx_list._gpx_data
            route_geojson = self._build_route_geojson_from_gpx(self._gpx_data)
            self.map_widget.loadRoute(route_geojson, do_fit=False)
            self.chart.set_gpx_data(self._gpx_data)
            self.map_widget.view.page().runJavaScript("hideLoading();")
        else:
            pass    
        
        
    def _on_auto_sync_video_toggled(self, checked: bool):
        """
        Wird aufgerufen, wenn der Menüpunkt "AutoSyncVideo" an-/abgehakt wird.
        => Speichere den Zustand in self._autoSyncVideoEnabled
        """    
        if checked and not self.action_edit_video.isChecked():
            # -> nicht erlaubt
            QMessageBox.warning(
                self,
                "AutoCutVideo+GPX requires Edit Mode",
                "You can only enable AutoCutVideo+GPX if 'Edit Video' is enabled.\n"
                "Please enable 'Edit Video' first."
            )
            # Checkbox zurücksetzen
            self.action_auto_sync_video.setChecked(False)
            return

        
        print(f"[DEBUG] _on_auto_sync_video_toggled => {checked}")
        self._autoSyncVideoEnabled = checked
        self.gpx_control.set_markE_visibility(not checked)
        
        
        if checked:
            self.video_editor.acut_status_label.setText("V&G:On")
            self.video_editor.acut_status_label.setStyleSheet(
                "background-color: rgba(0,0,0,120); "
                "color: red; "
                "font-size: 14px; "
                "font-weight: bold;"
                "padding: 2px;"
            )
        else:
            self.video_editor.acut_status_label.setText("")
            #self.video_editor.acut_status_label.setText("V&G:Off")
            #self.video_editor.acut_status_label.setStyleSheet(
            #    "background-color: rgba(0,0,0,120); "
            #    "color: grey; "
            #    "font-size: 14px; "
            #    "font-weight: normal;"
            #    "padding: 2px;"
            #)
        
        if self.gpx_control:
            self.gpx_control.update_set_gpx2video_state(
                video_edit_on=self.action_edit_video.isChecked(),
                auto_sync_on=checked
            )
        
    def on_delete_range_clicked(self):
        """
        Wird ausgelöst, wenn der Delete-Button (Mülleimer) 
        im gpx_control_widget geklickt wurde.
        => Leitet an die gpx_list weiter.
        """
        self.map_widget.view.page().runJavaScript("showLoading('Deleting GPX-Range...');")
        self.gpx_widget.gpx_list.delete_selected_range()
        self._update_gpx_overview()
        self._gpx_data = self.gpx_widget.gpx_list._gpx_data
        route_geojson = self._build_route_geojson_from_gpx(self._gpx_data)
        self.map_widget.loadRoute(route_geojson, do_fit=False)
        self.chart.set_gpx_data(self._gpx_data)
        
        if self.mini_chart_widget and self._gpx_data:
            self.mini_chart_widget.set_gpx_data(self._gpx_data)
        
        self.map_widget.view.page().runJavaScript("hideLoading();")

    
    def _update_gpx_overview(self):
        data = self.gpx_widget.gpx_list._gpx_data
        if not data:
            self.gpx_control.update_info_line(
                video_time_str="00:00:00",
                length_km=0.0,
                duration_str="00:00:00",
                elev_gain=0.0
            )
            return

        # 1) Länge in km
        total_dist_m = sum(pt.get("delta_m", 0.0) for pt in data)
        length_km = total_dist_m / 1000.0
    
        # 2) Höhengewinn
        elev_gain = 0.0
        for i in range(1, len(data)):
            dh = data[i]["ele"] - data[i-1]["ele"]
            if dh > 0:
                elev_gain += dh

        # 3) GPX-Dauer berechnen (time[-1] - time[0])
        from datetime import datetime
        start_t = data[0].get("time")
        end_t   = data[-1].get("time")
        if start_t and end_t:
            total_sec = (end_t - start_t).total_seconds()
        else:
            total_sec = 0.0
        if total_sec < 0:
            total_sec = 0.0
    
        # => In h:mm:ss formatieren
        gpx_hh = int(total_sec // 3600)
        gpx_mm = int((total_sec % 3600) // 60)
        gpx_ss = int(total_sec % 60)
        gpx_duration_str = f"{gpx_hh:02d}:{gpx_mm:02d}:{gpx_ss:02d}"
    
        # 4) Videolänge (z.B. final nach Cuts)
        total_dur = self.real_total_duration        # Roh-Gesamtlänge aller Videos
        sum_cuts  = self.cut_manager.get_total_cuts()
        final_dur = total_dur - sum_cuts
        if final_dur < 0:
            final_dur = 0
        vid_hh = int(final_dur // 3600)
        vid_mm = int((final_dur % 3600) // 60)
        vid_ss = int(final_dur % 60)
        video_time_str = f"{vid_hh:02d}:{vid_mm:02d}:{vid_ss:02d}"
    
        # 5) Weitere Werte wie slope_max/min etc.
        slope_vals = [pt.get("gradient", 0.0) for pt in data]
        slope_max = max(slope_vals) if slope_vals else 0.0
        slope_min = min(slope_vals) if slope_vals else 0.0
    
        zero_thr = self.chart.zero_speed_threshold()
        zero_speed_count = sum(
            1
            for i, pt in enumerate(data)
            if i > 0 and pt.get("speed_kmh", 0.0) < zero_thr
        )
    
        paused_count = 0
        for i in range(1, len(data)):
            dt = data[i]["rel_s"] - data[i-1]["rel_s"]
            if dt > 1.0:
                paused_count += 1
    
        # 6) An Dein gpx_control_widget übergeben
        self.gpx_control.update_info_line(
            video_time_str=video_time_str,     # Das ist Deine Video-Dauer
            length_km=length_km,
            duration_str=gpx_duration_str,     # DAS ist die Track-Dauer 
            elev_gain=elev_gain,
            slope_max=slope_max,
            slope_min=slope_min,
            zero_speed_count=zero_speed_count,
            paused_count=paused_count
        )


    
        
      
    def on_map_sync_idx(self, gpx_index: int):
       
        print(f"[DEBUG] on_map_sync_idx => idx={gpx_index}")

        # 0) Index-Prüfung
        if not (0 <= gpx_index < len(self._gpx_data)):
            print("[DEBUG] on_map_sync_idx => invalid gpx_index or no gpx_data loaded.")
            return

        # 1) GPX-Punkt auslesen
        point = self._gpx_data[gpx_index]
        print(f"[DEBUG] on_map_sync_idx => point={point}")

        rel_s = point.get("rel_s", 0.0)

        hh = int(rel_s // 3600)
        mm = int((rel_s % 3600) // 60)
        ss = int(rel_s % 60)

        
    
        # Extra Debug:
        print(f"[DEBUG] => resolved time => hh={hh}, mm={mm}, ss={ss}")

        # 4) Aufruf => on_time_hms_set_clicked(hh, mm, ss)
        self.on_time_hms_set_clicked(hh, mm, ss)
        #self.on_time_hms_set_clicked(hh, mm, ss)
        
    
        
        
    def on_user_selected_index(self, new_index: int):
        """
        Zentrale Methode für Klicks in Map oder GPX-Liste (im Pause-Modus).
        Wir entfernen die 'Loch'-Logik, sodass ein roter Punkt beim Anklicken
        NICHT mehr schwarz wird, sondern auch gelb.

        1) Alten gelben Punkt revertieren,
        2) Neuer Punkt => immer gelb (egal ob B..E oder nicht),
        3) Liste -> dieselbe Zeile gelb selektieren.
        """

        # 1) Bisherigen gelben Punkt in Map revertieren, falls vorhanden
       
        if self.video_editor.is_playing:
            self.map_widget.show_yellow(new_index)
        else:
            self.map_widget.show_blue(new_index)
        

        # 3) Liste: dieselbe Zeile gelb machen
        #    => so bleibt Map und Liste synchron
        self.gpx_widget.gpx_list.select_row_in_pause(new_index)
        self.chart.highlight_gpx_index(new_index)


    
        
    def _on_markB_in_list(self, b_idx: int):
        """ 
        Wird ausgelöst, wenn die GPXList MarkB gesetzt hat.
        => Wir rufen jetzt map_widget.set_markB_point(...) (neue JS-Funktion).
        """
        if self.map_widget:
            self.map_widget.set_markB_point(b_idx)
            self.map_widget.set_markB_idx(b_idx)

    def _on_markE_in_list(self, e_idx: int):
        if self.map_widget:
            self.map_widget.set_markE_point(e_idx)
            self.map_widget.set_markE_idx(e_idx)

    def _on_clear_in_list(self):
        if self.map_widget:
            self.map_widget.clear_marked_range()
            self.map_widget.set_markB_idx(None)
            self.map_widget.set_markE_idx(None)
        
    
    def on_point_moved(self, index: int, lat: float, lon: float):
        
        gpx_data = self.gpx_widget.gpx_list._gpx_data
        if not gpx_data:
            return
    
        # 1) Undo-Snapshot (gesamte GPX-Daten kopieren)
        import copy
        old_data = copy.deepcopy(gpx_data)
        self.gpx_widget.gpx_list._history_stack.append(old_data)
        
        """
        Wird aufgerufen, wenn der User in der Karte einen GPX-Punkt verschoben hat.
        """
        print(f"[MainWindow] on_point_moved => idx={index}, lat={lat}, lon={lon}")

        if 0 <= index < len(self._gpx_data):
            self._gpx_data[index]["lat"] = lat
            self._gpx_data[index]["lon"] = lon
            from core.gpx_parser import recalc_gpx_data
            recalc_gpx_data(self._gpx_data)
            

            # Falls du Distanz/Speed neu berechnen willst => optional
            #new_geojson = self._build_route_geojson_from_gpx(self._gpx_data)

            # ENTSCHEIDUNG: 
            # => do_fit=False => bleibe im aktuellen Ausschnitt 
            # => do_fit=True  => zoome wieder raus
            #self.map_widget.loadRoute(new_geojson, do_fit=False)

            # Tabelle updaten (damit man es auch sieht)
            self.gpx_widget.set_gpx_data(self._gpx_data)  
            self._update_gpx_overview()
            self.chart.set_gpx_data(self._gpx_data)
        else:
            print("[WARN] Index war außerhalb des GPX-Datenbereichs.")

    

    def _build_route_geojson_from_gpx(self, data):
        """
        data: Liste von Dicts => [{'lat':..., 'lon':...}, ...]
        Gibt FeatureCollection mit 1x Linestring + Nx Points zurück,
        wobei jeder Point => properties.index = i hat.
        """
        features = []

        # Linestring-Koords
        coords_line = []
        for i, pt in enumerate(data):
            coords_line.append([pt["lon"], pt["lat"]])

        line_feat = {
            "type": "Feature",
            "geometry": {
                "type": "LineString",
                "coordinates": coords_line
            },
            "properties": { "color": "#000000" }
        }
        features.append(line_feat)

        # Einzelne Punkt-Features
        for i, pt in enumerate(data):
            point_feat = {
                "type": "Feature",
                "geometry": {
                    "type": "Point",
                    "coordinates": [pt["lon"], pt["lat"]]
                },
                "properties": {
                    "index": i,
                    "color": "#000000"
                }
            }
            features.append(point_feat)

        return {
            "type": "FeatureCollection",
            "features": features
        }

    
    # -----------------------------------------------------------------------
    # Methoden und Slots (weitgehend unverändert)
    # -----------------------------------------------------------------------
    
    def format_seconds_to_hms(self, secs: float) -> tuple[int,int,int]:
        s_rounded = round(secs)
        h = s_rounded // 3600
        m = (s_rounded % 3600) // 60
        s = (s_rounded % 60)
        return (h, m, s)
    
    
    
   
    def on_markB_clicked_video(self):
        """
        Wird     aufgerufen, wenn man im VideoControlWidget den Button '[-' klickt.
        """
        # 1) Falls AutoSync=OFF => verhalte dich wie bisher (ohne +1).
        # 2) Falls AutoSync=ON  => *erst* Video/GPS syncen, dann +1 in der GPX-Liste.
        #
        if not self._autoSyncVideoEnabled:
            # => KEIN +1
            row = self.gpx_widget.gpx_list.table.currentRow()
            if row < 0:
                return
            #self.gpx_widget.gpx_list.set_markB_row(row)
            self.map_widget.set_markB_point(row)
        
            # cut_manager, timeline
            global_s = self.video_editor.get_current_position_s()  # = globale Sekunde
            self.cut_manager.markB_time_s = global_s
            self.timeline.set_markB_time(global_s)
            
            
        
        else:
            # => AutoCutVideo+GPX = ON
            #    typischerweise machen wir 'Sync': wir holen uns die globale Zeit
            global_s = self.video_editor.get_current_position_s()
            final_s = self.get_final_time_for_global(global_s)  # falls du final<->global rechnest
            best_idx = self.gpx_widget.get_closest_index_for_time(final_s)
        
            # Das +1:
            row = best_idx + 1
        
            # Klemme, falls row jenseits der letzten Zeile liegt
            maxrow = len(self.gpx_widget.gpx_list._gpx_data) - 1
            if row > maxrow:
                row = maxrow
        
            E_s = self.cut_manager.markE_time_s
            if E_s >= 0 and global_s >= E_s:
                from PySide6.QtWidgets import QMessageBox
                QMessageBox.warning(
                    self,
                    "Invalid MarkB",
                    f"You cannot set MarkB ({global_s:.2f}s) behind MarkE ({E_s:.2f}s)!"
                )
                return  # => Abbruch, nichts weiter setzen
        
            self.gpx_widget.gpx_list.set_markB_row(row)
            self.map_widget.set_markB_point(row)
            
            # Und analog ins cut_manager
            self.cut_manager.markB_time_s = global_s
            self.timeline.set_markB_time(global_s)

    

    def on_markE_clicked(self):
        print("[DEBUG] Alter markE")
        return
        
       

    
    def _on_markE_from_video(self):
        print("[DEBUG] MarkE from Video")
        
        if not self._autoSyncVideoEnabled:
            row = self.gpx_widget.gpx_list.table.currentRow()
            if row < 0:
                return
            #self.gpx_widget.gpx_list.set_markE_row(row)
            self.map_widget.set_markE_point(row)
            
            global_s = self.video_editor.get_current_position_s()
            self.cut_manager.markE_time_s = global_s
            self.timeline.set_markE_time(global_s)
        else:
            # AutoSync=ON
            global_s = self.video_editor.get_current_position_s()
            final_s  = self.get_final_time_for_global(global_s)
            best_idx = self.gpx_widget.get_closest_index_for_time(final_s)
            
           
            row = best_idx
            # clamp ...
            if row < 0:
                return
            maxrow = len(self.gpx_widget.gpx_list._gpx_data)-1
            if row > maxrow:
                row = maxrow
                
            B_s = self.cut_manager.markB_time_s
            if B_s >= 0 and global_s <= B_s:
                from PySide6.QtWidgets import QMessageBox
                QMessageBox.warning(
                    self,
                    "Invalid MarkE",
                    f"You cannot set MarkE ({global_s:.2f}s) in front of MarkB ({B_s:.2f}s)!"
                )
                return  # => Abbruch    
            
            self.gpx_widget.gpx_list.set_markE_row(row)
            self.map_widget.set_markE_point(row)
            
            self.cut_manager.markE_time_s = global_s
            self.timeline.set_markE_time(global_s)
    
    def _on_markE_from_gpx(self):
        print("[DEBUG] Mark E from gpx")
        
        
        if not self._autoSyncVideoEnabled:
            row = self.gpx_widget.gpx_list.table.currentRow()
            if row < 0:
                return
            self.gpx_widget.gpx_list.set_markE_row(row)
            self.map_widget.set_markE_point(row)
            
            #global_s = self.video_editor.get_current_position_s()
            #self.cut_manager.markE_time_s = global_s
            #self.timeline.set_markE_time(global_s)
        else:
            # AutoSync=ON
            global_s = self.video_editor.get_current_position_s()
            final_s  = self.get_final_time_for_global(global_s)
            best_idx = self.gpx_widget.get_closest_index_for_time(final_s)
            
           
            row = best_idx
            # clamp ...
            if row < 0:
                return
            maxrow = len(self.gpx_widget.gpx_list._gpx_data)-1
            if row > maxrow:
                row = maxrow
                
            B_s = self.cut_manager.markB_time_s
            if B_s >= 0 and global_s <= B_s:
                from PySide6.QtWidgets import QMessageBox
                QMessageBox.warning(
                    self,
                    "Invalid MarkE",
                    f"You cannot set MarkE ({global_s:.2f}s) in front of MarkB ({B_s:.2f}s)!"
                )
                return  # => Abbruch    
            
            self.gpx_widget.gpx_list.set_markE_row(row)
            self.map_widget.set_markE_point(row)
            
            self.cut_manager.markE_time_s = global_s
            self.timeline.set_markE_time(global_s)
    
    
    
    
    #neu2
    def _on_gpx_list_pause_clicked(self, row_idx: int):
        if not self.video_editor.is_playing:
            # Statt select_point_in_pause => show_blue
            #self.map_widget.show_blue(row_idx)
            self.map_widget.show_blue(row_idx, do_center=True)
            self.chart.highlight_gpx_index(row_idx)

    def _on_map_pause_clicked(self, index: int):
        """
        Wird aufgerufen, wenn im Pause-Modus in der Karte
        ein Punkt geklickt wurde.
        => Markiere denselben Index in der GPX-Liste!
        """
        if not self.video_editor.is_playing:
            self.gpx_widget.gpx_list.select_row_in_pause(index)
            self.chart.highlight_gpx_index(index)
    #neu2


    def _show_copyright_dialog(self):
        
        counts = self._fetch_counters_from_server()
        if counts:
            vcount = counts.get("video", 0)
            gcount = counts.get("gpx", 0)
        else:
            vcount, gcount = 0, 0
        
        msg = QMessageBox(self)
        msg.setWindowTitle("Copyright")
        msg.setText(
            "<h3>VGSync - Video and GPX Sync Tool</h3>"
            f"Version: {APP_VERSION}<br><br>"
            "©2025 by Bernd Eller<br>All rights reserved.<br><br>"
            "This software is for private use only. Commercial use is strictly prohibited.<br><br>"
        
            "<h3>End User License Agreement (EULA)</h3>"
            "By using this software, you agree to our <a href='http://vgsync.casa-eller.de/vgsync_eula.pdf'>End User License Agreement</a>.<br><br>"
        
            "<h3>Third-Party Libraries</h3>"
            "This application uses open-source software:<br>"
            "<b>1. FFmpeg</b> - <a href='https://ffmpeg.org'>ffmpeg.org</a> (LGPL v2.1 or later)<br>"
            "<b>2. mpv</b> - <a href='https://mpv.io'>mpv.io</a> (LGPL v2.1 or later)<br><br>"
        
            "The full license texts can be found in the <code>LICENSES</code> inside the mpv and ffmpeg directories.<br><br>"
            
            "<b>By clicking 'I Accept', you acknowledge that you have read and understood the terms.</b><br><br>"
            f"V: {vcount}  G: {gcount}</b>"
        )

        #msg.setText("  VGSync V1.0  \t\n\n\n©2025 by Bernd Eller.\n    All rights reserved.    ")
        msg.exec()
    
   

    
        

    def _on_timer_mode_changed(self):
        if self.action_global_time.isChecked():
            self._time_mode = "global"
        elif self.action_final_time.isChecked():
            self._time_mode = "final"
        self.update_timeline_marker()
        self.video_editor.set_time_mode(self._time_mode)    

    def _get_offset_for_filepath(self, video_path):
        try:
            idx = self.playlist.index(video_path)
        except ValueError:
            return 0.0
        return sum(self.video_durations[:idx])

   

   
    # Im MainWindow (oder ImportExportManager, wo du es hast)
    def start_indexing_process(self, video_path):
        from .dialogs import _IndexingDialog

        dlg = _IndexingDialog(video_path, parent=self)
        dlg.indexing_extracted.connect(self.on_extract_finished)
        dlg.start_indexing()

        # => Wichtig:
        dlg.show()
        from PySide6.QtWidgets import QApplication
        QApplication.processEvents()

        dlg.raise_()
        dlg.activateWindow()

        result = dlg.exec()
        if result == QDialog.Accepted:
            print("[DEBUG] IndexingDialog => Accepted")
        else:
            print("[DEBUG] IndexingDialog => Rejected/Closed")

   


    def on_extract_finished(self, video_path, temp_dir):
        """
        Wird aufgerufen, wenn das Indexing-Tool die CSV-Datei erstellt hat.
        Hier rufen wir dann self.run_merge(...) auf.
        """
        print("[DEBUG] on_extract_finished => rufe run_merge an ...")
    
        import os
        base_name = os.path.splitext(os.path.basename(video_path))[0]
    
        # BAUE den CSV-Dateinamen
        csv_path = os.path.join(temp_dir, f"keyframes_{base_name}_ffprobe.csv")
    
        # Jetzt run_merge aufrufen
        self.run_merge(
            video_path=video_path,
            csv_file=csv_path,     # <-- Hier definieren wir csv_path
            temp_dir=temp_dir
        )
    
    # -----------------------------------------------------------------------
    # Detach-Funktionen Video
    # -----------------------------------------------------------------------
    def _toggle_video(self):
        if self._video_area_floating_dialog is None:
            self._detach_video_area_widget()
            self.action_toggle_video.setText("Video (attach)")
        else:
            self._reattach_video_area_widget()
            self.action_toggle_video.setText("Video (detach)")

    def _reattach_video_area_widget(self):
        if not self._video_area_floating_dialog:
            return

        # 1) Dialog schließen
        self._video_area_floating_dialog.close()
        self._video_area_floating_dialog = None
    
        # 2) Platzhalter entfernen
        if self._video_placeholder is not None:
            idx = self.left_v_layout.indexOf(self._video_placeholder)
            if idx >= 0:
                self.left_v_layout.removeWidget(self._video_placeholder)
            self._video_placeholder.deleteLater()
            self._video_placeholder = None

        # 3) Video wieder einfügen (am selben Index)
        #    Falls du es wieder ganz oben haben willst, kannst du idx=0 nehmen
        self.left_v_layout.insertWidget(0, self.video_area_widget, 1)

       


    def _detach_video_area_widget(self):
        if self._video_area_floating_dialog is not None:
            # Schon abgekoppelt
            return

        # 1) Platzhalter erstellen (falls du ihn farblich hervorheben willst)
        #self._video_placeholder = QFrame()
        #self._video_placeholder.setStyleSheet("background-color: #444;")

        # 2) Index des video_area_widget im left_v_layout suchen
        idx = self.left_v_layout.indexOf(self.video_area_widget)
        if idx < 0:
            # Falls nicht gefunden => wir brechen lieber ab
            return
            
            
        self.left_v_layout.removeWidget(self.video_area_widget)
        self._video_placeholder = QFrame()
        self._video_placeholder.setStyleSheet("background-color: #444;")    

        # 3) An dieser Position den Platzhalter einfügen
        self.left_v_layout.insertWidget(idx, self._video_placeholder, 1)

        # 4) Das video_area_widget aus dem Layout entfernen
        #self.left_v_layout.removeWidget(self.video_area_widget)

        # 5) In einem neuen Dialog unterbringen
        dlg = DetachDialog(self)
        dlg.setWindowTitle("Video Editor (Detached)")
        dlg.setWindowFlags(Qt.Window | Qt.WindowMinimizeButtonHint | Qt.WindowMaximizeButtonHint)

        layout = QVBoxLayout(dlg)
        layout.addWidget(self.video_area_widget)

        # Signale für + / - / Reattach
        dlg.requestPlus.connect(self._on_detached_plus)
        dlg.requestMinus.connect(self._on_detached_minus)
        dlg.requestReattach.connect(self._on_request_reattach_floating)

        self._video_area_floating_dialog = dlg
        dlg.show()

        # Nach dem Anzeigen neu binden
        QTimer.singleShot(10, lambda: self._after_show_detached(dlg))
        
    
    

    def _after_show_detached(self, dlg: QDialog):
        this_screen = dlg.screen()
        if not this_screen:
            from PySide6.QtGui import QGuiApplication
            this_screen = QGuiApplication.primaryScreen()
        scr_geom = this_screen.availableGeometry()

        new_w = int(scr_geom.width() * 0.7)
        new_h = int(scr_geom.height() * 0.7)
        dlg.resize(new_w, new_h)

        frame_geo = dlg.frameGeometry()
        frame_geo.moveCenter(scr_geom.center())
        dlg.move(frame_geo.topLeft())

        

    def _on_request_reattach_floating(self):
        self._reattach_video_area_widget()

    def _on_detached_plus(self):
        if self.speed_index < len(self.vlc_speeds) - 1:
            self.speed_index += 1
        self.current_rate = self.vlc_speeds[self.speed_index]
        self.video_editor.set_playback_rate(self.current_rate)

    def _on_detached_minus(self):
        if self.speed_index > 0:
            self.speed_index -= 1
        self.current_rate = self.vlc_speeds[self.speed_index]
        self.video_editor.set_playback_rate(self.current_rate)    

    
   
    def load_mp4_files(self):
       
        
        files, _ = QFileDialog.getOpenFileNames(
            self,
            "Load MP4 files",
            "",
            "Video Files (*.mp4 *.mov *.mkv *.avi)",
        )
        if not files:
            return

        # 1) Alle ausgewählten Dateien in die Playlist hängen,
        #    ohne zwischendurch den Player zu starten:
        for file_path in files:
            self.add_to_playlist(file_path)

        # 2) Timeline neu berechnen
        self.rebuild_timeline()

        # 3) Erst am Ende einmal den ersten Frame vom allerersten Video zeigen:
        if self.playlist:
            self.video_editor.show_first_frame_at_index(0)

        QMessageBox.information(self, "Loaded", f"{len(files)} video(s) added to the playlist.")
    
   
    def _set_gpx_data(self, gpx_data):
        """Integriere die Daten in UI + merke sie in self._gpx_data."""
        self._gpx_data = gpx_data
        self.gpx_widget.set_gpx_data(gpx_data)

        self.chart.set_gpx_data(gpx_data)
        if self.mini_chart_widget:
            self.mini_chart_widget.set_gpx_data(gpx_data)

        route_geojson = self._build_route_geojson_from_gpx(gpx_data)
        self.map_widget.loadRoute(route_geojson, do_fit=True)

        self._update_gpx_overview()
        self.check_gpx_errors(gpx_data)

    def _parse_and_set_gpx(self, file_path, mode="new"):
        """
        Parst die GPX-Datei und hängt sie je nach mode ("new" vs. "append")
        an die vorhandene self._gpx_data an.
        """
        # 1) Kurzes Loading-Overlay oder Statusmeldung
        self.map_widget.view.page().runJavaScript("showLoading('Parsing GPX...');")
        QApplication.processEvents()

        # 2) PARSEN
        try:
            new_data = parse_gpx(file_path)
            ensure_gpx_stable_ids(new_data)
            if not new_data:
                QMessageBox.warning(self, "Load GPX", "File is empty or invalid.")
                self.map_widget.view.page().runJavaScript("hideLoading();")
                return
        except Exception as e:
            QMessageBox.critical(self, "Load GPX", f"Error parsing file:\n{e}")
            self.map_widget.view.page().runJavaScript("hideLoading();")
            return

        # 3) Je nach mode: "new" vs "append"
        if mode == "new" or (not self._gpx_data):
            # => alte Daten verwerfen
            self._set_gpx_data(new_data)
            QMessageBox.information(self, "Load GPX", "New GPX loaded successfully.")
        elif mode == "append":
            if not self._gpx_data:
                # falls aus irgendeinem Grund doch leer => wie "new"
                self._set_gpx_data(new_data)
            else:
                # => an vorhandene Daten dranhängen
                old_data = self._gpx_data

                # Optional: Undo-Snapshot
                old_snapshot = self.copy.deepcopy(old_data)
                self.gpx_widget.gpx_list._history_stack.append(old_snapshot)

                old_end_time = old_data[-1]["time"]  # datetime
                gap_start = old_end_time + timedelta(seconds=1)
                shift_dt = gap_start - new_data[0]["time"]
                shift_s = shift_dt.total_seconds()

                # alle Zeitstempel verschieben
                for pt in new_data:
                    pt["time"] = pt["time"] + shift_dt
                    pt["rel_s"] += shift_s

                merged_data = old_data + new_data
                recalc_gpx_data(merged_data)
                self._set_gpx_data(merged_data)

                QMessageBox.information(self, "Load GPX", "GPX appended successfully.")

        # 4) Overlay beenden
        self.map_widget.view.page().runJavaScript("hideLoading();")

   
    def load_gpx_file(self):
        # (A) Wenn schon GPX da ist => sofort Dialog
        if self._gpx_data:
            msg_box = QMessageBox(self)
            msg_box.setWindowTitle("Load GPX")
            msg_box.setText("A GPX is already loaded.\n"
                            "Do you want to start a new GPX or append the new file?")
            new_btn = msg_box.addButton("New", QMessageBox.AcceptRole)
            append_btn = msg_box.addButton("Append", QMessageBox.YesRole)
            cancel_btn = msg_box.addButton("Cancel", QMessageBox.RejectRole)

            msg_box.setWindowModality(Qt.WindowModal)
            msg_box.show()
            QApplication.processEvents()  # damit man ihn sofort sieht

            msg_box.exec()
            clicked = msg_box.clickedButton()
            if clicked == cancel_btn:
                return  # Nutzer hat abgebrochen
            elif clicked == new_btn:
                mode = "new"
            else:
                mode = "append"
        else:
            # => Noch keine GPX => Modus: new
            mode = "new"
    
            
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "Select GPX File",
            "",
            "GPX Files (*.gpx)",
        )
        if not file_path:
            return  # Abbruch
    
        
        self.map_widget.view.page().runJavaScript("showLoading('Loading GPX...');")
        QApplication.processEvents()
    
        # parse, ensureIDs, etc.
        new_data = parse_gpx(file_path)
        if not new_data:
            QMessageBox.warning(self, "Load GPX", "File is empty or invalid.")
            self.map_widget.view.page().runJavaScript("hideLoading();")
            return
    
        if mode == "new":
            self._set_gpx_data(new_data)
            QMessageBox.information(self, "Load GPX", "New GPX loaded successfully.")
        elif mode == "append":
            if not self._gpx_data:
                # Falls doch leer => wie new
                self._set_gpx_data(new_data)
            else:
                # => alte + neue zusammen
                old_data = self._gpx_data
    
                # optional Undo
                old_snapshot = self.copy.deepcopy(old_data)
                self.gpx_widget.gpx_list._history_stack.append(old_snapshot)
    
                from datetime import timedelta
                old_end_time = old_data[-1]["time"]
                gap_start = old_end_time + timedelta(seconds=1)
                shift_dt = gap_start - new_data[0]["time"]
    
                shift_s = shift_dt.total_seconds()
                for pt in new_data:
                    pt["time"] = pt["time"] + shift_dt
                    pt["rel_s"] += shift_s
    
                merged_data = old_data + new_data
                recalc_gpx_data(merged_data)
                self._set_gpx_data(merged_data)
                QMessageBox.information(self, "Load GPX", "GPX appended successfully.")
    
        self.map_widget.view.page().runJavaScript("hideLoading();")
        
    
    
    def update_timeline_marker(self):
        
        """
        Wird periodisch aufgerufen (z.B. alle 200ms) und aktualisiert:
        - Timeline:   Setzt den Marker
        - VideoEditor-Label:  Zeigt die aktuelle Zeit
        - VideoControl:       Setzt h:m:s
        - GPX/Map/Chart:      Wandert mit, solange is_playing=True
        """
        # 1) Aktuelle (globale) Videoposition abfragen:
        global_s = self.video_editor.get_current_global_time()
        if global_s < 0:
            global_s = 0.0
    
        # 2) Unterscheide, ob wir final oder global anzeigen wollen:
        if self._time_mode == "final":
            display_time = self.get_final_time_for_global(global_s)
        else:
            display_time = global_s
        
        # 3) Timeline-Marker (immer in "global" Koordinaten):
        self.timeline.set_marker_position(global_s)
        
        # 4) Zeit im VideoEditor-Label & VideoControl anzeigen
        s_rounded = round(display_time)
        hh = s_rounded // 3600
        mm = (s_rounded % 3600) // 60
        ss = s_rounded % 60
    
        self.video_editor.set_current_time(display_time)
        self.video_control.set_hms_time(hh, mm, ss)

        # 5) Wenn das Video gerade läuft => aktualisieren wir GPX/Map/Chart
        if self.video_editor.is_playing:
            # a) Welche "finale" Zeit markiert werden soll, hängt wieder vom Mode ab
            if self._time_mode == "final":
                final_s = display_time
            else:
                # falls _time_mode == "global", konvertieren wir global_s zu final_s
                final_s = self.get_final_time_for_global(global_s)
        
            # b) GPX-Widget highlighten
            self.gpx_widget.highlight_video_time(final_s, is_playing=True)

            # c) Index im GPX finden
            i = self.gpx_widget.get_closest_index_for_time(final_s)
        
            # d) Chart-Index highlighten
            self.chart.highlight_gpx_index(i)
        
            # e) Mini-Chart ebenfalls
            if self.mini_chart_widget:
                self.mini_chart_widget.set_current_index(i)
        
            # f) Map => gelben Marker
            self.map_widget.show_yellow(i)
        else:
            # Video pausiert => kein automatisches "Mitlaufen" in Map/GPX
            pass

    
    
    def _on_chart_marker_clicked(self, index: int):
        """
        Wird aufgerufen, wenn man im ChartWidget an Position index klickt.
        => Dann selektieren wir diesen index in gpx_list und Map, 
        und ggf. Video an diese Stelle spulen.
        """
        print(f"[DEBUG] _on_chart_marker_clicked => idx={index}")
        # 1) gpx_list => select_row_in_pause
        if not self.video_editor.is_playing:
            self.gpx_widget.gpx_list.select_row_in_pause(index)
            # => map
            #self.map_widget.select_point_in_pause(index)
            self.map_widget.show_blue(index, do_center=True)
            #self.map_widget.show_blue(index)
            self.chart.highlight_gpx_index(index)
        else:
            # Wenn Video gerade läuft => evtl. jump dorthin
            # ... oder du pausierst / oder was du willst
            pass

       
        self.chart.highlight_gpx_index(index)


    

    
    def add_to_playlist(self, filepath):
        if filepath not in self.playlist:
            self.playlist.append(filepath)
            self.playlist_counter += 1
            label_text = f"{self.playlist_counter}: {os.path.basename(filepath)}"
            action = self.playlist_menu.addAction(label_text)
            action.triggered.connect(lambda checked, f=filepath, a=action: self.confirm_remove(f, a))

            
            self.video_editor.set_playlist(self.playlist)
            
            if self.action_edit_video.isChecked() and (not self._userDeclinedIndexing):
                self.start_indexing_process(filepath)
            else:
                print("[DEBUG] Kein Indexing, weil der User es abgelehnt hat oder EditVideo=OFF.")                
           

    def confirm_remove(self, filepath, action):
        msg = QMessageBox(self)
        msg.setWindowTitle("Delete?")
        msg.setText(f"Delete {os.path.basename(filepath)} from playlist?")
        msg.setStandardButtons(QMessageBox.Yes | QMessageBox.No)
        r = msg.exec()
        if r == QMessageBox.Yes:
            self.remove_from_playlist(filepath, action)
   
   
    def remove_from_playlist(self, filepath, action):
        if filepath in self.playlist:
            idx = self.playlist.index(filepath)
            self.playlist.remove(filepath)
            if idx < len(self.video_durations):
                self.video_durations.pop(idx)

            self.playlist_menu.removeAction(action)
            
            # STATT rebuild_vlc_playlist():
            self.video_editor.set_playlist(self.playlist)

            # Timeline anpassen:
            self.rebuild_timeline()
    
    
    def rebuild_timeline(self):
        self.video_durations = []
        offset = 0.0
        for path in self.playlist:
            dur = self.get_video_length_ffprobe(path)
            self.video_durations.append(dur)
            offset += dur
        self.real_total_duration = offset
        self.timeline.set_total_duration(self.real_total_duration)

        boundaries = []
        ofs = 0.0
        for d in self.video_durations:
            ofs += d
            boundaries.append(ofs)
        self.timeline.set_boundaries(boundaries)

        self.video_editor.set_total_length(self.real_total_duration)
        self.video_editor.set_multi_durations(self.video_durations)
        self.cut_manager.set_video_durations(self.video_durations)
        self._update_gpx_overview()

    def get_video_length_ffprobe(self, filepath):
        cmd = [
            "ffprobe", "-v", "quiet", "-of", "csv=p=0",
            "-show_entries", "format=duration", filepath
        ]
        try:
            out = subprocess.check_output(cmd, stderr=subprocess.STDOUT)
            val = float(out.strip())
            if val > 0:
                return val
            return 0.0
        except:
            return 0.0

    def run_merge(self, video_path, csv_file, temp_dir):
        print("[DEBUG] run_merge => direkt merge_keyframes_incremental aufrufen ...")
        offset_value = self._get_offset_for_filepath(video_path)
        label = os.path.basename(video_path)
        json_file = os.path.join(temp_dir, "merged_keyframes.json")
    
        try:
            merge_keyframes_incremental(
                csv_file=csv_file,
                json_file=json_file,
                label=label,
                offset=offset_value,
                do_sort=True
            )
            # Danach ggf. self.on_indexing_finished(temp_dir) aufrufen
            self.on_indexing_finished(temp_dir)

        except Exception as e:
            print("Fehler beim Merge:", e)
            QMessageBox.warning(self, "Merge Error", "Merge step failed.")

    def on_indexing_finished(self, temp_dir):
        merged_json = os.path.join(temp_dir, "merged_keyframes.json")
        if not os.path.exists(merged_json):
            print("[DEBUG] merged_keyframes.json nicht gefunden in", temp_dir)
            return

        try:
            with open(merged_json, "r", encoding="utf-8") as f:
                data = json.load(f)

            new_kfs = []
            for entry in data:
                try:
                    gt = float(entry.get("global_time", 0.0))
                    new_kfs.append(gt)
                except:
                    pass
            new_kfs.sort()

            self.global_keyframes.extend(new_kfs)
            self.global_keyframes = sorted(set(self.global_keyframes))
            print("[DEBUG] %d Keyframes global geladen (gesamt)." % len(self.global_keyframes))

        except Exception as e:
            print("[DEBUG] Fehler beim Laden der JSON:", e)

    # -----------------------------------------------------------------------
    # Marker- und Player-Funktionen ...
    # -----------------------------------------------------------------------
    
    def on_play_pause(self):
        if self.video_editor.is_playing:
            # => Pause
            self.video_editor.play_pause()
            self.video_control.update_play_pause_icon(False)

            # GPX-List / Map: Pause
            self.gpx_widget.set_video_playing(False)
            self.map_widget.set_video_playing(False)

            # (A) => Falls wir noch einen gelben Play-Marker hatten, revertieren:
            #if self._last_map_idx is not None:
            #    # => Schwarz oder Rot? Da du ggf. in "update_timeline_marker" 
            #    #    den gelben Marker setzt, revertieren wir hier einfach auf schwarz:
            #    self.map_widget.highlight_gpx_point(self._last_map_idx, "#000000", 4, False)
            #    self._last_map_idx = None
            
            self.cut_manager.stop_skip_timer()

        else:
            
            if not self.cut_manager._has_active_file():
                if self.playlist:
                    self.video_editor.show_first_frame_at_index(0)
            
            if self._video_at_end:
                # => Wir waren am Ende => also erst "stoppen"
                self.on_stop()             # ruft dein Stop-Verhalten auf
                self._video_at_end = False # Reset dieses Merkers
            
            
            # => PLAY
            self.video_editor.play_pause()
            self.video_control.update_play_pause_icon(True)

            # GPX-List / Map: Play
            self.gpx_widget.set_video_playing(True)
            self.map_widget.set_video_playing(True)

            # Optional: Einmalig Karte zentrieren
            ...
            self.cut_manager.start_skip_timer()
    
    
    def _get_cut_end_if_any(self) -> float:
        """
        Falls es in cut_manager._cut_intervals einen Bereich (0.0, end_s) gibt,
        gib end_s zurück. Sonst 0.0
        """
        cut_intervals = self.cut_manager.get_cut_intervals()  # Liste (start_s, end_s)
        for (start_s, end_s) in cut_intervals:
            # Prüfen mit kleinem Toleranzwert:
            if abs(start_s) < 0.0001:
                return end_s
        return 0.0
        
    
      
    
    def on_stop(self):
        self.video_editor.stop()
        
    def on_play_ended(self):
        self.video_control.update_play_pause_icon(False)

        # 1) Player manuell in "Pause"-State
        # mpv self.video_editor.media_player.pause()
        self.video_editor._player.pause = True
        self.video_editor.is_playing = False

        # 2) GPX/Map => wir sind in Pause
        self.gpx_widget.set_video_playing(False)
        self.map_widget.set_video_playing(False)

        # 3) Gelben Marker entfernen
        lw = self.gpx_widget.gpx_list
        if lw._last_video_row is not None:
            lw._mark_row_bg_except_markcol(lw._last_video_row, Qt.white)
            lw._last_video_row = None
        
        self._video_at_end = True
    
    def _jump_player_to_time(self, new_s: float):
        total = sum(self.video_durations)
        if total <= 0:
            return
        new_s = max(0.0, min(new_s, total))

        # boundaries + local_s berechnen
        boundaries = []
        offset = 0.0
        for dur in self.video_durations:
            offset += dur
            boundaries.append(offset)

        new_idx = 0
        offset_prev = 0.0
        for i, b in enumerate(boundaries):
            if new_s < b:
                new_idx = i
                break
            offset_prev = b
    
        local_s = new_s - offset_prev
        if local_s < 0:
            local_s = 0
    
        old_idx = self.video_editor._current_index
    
        # 1) Falls wir das Video wechseln müssen:
        if new_idx != old_idx:
            self.video_editor._player.command('stop')
            self.video_editor.is_playing = False
            self.video_editor._current_index = new_idx
    
            if new_idx < len(self.playlist):
                path_ = self.playlist[new_idx]
                self.video_editor._player.command('loadfile', path_)
                # => local_s
                self.video_editor._player.seek(local_s, reference='absolute')
                self.video_editor._player.pause = True
                self.video_editor.is_playing = False
        else:
            # Gleicher Index => nur seek
            self.video_editor._player.seek(local_s, reference='absolute')
            self.video_editor._player.pause = True
            self.video_editor.is_playing = False
            


    def on_step_mode_changed(self, new_value):
        self.step_manager.set_step_mode(new_value)

    def on_multiplier_changed(self, new_value):
        numeric = new_value.replace("x", "")
        try:
            val = float(numeric)
        except:
            val = 1.0
        self.step_manager.set_step_multiplier(val)

    def _on_timeline_marker_moved(self, new_time_s: float):
        #self._jump_player_to_time(new_time_s)
        self.video_editor._jump_to_global_time(new_time_s)

    def on_time_hms_set_clicked(self, hh: int, mm: int, ss: int, ms=0):
        """
        Empfängt das Signal vom VideoControlWidget (SetTime-Button).
        Rechnet hh:mm:ss => globale Sekunde => springt dorthin.
        """
        # 1) h/m/s in float-Sekunden
        total_s = hh * 3600 + mm * 60 + ss + (ms / 1000.0)
        
        
        if self.cut_manager.is_in_cut_segment(total_s):
            QMessageBox.warning(
                self,
                "Invalid Time",
                "This time is inside a cut segment.\nCannot jump there!"
            )
            return  # Abbruch

    
        # 2) Begrenzen auf [0 .. real_total_duration]
        if total_s < 0:
            total_s = 0.0
        if total_s > self.real_total_duration:
            total_s = self.real_total_duration
    
        # 3) Aufruft der mpv-Funktion => "globaler" Sprung
        self.video_editor.set_time(total_s)
        #
        # Damit ruft Ihr intern mpv._jump_to_global_time(total_s) auf,
        # das berechnet, in welchem Clip wir landen und spult dorthin.
        #
    
    
    
    def _after_hms_switch(self, local_s):
        """
        1) Setzt die local_s
        2) Startet kurz das Abspielen (ohne is_playing=True zu setzen), 
        damit VLC das Frame dekodieren kann.
        3) Ein kleiner Timer pausiert wieder => Frame ist sichtbar.
        """
        # mpv self.video_editor.media_player.set_time(int(local_s * 1000))
        self.video_editor.set_time(local_s)  # (float Sek in MPV)
        self.video_editor.media_player.play()
    
        from PySide6.QtCore import QTimer
        #QTimer.singleShot(80, lambda: self._really_pause)
        QTimer.singleShot(80, lambda: self._really_pause())
    

    def _really_pause(self):
        """
        Pausiert das Video => wir bleiben direkt am Zielbild stehen
        (statt weiterzulaufen wie zuvor).
        """
        # mpv self.video_editor.media_player.pause()
        self.video_editor._player.pause = True
        # Falls du NICHT willst, dass "is_playing=True" war, 
        # lässt du es weg - hier also is_playing=False, 
        # oder gar nicht verändern.
        self.video_editor.is_playing = False


    def _pause_player_popup(self):
        # mpv self.video_editor.media_player.pause()
        self.video_editor._player.pause = True
        self.video_editor.is_playing = False
        real_s = self.video_editor.get_current_position_s()
        self.video_editor.set_current_time(real_s)

        hh = int(real_s // 3600)
        mm = int((real_s % 3600) // 60)
        ss = int(real_s % 60)
        #self.video_control.set_hms_time(hh, mm, ss)
    
    
    def _on_cuts_changed(self, sum_of_cuts_s):
        print("[DEBUG] _on_cuts_changed => sum_of_cuts_s:", sum_of_cuts_s)
        new_duration = self.real_total_duration - sum_of_cuts_s
        if new_duration < 0:
            new_duration = 0
        self.video_editor.set_old_time(self.real_total_duration)
        self.video_editor.set_cut_time(new_duration)
        self._update_gpx_overview()    
        
        
    ## on_safe_click
    def on_safe_clicked(self):
        # 1) Sicherheitsabfrage
        msg = QMessageBox(self)
        msg.setWindowTitle("Are you sure?")
        msg.setText("We are now creating the final video, changes are no longer possible! Sure?")
        msg.setStandardButtons(QMessageBox.Yes | QMessageBox.No)
        r = msg.exec()
        if r == QMessageBox.No:
            return

        if not self.playlist:
            QMessageBox.warning(self, "Error", "No videos in playlist!")
            return

        total_dur = self.real_total_duration
        sum_cuts = self.cut_manager.get_total_cuts()
        final_duration_s = total_dur - sum_cuts
        if final_duration_s < 0:
            final_duration_s = 0

        out_file, _ = QFileDialog.getSaveFileName(
            self,
            "Select output file",
            "output_final.mp4",
            "Video Files (*.mp4 *.mov *.mkv *.avi)"
        )
        if not out_file:
            return

        keep_intervals = self._compute_keep_intervals(self.cut_manager._cut_intervals, total_dur)
        if not keep_intervals:
            QMessageBox.warning(self, "Error", "All time ranges are cut! Nothing to export.")
            return

        import tempfile
        tmp_dir = MY_GLOBAL_TMP_DIR  # denselben Ordner nutzen
        

        # 2) Statt direkt ffmpeg aufzurufen => wir bauen eine Liste an Commands
        segment_commands = []
        segment_files = []
        seg_index = 0

        for (global_start, global_end) in keep_intervals:
            partials = self._resolve_partial_intervals(global_start, global_end)
            for (vid_idx, local_st, local_en) in partials:
                source_path = self.playlist[vid_idx]
                seg_len = local_en - local_st
                if seg_len <= 0.01:
                    continue
                out_segment = os.path.join(tmp_dir, f"segment_{seg_index:03d}.mp4")
                segment_files.append(out_segment)

                cmd = [
                    "ffmpeg", "-y",
                    "-ss", f"{local_st:.3f}",
                    "-to", f"{local_en:.3f}",
                    "-i", source_path,
                    "-c", "copy",
                    out_segment
                ]
                segment_commands.append(cmd)
                seg_index += 1

        # 3) Concat-File
        concat_file = os.path.join(tmp_dir, "concat_list.txt")
        with open(concat_file, "w") as f:
            for segpath in segment_files:
                f.write(f"file '{segpath}'\n")

        final_cmd = [
            "ffmpeg", "-y",
            "-f", "concat",
            "-safe", "0",
            "-i", concat_file,
            "-c", "copy",
            out_file
        ]

        # 4) Nun unser asynchroner Dialog
        dlg = _SafeExportDialog(self)
        dlg.set_commands(segment_commands, final_cmd, out_file)
        dlg.start_export()  # startet direkt den ersten ffmpeg-Aufruf
        dlg.exec()

        # Wenn du hierher kommst, ist der Dialog geschlossen => entweder fertig oder abgebrochen
        # Ggf. könntest du ein "if dlg.result() == QDialog.Accepted" => print("OK!") etc.
        if dlg.result() == QDialog.Accepted:
            print("Export was successful!")
            ret = self._increment_counter_on_server("video")
            if ret is not None:
                vcount, gcount = ret
                print(f"[INFO] Server-Counter nun: Video={vcount}, GPX={gcount}")
            else:
                print("[WARN] Konnte Video-Zähler nicht hochsetzen.")
        else:
            print("Export canceled or error.")

        
   
        

    def _compute_keep_intervals(self, cut_intervals, total_duration):
        if not cut_intervals:
            return [(0.0, total_duration)]

        sorted_cuts = sorted(cut_intervals, key=lambda x: x[0])
        merged = []
        current_start, current_end = sorted_cuts[0]
        for i in range(1, len(sorted_cuts)):
            (st, en) = sorted_cuts[i]
            if st <= current_end:
                if en > current_end:
                    current_end = en
            else:
                merged.append((current_start, current_end))
                current_start, current_end = st, en
        merged.append((current_start, current_end))

        keep_list = []
        pos = 0.0
        for (cst, cen) in merged:
            if cst > pos:
                keep_list.append((pos, cst))
            pos = cen
        if pos < total_duration:
            keep_list.append((pos, total_duration))

        return keep_list

    def _resolve_partial_intervals(self, global_start, global_end):
        results = []
        if global_end <= global_start:
            return results
        if len(self.video_durations) == 0:
            return results

        boundaries = []
        offset = 0.0
        for dur in self.video_durations:
            offset += dur
            boundaries.append(offset)

        current_s = global_start
        end_s = global_end

        idx = 0
        prev_offset = 0.0
        for i, b in enumerate(boundaries):
            if current_s < b:
                idx = i
                prev_offset = boundaries[i - 1] if i > 0 else 0.0
                break

        while current_s < end_s and idx < len(boundaries):
            video_upper = boundaries[idx]
            local_st = current_s - prev_offset
            segment_end_global = min(end_s, video_upper)
            local_en = segment_end_global - prev_offset

            if local_en > local_st:
                results.append((idx, local_st, local_en))

            current_s = segment_end_global
            idx += 1
            if idx < len(boundaries):
                prev_offset = boundaries[idx - 1]

        return results

    def keyPressEvent(self, event):
        if event.key() == Qt.Key_Plus or event.text() == '+':
            if self.speed_index < len(self.vlc_speeds) - 1:
                self.speed_index += 1
                self.current_rate = self.vlc_speeds[self.speed_index]
                self.video_editor.set_playback_rate(self.current_rate)
        elif event.key() == Qt.Key_Minus or event.text() == '-':
            if self.speed_index > 0:
                self.speed_index -= 1
                self.current_rate = self.vlc_speeds[self.speed_index]
                self.video_editor.set_playback_rate(self.current_rate)
        else:
            super(MainWindow, self).keyPressEvent(event)

    def get_final_time_for_global(self, global_s: float) -> float:
        """
        Konvertiert 'global_s' (Rohvideo-Zeit) => 'final_s' (geschnittenes Video).
        Liegen wir exakt auf dem Start eines Cuts, springen wir an den Endpunkt
        des vorherigen Keep-Segments.
        """
        cut_intervals = self.cut_manager._cut_intervals
        total_dur = self.real_total_duration
        if not cut_intervals:
            return min(global_s, total_dur)

        keep_list = self._compute_keep_intervals(cut_intervals, total_dur)
        final_time = 0.0
        EPS = 1e-9

        for (kstart, kend) in keep_list:
            seg_len = (kend - kstart)
            if global_s < (kstart - EPS):
                break
            elif abs(global_s - kstart) <= EPS:
                # exact Start => final bleibt am Ende des letzten
                return final_time
            elif kstart <= global_s < (kend - EPS):
                final_time += (global_s - kstart)
                return final_time
            else:
                final_time += seg_len

        return final_time
        
        
    def get_global_time_for_final(self, final_s: float) -> float:
        """
        Konvertiert 'final_s' (geschnittenes Video) => 'global_s' (Rohvideo-Zeit).
        Liegt final_s exakt am Keep-Segmentende, springen wir ins nächste Segment.
        """
        cut_intervals = self.cut_manager._cut_intervals
        total_dur = self.real_total_duration
        if not cut_intervals:
            return min(final_s, total_dur)

        keep_list = self._compute_keep_intervals(cut_intervals, total_dur)
        remaining = final_s
        EPS = 1e-9

        for (seg_start, seg_end) in keep_list:
            seg_len = (seg_end - seg_start)

            if remaining < seg_len - EPS:
                return seg_start + remaining
            elif abs(remaining - seg_len) <= EPS:
                # exakt Segmentende => Skip in den Anfang des nächsten Keep
                remaining = 0.0
            else:
                remaining -= seg_len

        return total_dur    
        
    def on_sync_clicked(self):
        """
        Sync-Button aus VideoControlWidget: 
        Wir nutzen die *final* Time (falls Cuts) und 
        zeigen in der GPX-Liste + Map (blau) den passenden Punkt.
        """
        # 1) Aktuelle Videoposition => global
        """
        local_time_s = self.video_editor.get_current_position_s()
        if local_time_s < 0:
            local_time_s = 0.0
        video_idx = self.video_editor.get_current_index()
        offset = sum(self.video_durations[:video_idx])
        global_s = offset + local_time_s
        """
        global_s = self.video_editor.get_current_position_s()
        print(f"[DEBUG] on_sync_clicked => get_current_position_s()={global_s:.3f}")

        # 2) => final_s, falls Cuts
        final_s = self.get_final_time_for_global(global_s)

        # 3) => best_idx in GPX
        best_idx = self.gpx_widget.get_closest_index_for_time(final_s)

        # 4) GPX-Liste => Pause => also "select_row_in_pause"
        self.gpx_widget.gpx_list.select_row_in_pause(best_idx)

        # 5) Map => blau => "show_blue"
        #self.map_widget.show_blue(best_idx)
        self.map_widget.show_blue(best_idx, do_center=True)


        # 6) Falls du dein Chart mitziehen möchtest:
        self.chart.highlight_gpx_index(best_idx)


        
    def on_map_sync_any(self):
        """
        Wird von map_widget._on_sync_noarg_from_js aufgerufen,
        wenn der Sync-Button in map_page.html geklickt wird.

        1) Index => map_widget._blue_idx oder fallback => gpx_list.currentRow()
        2) final_s = gpx_data[idx]["rel_s"]
        3) global_s = get_global_time_for_final(final_s)
        4) => on_time_hms_set_clicked => Video
        """
        print("[DEBUG] on_map_sync_any() aufgerufen (Map-Sync)")

        # 1) Welcher Punkt in der Karte? (blau_idx)
        idx_map = self.map_widget._blue_idx
        if idx_map is None or idx_map < 0:
            # fallback => nimm Zeile aus gpx_list
            idx_map = self.gpx_widget.gpx_list.table.currentRow()

        # Prüfung
        row_count = self.gpx_widget.gpx_list.table.rowCount()
        if not (0 <= idx_map < row_count):
            print("[DEBUG] on_map_sync_any => invalid index => Abbruch.")
            return

        # 2) final_s
        point = self._gpx_data[idx_map]
        final_s = point.get("rel_s", 0.0)

        # 3) global_s => Falls Cuts => global_s = get_global_time_for_final(final_s)
        global_s = self.get_global_time_for_final(final_s)

        # => h,m,s
        hh = int(global_s // 3600)
        mm = int((global_s % 3600) // 60)
        s_float = (global_s % 60)      # z.B. 13.456
        ss = int(s_float)             # 13
        ms = int(round((s_float - ss)*1000))  # 456
        
        # 4) => Video-Position
        print(f"[DEBUG] on_map_sync_any => idx={idx_map}, final_s={final_s:.2f}, global_s={global_s:.2f}")
        self.on_time_hms_set_clicked(hh, mm, ss, ms)
        
    

    def _save_gpx_to_file(self, gpx_points, out_file: str):
        """
        Schreibt gpx_points als valides GPX 1.1 in die Datei `out_file`.
        gpx_points: list of dicts with lat, lon, ele, time, rel_s, ...
    
        Zeitformat => "YYYY-MM-DDTHH:MM:SS.xxxZ"
        Beispiel: "2024-07-20T06:50:42.000Z"
        """
        import datetime

        if not gpx_points:
            return

        start_time = gpx_points[0].get("time", None)
        end_time   = gpx_points[-1].get("time", None)
        if not start_time:
            start_time = datetime.datetime.now()
        if not end_time:
            end_time = start_time

        # Bsp: 2024-07-20T06:50:42.000Z
        def _format_dt(dt):
            # dt.strftime("%Y-%m-%dT%H:%M:%S.%fZ") => hat 6 Mikrosekunden
            # Wir kürzen auf 3 Stellen => .%f => .xxx
            s = dt.strftime("%Y-%m-%dT%H:%M:%S.%f")  # z.B. 2024-07-20T06:50:42.123456
            # => wir wollen nur die ersten 3 Nachkommastellen
            return s[:-3] + "Z"  # => 2024-07-20T06:50:42.123Z

        start_str = _format_dt(start_time)
        end_str   = _format_dt(end_time)

        track_name = "Exported GPX"
        track_desc = "Cut to final video length"

        with open(out_file, "w", encoding="utf-8") as f:
            f.write('<?xml version="1.0" encoding="UTF-8"?>\n')
            f.write('<gpx version="1.1" creator="MyApp" ')
            f.write('xmlns="http://www.topografix.com/GPX/1/1" ')
            f.write('xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" ')
            f.write('xsi:schemaLocation="http://www.topografix.com/GPX/1/1 ')
            f.write('http://www.topografix.com/GPX/1/1/gpx.xsd">\n')

            # Metadata
            f.write('  <metadata>\n')
            f.write(f'    <time>{start_str}</time>\n')
            f.write('  </metadata>\n')

            f.write('  <trk>\n')
            f.write(f'    <name>{track_name}</name>\n')
            f.write(f'    <desc>{track_desc}</desc>\n')
            f.write('    <trkseg>\n')
            for pt in gpx_points:
                lat = pt.get("lat", 0.0)
                lon = pt.get("lon", 0.0)
                ele = pt.get("ele", 0.0)
                dt = pt.get("time", None)
                if dt is None:
                    dt = datetime.datetime.now()
                time_str = _format_dt(dt)
    
                f.write(f'      <trkpt lat="{lat:.6f}" lon="{lon:.6f}">\n')
                f.write(f'        <ele>{ele:.2f}</ele>\n')
                f.write(f'        <time>{time_str}</time>\n')
                f.write('      </trkpt>\n')
            f.write('    </trkseg>\n')
            f.write('  </trk>\n')
            f.write('</gpx>\n')
    
        print(f"[DEBUG] _save_gpx_to_file => wrote {len(gpx_points)} points to {out_file}")
        
        
   

    ###############################################################################        
    
    def on_chPercent_clicked(self):
        """
        Called when the user clicks the 'ch%' button.
        - If no valid range is selected (or only 1 point in that range),
        it changes the slope for a single point (row) relative to row-1.
        - If a valid range [markB..markE] with >=2 points is selected,
        it applies one consistent slope across that entire range,
        and shifts subsequent points accordingly.
        All user-facing texts are in English.
        """
        from PySide6.QtWidgets import (
            QDialog, QVBoxLayout, QHBoxLayout, QLabel,
            QDoubleSpinBox, QPushButton, QMessageBox
        )
        import copy
        import math
        from datetime import timedelta
        from core.gpx_parser import recalc_gpx_data
    
        gpx_data = self.gpx_widget.gpx_list._gpx_data
        if not gpx_data:
            QMessageBox.warning(self, "No GPX Data", "No GPX data available.")
            return
    
        n = len(gpx_data)
        if n < 2:
            QMessageBox.warning(self, "Too few points", "At least 2 GPX points are required.")
            return

        # --- Check if we have a valid markB..markE range ---
        b_idx = self.gpx_widget.gpx_list._markB_idx
        e_idx = self.gpx_widget.gpx_list._markE_idx
    
        valid_range = False
        if b_idx is not None and e_idx is not None:
            if b_idx > e_idx:
                b_idx, e_idx = e_idx, b_idx
            if 0 <= b_idx < n and 0 <= e_idx < n and (e_idx - b_idx) >= 1:
                valid_range = True

        # ------------------------------------------------------------------
        # CASE A) No valid range => single-point slope change
        # ------------------------------------------------------------------
        if not valid_range:
            row = self.gpx_widget.gpx_list.table.currentRow()
            if row < 1:
                QMessageBox.warning(self, "Invalid Selection",
                    "Please select a point with row >= 1.\n"
                    "Cannot compute slope for the very first point (row=0).")
                return
            if row >= n:
                return
    
            # => Undo
            old_data = copy.deepcopy(gpx_data)
            self.gpx_widget.gpx_list._history_stack.append(old_data)
    
            # lat/lon/ele for row-1 and row
            lat1, lon1, ele1 = (
                gpx_data[row-1].get("lat", 0.0),
                gpx_data[row-1].get("lon", 0.0),
                gpx_data[row-1].get("ele", 0.0)
            )
            lat2, lon2, ele2 = (
                gpx_data[row].get("lat", 0.0),
                gpx_data[row].get("lon", 0.0),
                gpx_data[row].get("ele", 0.0)
            )
    
            # Dist2D => we can reuse a small helper or do a direct haversine:
            dist_2d = self._haversine_m(lat1, lon1, lat2, lon2)
            if dist_2d < 0.01:
                QMessageBox.warning(self, "Zero Distance",
                    f"Points {row-1} and {row} have nearly no distance => slope undefined.")
                return
    
            old_slope = 100.0 * ((ele2 - ele1) / dist_2d)
    
            # Dialog => new slope
            dlg = QDialog(self)
            dlg.setWindowTitle(f"Change Slope (Single Point) - Row {row}")
            vbox = QVBoxLayout(dlg)
    
            lbl_info = QLabel(
                f"Current slope between row {row-1} and row {row}: {old_slope:.2f}%\n"
                "Please enter the new slope (in %)."
            )
            vbox.addWidget(lbl_info)
    
            spin_slope = QDoubleSpinBox()
            spin_slope.setRange(-200.0, 200.0)  # e.g. -200%.. 200%
            spin_slope.setDecimals(2)
            spin_slope.setSingleStep(0.01)
            spin_slope.setValue(old_slope)
            vbox.addWidget(spin_slope)
    
            h_btn = QHBoxLayout()
            btn_ok = QPushButton("OK")
            btn_cancel = QPushButton("Cancel")
            h_btn.addWidget(btn_ok)
            h_btn.addWidget(btn_cancel)
            vbox.addLayout(h_btn)
    
            def on_ok():
                dlg.accept()
    
            def on_cancel():
                dlg.reject()
    
            btn_ok.clicked.connect(on_ok)
            btn_cancel.clicked.connect(on_cancel)
    
            if not dlg.exec():
                return
    
            new_slope = spin_slope.value()
            if abs(new_slope - old_slope) < 1e-9:
                QMessageBox.information(self, "No change", "Slope unchanged.")
                return
    
            # => new ele2 = ele1 + dist_2d*(new_slope/100)
            new_ele2 = ele1 + dist_2d * (new_slope / 100.0)
            gpx_data[row]["ele"] = new_ele2
    
            # recalc
            recalc_gpx_data(gpx_data)
            self.gpx_widget.set_gpx_data(gpx_data)
            self._gpx_data = gpx_data
            self._update_gpx_overview()
    
            self.chart.set_gpx_data(gpx_data)
            if self.mini_chart_widget:
                self.mini_chart_widget.set_gpx_data(gpx_data)
    
            # Map
            #route_geojson = self._build_route_geojson_from_gpx(gpx_data)
            #self.map_widget.loadRoute(route_geojson, do_fit=False)

            diff_val = new_slope - old_slope
            QMessageBox.information(
                self, "Done",
                f"Slope changed from {old_slope:.2f}% to {new_slope:.2f}%.\n"
                f"Elevation of row {row} updated accordingly."
            )
            return

        # ------------------------------------------------------------------
        # CASE B) Valid range => single linear slope for [b_idx..e_idx]
        # ------------------------------------------------------------------
        else:
            # => Undo
            old_data = copy.deepcopy(gpx_data)
            self.gpx_widget.gpx_list._history_stack.append(old_data)
    
            lat_b, lon_b, ele_b = (
                gpx_data[b_idx].get("lat", 0.0),
                gpx_data[b_idx].get("lon", 0.0),
                gpx_data[b_idx].get("ele", 0.0)
            )
            lat_e, lon_e, ele_e = (
                gpx_data[e_idx].get("lat", 0.0),
                gpx_data[e_idx].get("lon", 0.0),
                gpx_data[e_idx].get("ele", 0.0)
            )
    
            # (1) Compute the total 2D distance from b_idx.. e_idx
            #     Summation of each segment's distance in [b_idx.. e_idx-1].
            total_2d = 0.0
            for i in range(b_idx, e_idx):
                la1, lo1 = gpx_data[i]["lat"], gpx_data[i]["lon"]
                la2, lo2 = gpx_data[i+1]["lat"], gpx_data[i+1]["lon"]
                dist_2d = self._haversine_m(la1, lo1, la2, lo2)
                total_2d += dist_2d
    
            if total_2d < 0.01:
                QMessageBox.warning(self, "Zero Distance",
                    f"The range {b_idx}..{e_idx} has almost no distance => slope undefined.")
                return
    
            # (2) old average slope
            old_dz = ele_e - ele_b
            old_slope = 100.0 * (old_dz / total_2d)
    
            # (3) Dialog => new slope
            dlg = QDialog(self)
            dlg.setWindowTitle(f"Change Average Slope - Range {b_idx}..{e_idx}")
            vbox = QVBoxLayout(dlg)
    
            lbl_info = QLabel(
                f"You have selected a range from {b_idx} to {e_idx}.\n"
                f"Current average slope in this range: {old_slope:.2f}%\n\n"
                "Please enter the new slope in % (e.g., 5.0 means 5%)."
            )
            vbox.addWidget(lbl_info)
    
            spin_slope = QDoubleSpinBox()
            spin_slope.setRange(-200.0, 200.0)  # e.g. -200..+200%
            spin_slope.setDecimals(2)
            spin_slope.setSingleStep(0.01)
            spin_slope.setValue(old_slope)
            vbox.addWidget(spin_slope)
    
            h_btn = QHBoxLayout()
            btn_ok = QPushButton("OK")
            btn_cancel = QPushButton("Cancel")
            h_btn.addWidget(btn_ok)
            h_btn.addWidget(btn_cancel)
            vbox.addLayout(h_btn)
    
            def on_ok_range():
                dlg.accept()
    
            def on_cancel_range():
                dlg.reject()
    
            btn_ok.clicked.connect(on_ok_range)
            btn_cancel.clicked.connect(on_cancel_range)
    
            if not dlg.exec():
                return
    
            new_slope = spin_slope.value()
            if abs(new_slope - old_slope) < 1e-9:
                QMessageBox.information(self, "No change", "Slope unchanged.")
                return
    
            # (4) new total height difference => new_dz
            new_dz = total_2d * (new_slope / 100.0)
            shift_dz = new_dz - old_dz   # how much we add from e_idx onward
    
            # (5) Recompute elevations linearly from b_idx.. e_idx
            #     Keep ele[b_idx] as it is, 
            #     then for each i in [b_idx+1.. e_idx], 
            #     compute the cumulative distance from b_idx to i.
            def cumulative_distance(b_i, i_i):
                dist_sum = 0.0
                for x in range(b_i, i_i):
                    la1, lo1 = gpx_data[x]["lat"], gpx_data[x]["lon"]
                    la2, lo2 = gpx_data[x+1]["lat"], gpx_data[x+1]["lon"]
                    dist_sum += self._haversine_m(la1, lo1, la2, lo2)
                return dist_sum
    
            for i in range(b_idx+1, e_idx+1):
                dist_i = cumulative_distance(b_idx, i)
                # slope-based new altitude
                new_ele_i = ele_b + (new_slope / 100.0) * dist_i
                gpx_data[i]["ele"] = new_ele_i
    
            # (6) Shift all points after e_idx by shift_dz
            if e_idx < n-1 and abs(shift_dz) > 1e-9:
                for j in range(e_idx+1, n):
                    gpx_data[j]["ele"] = gpx_data[j]["ele"] + shift_dz
    
            # (7) recalc + update
            recalc_gpx_data(gpx_data)
            self.gpx_widget.set_gpx_data(gpx_data)
            self._gpx_data = gpx_data
            self._update_gpx_overview()
    
            self.chart.set_gpx_data(gpx_data)
            if self.mini_chart_widget:
                self.mini_chart_widget.set_gpx_data(gpx_data)
    
            #route_geojson = self._build_route_geojson_from_gpx(gpx_data)
            #self.map_widget.loadRoute(route_geojson, do_fit=False)

            QMessageBox.information(
                self, "Done",
                f"Average slope in {b_idx}..{e_idx} changed from {old_slope:.2f}% to {new_slope:.2f}%.\n"
                f"Subsequent points have been shifted by {shift_dz:+.2f} m in elevation."
            )
    
    
            
   
  
            
    def _partial_recalc_gpx(self, i: int):
        """
        Neuberechnung nur für index i und i+1 
        (sowie i-1.. i, falls i>0)
        """
        import math
        from core.gpx_parser import recalc_gpx_data
        gpx = self.gpx_widget.gpx_list._gpx_data
        n = len(gpx)
        if n < 2:
            return

        start_i = max(0, i-1)
        end_i   = min(n-1, i+1)

        # => Einfacher Weg: extrahiere Subarray, recalc, schreibe zurück
        sub = gpx[start_i:end_i+1]

        # recalc_gpx_data kann das gesamte Array => wir machen 
        # --> Variante A) sub
        # --> Variante B) In-Place code (selber berechnen).

        # Hier der "grosse" Weg: wir rufen recalc_gpx_data auf ALLE, 
        # ist simpler & kein Performanceproblem
        from core.gpx_parser import recalc_gpx_data
        recalc_gpx_data(gpx)

        # Falls du nur sub recalc willst, ist das aufwändiger.
        
    def _on_new_project_triggered(self):
        """
        Führt einen "Soft-Reset" durch, ohne das Programm neu zu starten.
        Alle Daten (GPX, Videos, Markierungen) werden entfernt.
        """
        from PySide6.QtWidgets import QMessageBox

        answer = QMessageBox.question(
            self,
            "New Project",
            "All data (GPX, video playlist, cuts, marks) will be removed.\n"
            "Do you really want to start a new project?",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No
        )
        if answer == QMessageBox.Yes:
            # 1) Playback stoppen
            self.on_stop()  # oder self.video_editor.stop(), + selbst is_playing=False etc.
    
            # 2) Video-Cuts entfernen
            self.cut_manager._cut_intervals.clear()  # or use an API remove_all_cuts()
            self.cut_manager.markB_time_s = -1
            self.cut_manager.markE_time_s = -1

            # 3) Timeline zurücksetzen
            self.timeline.set_markB_time(-1)
            self.timeline.set_markE_time(-1)
            self.timeline._cut_intervals.clear()  # interne Liste
            self.timeline.set_marker_position(0.0)
            self.timeline.set_total_duration(0.0)

            # 4) GPX-Widget + GPX-Daten leeren
            self.gpx_widget.set_gpx_data([])
            self._gpx_data = []
            # Undo-Stack der gpx_list leeren
            self.gpx_widget.gpx_list._history_stack.clear()
            # Markierungen
            self.gpx_widget.gpx_list.clear_marked_range()

            # 5) Playlist und Video-Durations leeren
            self.playlist.clear()
            self.video_durations.clear()
            #self.video_editor.rebuild_vlc_playlist([])  # leere Liste => kein Video
            self.video_editor.set_playlist([])
            
            self.playlist_menu.clear()  # <-- Wichtig!
            self.video_editor.set_total_length(0.0)
            self.video_editor.set_cut_time(0.0)


            # 6) Falls du globale Keyframes (self.global_keyframes) hast:
            self.global_keyframes.clear()

            # 7) Ggf. GUI-Anzeigen zurücksetzen (z.B. chart, map)
            self.chart.set_gpx_data([])
            if self.mini_chart_widget:
                self.mini_chart_widget.set_gpx_data([])
            self.map_widget.loadRoute(None, do_fit=False)
            
            self.map_widget.loadRoute({"type":"FeatureCollection","features":[]}, do_fit=False)
    
            # 8) Info an den User
            QMessageBox.information(
                self,
                "Project Cleared",
                "All data was cleared. You can now load new GPX/videos."
            )

    def add_or_update_point_on_map(self, stable_id: str, lat: float, lon: float, 
                                color: str="#000000", size: int=4):
        """
        Ruft in map_page.html => addOrUpdatePoint(...) auf.
        """
        js_code = (f"addOrUpdatePoint('{stable_id}', {lat}, {lon}, "
                f"'{color}', {size});")
        self.map_widget.view.page().runJavaScript(js_code)

    def remove_point_on_map(self, stable_id: str):
        """
        Ruft in map_page.html => removePoint(...) auf.
        """
        

        js_code = f"removePoint('{stable_id}');"
        self.map_widget.view.page().runJavaScript(js_code)

    
    
     

    
            
    
    
        
    def _go_to_gpx_index(self, idx: int):
        """
        Highlights the GPX index 'idx' in the map, the gpx list, the chart, 
        and optionally the mini-chart or the video timeline.
        """
        # 1) Table (GPXList) -> Pause-Selection
        self.gpx_widget.gpx_list.select_row_in_pause(idx)
    
        # 2) Map -> show blue + center
        self.map_widget.show_blue(idx, do_center=True)

        # 3) Chart
        self.chart.highlight_gpx_index(idx)
    
        # 4) MiniChart
        if self.mini_chart_widget:
            self.mini_chart_widget.set_current_index(idx)

        # 5) (Optional) => Video 
        #    Falls du direkt zum passenden Zeitpunkt springen willst:
        # global_s = gpx_data[idx]["rel_s"]   # oder wie auch immer du es nennst
        # => self.on_time_hms_set_clicked(....) 
        # or do nothing if you prefer just highlighting
        
        
    def on_markB_clicked_gpx(self):
        
        """
        Wird aufgerufen, wenn im GPXControlWidget der Button 'MarkB' geklickt wird.
        => current_row ohne +1
        """
        current_row = self.gpx_widget.gpx_list.table.currentRow()
        if current_row < 0:
            print("[DEBUG] Keine Zeile ausgewählt in gpx_list!")
            return

        # Ohne +1
        self.gpx_widget.gpx_list.set_markB_row(current_row)
        self.map_widget.set_markB_point(current_row)           
    
   
    def on_deselect_clicked(self):
        
        """
        Wird aufgerufen, wenn der Deselect-Button gedrückt wird 
        (VideoControlWidget oder GPXControlWidget).
        => Wir entfernen alle roten Markierungen in der GPX-Liste.
        """
        self.gpx_widget.gpx_list.clear_marked_range()
        self.map_widget.clear_marked_range()        
        
    def check_gpx_errors(self, gpx_data):
        """
        Checks for:
        1) Time errors (points with time[i] == time[i-1])
        2) Way errors (points with lat/lon identical to next point)
        If any errors are found, shows an English warning message:
        - Only time errors
        - Only way errors
        - Both time & way errors
        Otherwise, no message.
        """
        from PySide6.QtWidgets import QMessageBox

        if not gpx_data or len(gpx_data) < 2:
            return  # zu wenige Punkte -> auch keine Warnung

        # 1) Time Errors zählen
        time_err_count = 0
        for i in range(1, len(gpx_data)):
            if gpx_data[i]["time"] == gpx_data[i-1]["time"]:
                time_err_count += 1

        # 2) Way Errors zählen
        way_err_count = 0
        for i in range(len(gpx_data) - 1):
            lat1 = gpx_data[i]["lat"]
            lon1 = gpx_data[i]["lon"]
            lat2 = gpx_data[i+1]["lat"]
            lon2 = gpx_data[i+1]["lon"]
            # Vergleiche Koordinaten - fast identisch?
            if abs(lat1 - lat2) < 1e-12 and abs(lon1 - lon2) < 1e-12:
                way_err_count += 1
    
        # Nichts gefunden => keine Meldung
        if time_err_count == 0 and way_err_count == 0:
            return
    
        # Mindestens eines vorhanden => Warnmeldung bauen:
        if time_err_count > 0 and way_err_count > 0:
            msg = (
                f"Warning:\n"
                f"We found {time_err_count} time errors (0s step) and {way_err_count} way errors (duplicate coordinates).\n"
                "Please fix them via the more-menu \"...\" -> Time Errors / Way Errors!"
            )
        elif time_err_count > 0:
            msg = (
                f"Warning:\n"
                f"We found {time_err_count} time errors (0s step).\n"
                "Please fix them via the more-menu \"...\" -> Time Errors!"
            )
        else:  # way_err_count > 0
            msg = (
                f"Warning:\n"
                f"We found {way_err_count} way errors (duplicate coordinates).\n"
                "Please fix them via the more-menu \"...\" -> (Way Errors)!"
            )
    
        QMessageBox.warning(self, "GPX Errors Detected", msg)
        
    def _toggle_map(self):
        """Menü-Aktion: 'Map (detach)' oder 'Map (attach)'."""
        if self._map_floating_dialog is None:
            self._detach_map_widget()
            self.action_toggle_map.setText("Map (attach)")
        else:
            self._reattach_map_widget()
            self.action_toggle_map.setText("Map (detach)")


    def _detach_map_widget(self):
        if self._map_floating_dialog is not None:
            return
    
        # Index des map_widget im Layout finden
        idx = self.left_v_layout.indexOf(self.map_widget)
        if idx < 0:
            return
    
        # Platzhalter
        self._map_placeholder = QFrame()
        self._map_placeholder.setStyleSheet("background-color: #444;")
    
        # Platzhalter an die alte Stelle des map_widget
        self.left_v_layout.insertWidget(idx, self._map_placeholder, 1)
        self.left_v_layout.removeWidget(self.map_widget)
    
        # DetachDialog
        dlg = DetachDialog(self)
        dlg.setWindowTitle("Map (Detached)")
        dlg.setMinimumSize(800, 600)  # <-- WICHTIG: Mindestens 800×600
    
        layout = QVBoxLayout(dlg)
        layout.addWidget(self.map_widget)
    
        # Optional: + / - / reattach
        dlg.requestPlus.connect(self._on_map_plus)
        dlg.requestMinus.connect(self._on_map_minus)
        dlg.requestReattach.connect(self._on_request_reattach_map)
    
        self._map_floating_dialog = dlg
        dlg.show()
    
        # Zeitverzögertes Resize
        QTimer.singleShot(50, lambda: self._after_show_map_detached(dlg))
    
    
    def _after_show_map_detached(self, dlg: QDialog):
        screen = dlg.screen()
        if not screen:
            from PySide6.QtGui import QGuiApplication
            screen = QGuiApplication.primaryScreen()
    
        sg = screen.availableGeometry()
        w = int(sg.width() * 0.5)
        h = int(sg.height() * 0.5)
        dlg.resize(w, h)
    
        fg = dlg.frameGeometry()
        fg.moveCenter(sg.center())
        dlg.move(fg.topLeft())
    
    
    def _reattach_map_widget(self):
        if not self._map_floating_dialog:
            return
    
        self._map_floating_dialog.close()
        self._map_floating_dialog = None
    
        if self._map_placeholder:
            idx = self.left_v_layout.indexOf(self._map_placeholder)
            if idx >= 0:
                self.left_v_layout.removeWidget(self._map_placeholder)
            self._map_placeholder.deleteLater()
            self._map_placeholder = None
    
        # Map wieder unten einfügen (z.B. am Ende des Layouts)
        self.left_v_layout.addWidget(self.map_widget, 1)
    
    
    def _on_request_reattach_map(self):
        """Vom Dialog-Signal aufgerufen."""
        self._reattach_map_widget()
    
    
    # (Optional) Falls du + / – für Zoom willst:
    def _on_map_plus(self):
        # Angenommen, du hast in map_page.html JS-Funktionen "mapZoomIn()"
        js_code = "mapZoomIn();"
        self.map_widget.view.page().runJavaScript(js_code)
    
    def _on_map_minus(self):
        js_code = "mapZoomOut();"
        self.map_widget.view.page().runJavaScript(js_code)
    
    
```


```
from PySide6.QtWidgets import QWidget
from PySide6.QtCore import Qt, QPoint, Signal, QPointF
from PySide6.QtGui import (
    QPainter, QPen, QBrush, QColor, QWheelEvent, QPolygonF
)
                           


class ChartWidget(QWidget):
    markerClicked = Signal(int)

    def __init__(self, parent=None):
        super().__init__(parent)
        self.setMouseTracking(True)
        self.setFocusPolicy(Qt.StrongFocus)

        self._gpx_data = []
        self._speed_cap = 70.0

        # Ausschnitt/Zoom
        self._zoom_factor = 1.0
        self._min_zoom = 1.0
        self._max_zoom = 50.0
        self._horizontal_offset = 0.0

        self._marker_index = 0

        # Dragging
        self._dragging_scroll = False
        self._drag_start_x = 0.0
        self._offset_start = 0.0

        # Chart-Layouts
        self._chart_height_top = 0.6
        self._chart_height_bottom = 0.3
        self._scroll_speed_px = 40

        # Neuer Schwellenwert (z.B. 1 km/h)
        self._zero_speed_threshold = 1.0
        
        
         # ---------------------------
        # **NEU**: Schwellenwert für Stops
        self._stop_threshold = 1.0   # z.B. Default 1 Sekunde

        self.setAttribute(Qt.WA_OpaquePaintEvent, True)
        self.setAutoFillBackground(True)
        
    def set_stop_threshold(self, value: float):
        self._stop_threshold = value
        self.update()  # Damit das Diagramm neu gezeichnet wird    
        

    # -----------------------------------------------------
    # Getter/Setter für die neue Zero-Speed-Einstellung
    # -----------------------------------------------------
    def set_zero_speed_threshold(self, threshold: float):
        """
        Legt den Geschwindigkeits-Schwellenwert fest.
        Werte darunter werden im Diagramm rot markiert.
        """
        self._zero_speed_threshold = threshold
        self.update()

    def zero_speed_threshold(self) -> float:
        return self._zero_speed_threshold

    # -----------------------------------------------------
    # Andere bekannte Setter
    # -----------------------------------------------------
    def set_speed_cap(self, new_limit: float):
        """Setzt das max. Speed-Limit und refresht."""
        self._speed_cap = new_limit
        self.update()

    def set_gpx_data(self, data):
        self._gpx_data = data if data else []
        self._marker_index = 0
        self._zoom_factor = 1.0
        self._horizontal_offset = 0.0
        self.update()

    def highlight_gpx_index(self, index: int):
        """Springt im Chart zum GPX-Punkt `index`."""
        if not self._gpx_data:
            return
        if index < 0:
            index = 0
        if index >= len(self._gpx_data):
            index = len(self._gpx_data) - 1
        self._marker_index = index
        self._keep_marker_visible()
        self.update()

    def _keep_marker_visible(self):
        """
        Verhindert, dass der Marker aus dem sichtbaren Bereich rutscht.
        Schiebt ggf. self._horizontal_offset so, dass der Marker x-Koordinate
        in ~80% des sichtbaren Bereichs bleibt.
        """
        count = len(self._gpx_data)
        if count <= 0:
            return

        w = self.width()
        chart_width = w * self._zoom_factor

        if count > 1:
            ratio = self._marker_index / (count - 1)
        else:
            ratio = 0.0

        marker_x = ratio * chart_width

        if marker_x < self._horizontal_offset:
            self._horizontal_offset = marker_x
        elif marker_x > self._horizontal_offset + (0.8 * w):
            self._horizontal_offset = marker_x - (0.8 * w)

        if self._horizontal_offset < 0:
            self._horizontal_offset = 0
        max_offset = chart_width - w
        if max_offset < 0:
            max_offset = 0
        if self._horizontal_offset > max_offset:
            self._horizontal_offset = max_offset

    # -----------------------------------------------------
    # Mouse/Scroll/Zoom
    # -----------------------------------------------------
    def mousePressEvent(self, event):
        if event.button() == Qt.LeftButton:
            idx = self._index_for_x(event.pos().x())
            self._marker_index = idx
            self.update()
            self.markerClicked.emit(idx)
            event.accept()
        elif event.button() == Qt.RightButton:
            self._dragging_scroll = True
            self._drag_start_x = event.pos().x()
            self._offset_start = self._horizontal_offset
            event.accept()
        else:
            super().mousePressEvent(event)

    def mouseMoveEvent(self, event):
        if self._dragging_scroll:
            delta_x = event.pos().x() - self._drag_start_x
            new_offset = self._offset_start - delta_x
            if new_offset < 0:
                new_offset = 0
            self._horizontal_offset = new_offset
            self.update()
            event.accept()
        else:
            event.ignore()

    def mouseReleaseEvent(self, event):
        if event.button() == Qt.RightButton and self._dragging_scroll:
            self._dragging_scroll = False
            event.accept()
        else:
            event.ignore()

    def wheelEvent(self, event: QWheelEvent):
        delta = event.angleDelta().y()
        if delta == 0:
            super().wheelEvent(event)
            return

        mods = event.modifiers()
        if (mods & Qt.ShiftModifier):
            # horizontal scroll
            if delta > 0:
                self._horizontal_offset = max(0, self._horizontal_offset - self._scroll_speed_px)
            else:
                self._horizontal_offset += self._scroll_speed_px
            self.update()
            event.accept()
            return

        if (mods & Qt.ControlModifier):
            # zoom
            factor = 1.1 if delta > 0 else (1.0 / 1.1)
            new_zoom = self._zoom_factor * factor
            if new_zoom < self._min_zoom:
                new_zoom = self._min_zoom
            if new_zoom > self._max_zoom:
                new_zoom = self._max_zoom

            old_zoom = self._zoom_factor
            self._zoom_factor = new_zoom
            self._center_marker(0.3)
            self.update()
            event.accept()
            return

        super().wheelEvent(event)

    def _center_marker(self, widget_ratio: float):
        count = len(self._gpx_data)
        if count < 2:
            return
        w = self.width()
        chart_width = w * self._zoom_factor
        ratio = self._marker_index / (count - 1)
        marker_x_abs = ratio * chart_width
        desired_x_in_widget = widget_ratio * w
        self._horizontal_offset = marker_x_abs - desired_x_in_widget
        if self._horizontal_offset < 0:
            self._horizontal_offset = 0

    # -----------------------------------------------------
    # Painting
    # -----------------------------------------------------
    def paintEvent(self, event):
        super().paintEvent(event)
        painter = QPainter(self)
        painter.setRenderHint(QPainter.Antialiasing)
    
        rect_ = self.rect()
        w = rect_.width()
        h = rect_.height()
        painter.fillRect(rect_, QColor("#222222"))

        # ------------------------------------------------------
        # LEGENDE (oben links)
        # ------------------------------------------------------
        legend_x = 10
        legend_y = 20

        # SPEED
        painter.setPen(QPen(Qt.white, 1))
        painter.drawText(legend_x, legend_y, "Speed:")

        fm = painter.fontMetrics()
        speed_text_width = fm.horizontalAdvance("Speed:")
        line_start_x = legend_x + speed_text_width + 5
        line_start_y = legend_y - 5
        line_end_x = line_start_x + 30
        line_end_y = line_start_y

        # Speed-Legendenlinie (cyan, 3px)
        painter.setPen(QPen(QColor("cyan"), 3))
        painter.drawLine(line_start_x, line_start_y, line_end_x, line_end_y)

        # HEIGHT
        next_block_x = line_end_x + 20
        painter.setPen(QPen(Qt.white, 1))
        painter.drawText(next_block_x, legend_y, "Height:")
    
        height_text_width = fm.horizontalAdvance("Height:")
        height_line_start_x = next_block_x + height_text_width + 5
        height_line_start_y = legend_y - 5
        height_line_end_x = height_line_start_x + 30
        height_line_end_y = height_line_start_y
    
        # Height-Legendenlinie (yellow, 3px)
        painter.setPen(QPen(QColor("yellow"), 3))
        painter.drawLine(
            height_line_start_x,
            height_line_start_y,
            height_line_end_x,
            height_line_end_y
        )
    
        # ------------------------------------------------------
        # GPX-Daten prüfen
        # ------------------------------------------------------
        count = len(self._gpx_data)
        if count < 2:
            painter.setPen(QColor("white"))
            painter.drawText(10, 60, "No GPX data for chart.")
            return

        chart_width = w * self._zoom_factor
    
        # ------------------------------------------------------
        # ELE / SPEED ermitteln und skalieren
        # ------------------------------------------------------
        ele_vals = [pt.get("ele", 0.0) for pt in self._gpx_data]
    
        speed_vals = []
        for pt in self._gpx_data:
            raw_spd = pt.get("speed_kmh", 0.0)
            capped_spd = min(raw_spd, self._speed_cap)
            speed_vals.append(capped_spd)
    
        min_ele, max_ele = min(ele_vals), max(ele_vals)
        min_spd, max_spd = min(speed_vals), max(speed_vals)
    
        if abs(max_ele - min_ele) < 0.1:
            max_ele += 0.1
            min_ele -= 0.1
        if abs(max_spd - min_spd) < 0.1:
            max_spd += 0.1
            min_spd -= 0.1
    
        top_height = int(self._chart_height_top * h)
        bottom_height = int(self._chart_height_bottom * h)
    
        def x_for_index(i: int) -> float:
            ratio = i / (count - 1)
            return ratio * chart_width - self._horizontal_offset
    
        def y_for_ele(e: float) -> float:
            frac = (e - min_ele) / (max_ele - min_ele)
            return top_height - (frac * (top_height - 20))
    
        def y_for_speed(s: float) -> float:
            frac = (s - min_spd) / (max_spd - min_spd)
            speed_range = bottom_height - 20
            y0 = top_height + 10
            return y0 + (bottom_height - 20) - (frac * speed_range)
    
        # Pfade für Elevation/Speed
        path_ele = []
        path_spd = []
        for i in range(count):
            x_ = x_for_index(i)
            path_ele.append((x_, y_for_ele(ele_vals[i])))
            path_spd.append((x_, y_for_speed(speed_vals[i])))
    
        # ------------------------------------------------------
        # Linien zeichnen (Elevation = gelb, Speed = cyan)
        # ------------------------------------------------------
        def draw_polyline(painter, pts, color, thickness=2):
            painter.setPen(QPen(color, thickness))
            for idx in range(len(pts) - 1):
                x1, y1 = pts[idx]
                x2, y2 = pts[idx + 1]
                if (x1 < -50 and x2 < -50):
                    continue
                if (x1 > w + 50 and x2 > w + 50):
                    continue
                painter.drawLine(x1, y1, x2, y2)
    
        # 1) Elevation-Linie (gelb, 2px)
        draw_polyline(painter, path_ele, QColor(255, 255, 0), thickness=2)
    
        # 2) Speed-Linie (cyan, 1px)
        draw_polyline(painter, path_spd, QColor(0, 255, 255), thickness=1)
    
        # ------------------------------------------------------
        # Null-Linie (0 km/h) dünn weiß
        # ------------------------------------------------------
        painter.setPen(QPen(QColor("white"), 1))
        zero_speed_y = y_for_speed(0.0)
        painter.drawLine(0, zero_speed_y, w, zero_speed_y)
    
        # ------------------------------------------------------
        # Bereich für Geschwindigkeiten < zero_speed_threshold rot markieren
        # ------------------------------------------------------
        zst = self._zero_speed_threshold  # z.B. 1 km/h
        y_axis_speed = y_for_speed(0)     # x-Achse für Speed
    
        # Wir nutzen ein "Füll-Polygon" für jede zusammenhängende Unterschreitung.
        painter.setBrush(QColor(255, 0, 0, 100))  # halbtransparentes Rot
        painter.setPen(Qt.NoPen)
    
        sub_threshold_polygon = []
        in_segment = False
    
        for i in range(count):
            if i == 0:
                continue  # Ersten Punkt überspringen
            x_, y_ = path_spd[i]
            spd_ = speed_vals[i]
    
            # Unterhalb Schwelle?
            if spd_ < zst:
                # Segment anfangen, falls wir noch nicht "drin" sind
                if not in_segment:
                    sub_threshold_polygon.append((x_, y_axis_speed))
                    in_segment = True
                sub_threshold_polygon.append((x_, y_))
            else:
                # Falls wir gerade ein "rotes" Segment hatten, jetzt schließen
                if in_segment:
                    sub_threshold_polygon.append((x_, y_axis_speed))
                    # Zeichnen der Polygonfläche
                    poly = QPolygonF()
                    for (px, py) in sub_threshold_polygon:
                        poly.append(QPointF(px, py))
                    painter.drawPolygon(poly)
                    sub_threshold_polygon.clear()
                    in_segment = False
    
        # Falls Segment bis zum letzten Punkt offen
        if in_segment and len(sub_threshold_polygon) > 0:
            sub_threshold_polygon.append((path_spd[-1][0], y_axis_speed))
            poly = QPolygonF()
            for (px, py) in sub_threshold_polygon:
                poly.append(QPointF(px, py))
            painter.drawPolygon(poly)
    
        # ------------------------------------------------------
        # Rote Marker an der x-Achse für alle Punkte < zst
        # ------------------------------------------------------
        painter.setPen(QPen(QColor(255, 0, 0), 4))
        for i in range(count):
            if i == 0:
                continue
            x_, y_ = path_spd[i]
            spd_ = speed_vals[i]
            if spd_ < zst:
                # Kleiner senkrechter Strich nach unten (5px)
                painter.drawLine(x_, y_axis_speed, x_, y_axis_speed + 15)
    
        # ------------------------------------------------------
        # **NEU**: Blaue Marker für "Stops"
        # wenn Zeitdifferenz > self._stop_threshold
        # ------------------------------------------------------
        painter.setPen(QPen(QColor(255, 165, 0), 4))  # Blau, Dicke=2
        for i in range(1, count):
            # Zeitdifferenz zwischen Punkt i-1 und i:
            dt = self._gpx_data[i]["rel_s"] - self._gpx_data[i-1]["rel_s"]
            if dt > self._stop_threshold:
                # x_-Koordinate des Punktes i (bereits in path_spd gespeichert)
                x_ = path_spd[i][0]
                # Hier zeichnen wir einen Strich nach oben (15px) vom zero_speed_y:
                painter.drawLine(x_, zero_speed_y, x_, zero_speed_y + 15)
    
        # ------------------------------------------------------
        # Kreise auf den Datenpunkten (Elevation = gelb, Speed = cyan)
        # ------------------------------------------------------
        painter.setPen(Qt.NoPen)
    
        # Elevation-Kreise
        painter.setBrush(QBrush(QColor(255, 255, 0)))
        ele_radius = 1
        for (xx, yy) in path_ele:
            if -10 < xx < w + 10:
                painter.drawEllipse(QPointF(xx, yy), ele_radius, ele_radius)
    
        # Speed-Kreise
        painter.setBrush(QBrush(QColor(0, 255, 255)))
        speed_radius = 0.7
        for (xx, yy) in path_spd:
            if -10 < xx < w + 10:
                painter.drawEllipse(QPointF(xx, yy), speed_radius, speed_radius)
    
        # ------------------------------------------------------
        # Marker-Linie und Info-Texte
        # ------------------------------------------------------
        m_x = x_for_index(self._marker_index)
        if -50 < m_x < w + 50:
            painter.setPen(QPen(QColor(255, 255, 255), 2))
            painter.drawLine(m_x, 0, m_x, h)
            pt_ = self._gpx_data[self._marker_index]
    
            ele_val = pt_['ele']
            spd_val = speed_vals[self._marker_index]  # gecappter Wert
            grad_val = pt_.get("gradient", 0.0)
    
            line1 = f"{ele_val:.1f}".replace(".", ",") + "m"
            line2 = f"{spd_val:.1f}".replace(".", ",") + "km/h"
            line3 = f"{grad_val:.1f}".replace(".", ",") + "%"
    
            y_start = 40
            y_step = 15
    
            painter.setPen(QPen(QColor("white"), 1))
            painter.drawText(m_x + 5, y_start, line1)
            painter.drawText(m_x + 5, y_start + y_step, line2)
            painter.drawText(m_x + 5, y_start + 2 * y_step, line3)
    
                
     

    # -----------------------------------------------------
    # Hilfsfunktion: x->Index
    # -----------------------------------------------------
    def _index_for_x(self, x_screen: float) -> int:
        count = len(self._gpx_data)
        if count < 2:
            return 0
        w = self.width()
        chart_width = w * self._zoom_factor
        abs_x = x_screen + self._horizontal_offset
        ratio = abs_x / chart_width
        ratio = max(0, min(ratio, 1))
        idx_ = int(round(ratio * (count - 1)))
        return max(0, min(idx_, count - 1))

```
# gpx_control_widget.py 
## aufgeräumt

import copy
import math
import urllib.request
import json
import copy

from PySide6.QtWidgets import (
    QWidget, QHBoxLayout, QPushButton, QStyle,
    QVBoxLayout, QLabel, QSizePolicy, QFrame,
    QMenu, QDialog, QRadioButton, QButtonGroup,
    QDoubleSpinBox, QMessageBox, QFileDialog
)

from PySide6.QtCore import Qt, Signal, QPoint

from datetime import timedelta
from core.gpx_parser import recalc_gpx_data





        



        


class GPXControlWidget(QWidget):
    """
    Enthält die Buttons (MarkB, MarkE, x, Delete, chTime, chEle, ch%, Undo, Smooth, Save)
    UND eine Info-Zeile darunter, in der wir vier Labels anzeigen:
    - Video: ...
    - Length(GPX): ...
    - Duration(GPX): ...
    - Elevation Gain: ...
    """

    # Signale
    markBClicked = Signal()
    markEClicked = Signal()
    deselectClicked = Signal()  # "x"
    deleteClicked = Signal()
    chTimeClicked = Signal()
    chEleClicked = Signal()
    chPercentClicked = Signal()
    undoClicked = Signal()
    smoothClicked = Signal()
    saveClicked = Signal()
    showMaxSlopeClicked = Signal()
    showMinSlopeClicked = Signal()
    averageSpeedClicked = Signal()
    maxSpeedClicked = Signal()
    minSpeedClicked = Signal()
    closeGapsClicked = Signal()
    deleteWayErrorsClicked = Signal()
    deleteTimeErrorsClicked = Signal()


    def __init__(self, parent=None):
        super().__init__(parent)
        
        self._mainwindow = None
        


        # SORGT DAFÜR, DASS DAS WIDGET NICHT ENDLOS IN DIE HÖHE WÄCHST
        self.setSizePolicy(
            QSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)
        )

        # Oberstes (vertikales) Layout, darin: Buttons-Zeile + Info-Zeile
        self.main_vbox = QVBoxLayout(self)
        self.main_vbox.setContentsMargins(5, 5, 5, 5)
        self.main_vbox.setSpacing(5)

        # ---------------------------------------------
        # (A) Erste Zeile: Buttons
        # ---------------------------------------------
        self._buttons_layout = QHBoxLayout()
        self._buttons_layout.setSpacing(5)
        self.main_vbox.addLayout(self._buttons_layout)

        # 1) MarkB
        self.markB_button = QPushButton("[-", self)
        self.markB_button.setToolTip("Mark the Begin of the Cut in the GPX")
        
        self.markB_button.setMaximumWidth(40)
        self.markB_button.clicked.connect(self.markBClicked.emit)
        self._buttons_layout.addWidget(self.markB_button)
        
        self._default_markB_style = self.markB_button.styleSheet() or ""

        # 2) MarkE
        self.markE_button = QPushButton("-]", self)
        self.markE_button.setToolTip("Mark the End of the Cut in the GPX")
        
        self.markE_button.setMaximumWidth(40)
        self.markE_button.clicked.connect(self.markEClicked.emit)
        self._buttons_layout.addWidget(self.markE_button)
        
        self._default_markE_style = self.markE_button.styleSheet() or ""

        # 3) x => "deselect"
        self.deselect_button = QPushButton("x", self)
        self.deselect_button.setToolTip("Deselect the marked Area")
        
        self.deselect_button.setMaximumWidth(40)
        self.deselect_button.clicked.connect(self.deselectClicked.emit)
        self._buttons_layout.addWidget(self.deselect_button)

        # 4) Delete
        self.delete_button = QPushButton("", self)
        self.delete_button.setToolTip("Delete a marked Point or a marked Area")
        self.delete_button.setIcon(self.style().standardIcon(QStyle.SP_TrashIcon))
        self.delete_button.setMinimumWidth(40)
        
        self.delete_button.clicked.connect(self.deleteClicked.emit)
        self._buttons_layout.addWidget(self.delete_button)
        
        
        

        # 5) chTime
        self.chTime_button = QPushButton("chT", self)
        self.chTime_button.setToolTip("Change the Step (time) of a point")
        self.chTime_button.setMaximumWidth(50)
        self.chTime_button.clicked.connect(self.chTimeClicked.emit)
        self._buttons_layout.addWidget(self.chTime_button)

        # 6) chEle
        self.chEle_button = QPushButton("chEle", self)
        self.chEle_button.setToolTip("Change the height of a single point or move a complete height of a marked area")
        self.chEle_button.setMaximumWidth(50)
        self.chEle_button.clicked.connect(self.chEleClicked.emit)
        self._buttons_layout.addWidget(self.chEle_button)

        # 7) ch%
        self.chPercent_button = QPushButton("ch%", self)
        self.chPercent_button.setToolTip("Change the percent of a point")
        self.chPercent_button.setMaximumWidth(50)
        self.chPercent_button.clicked.connect(self.chPercentClicked.emit)
        self._buttons_layout.addWidget(self.chPercent_button)
            
        self.more_button = QPushButton("...", self)
        self.more_button.setToolTip("More...")
        self.more_button.setMaximumWidth(50)  
        self._buttons_layout.addWidget(self.more_button)

        # (Menü anlegen)
        self.more_menu = QMenu(self.more_button)
        
        action_maxslope = self.more_menu.addAction("show max%")
        action_maxslope.triggered.connect(self.showMaxSlopeClicked.emit)
        
        action_minslope = self.more_menu.addAction("show min%")
        action_minslope.triggered.connect(self.showMinSlopeClicked.emit)
        
        action_maxspeed = self.more_menu.addAction("show MaxSpeed")
        action_minispeed = self.more_menu.addAction("show MinSpeed")

        action_maxspeed.triggered.connect(self.maxSpeedClicked.emit)
        action_minispeed.triggered.connect(self.minSpeedClicked.emit)
        
        action_avgspeed = self.more_menu.addAction("AverageSpeed")
        action_avgspeed.triggered.connect(self.averageSpeedClicked.emit)
        
        self._action_closegaps = self.more_menu.addAction("Close Gaps")
        self._action_closegaps.triggered.connect(self.closeGapsClicked.emit)
        
        action_del_way_errors = self.more_menu.addAction("Delete Way Errors")
        action_del_way_errors.triggered.connect(self.deleteWayErrorsClicked.emit)
        
        
        action_delete_time_errors = self.more_menu.addAction("Delete Time Errors")
        action_delete_time_errors.triggered.connect(self.deleteTimeErrorsClicked.emit)
        
        action_cut_before_b = self.more_menu.addAction("Cut all before markB")
        action_cut_before_b.triggered.connect(self.on_cut_before_b_clicked)

        action_cut_after_e = self.more_menu.addAction("Cut all after markB")
        action_cut_after_e.triggered.connect(self.on_cut_after_e_clicked)
        
        
        self._action_set_gpx2video = self.more_menu.addAction("SetGPX2VideoTime")
        self._action_set_gpx2video.setEnabled(False)  # standard aus
        self._action_set_gpx2video.triggered.connect(self._on_set_gpx2video_triggered)
        
        
        # Menü dem Button zuweisen
        self.more_button.clicked.connect(self._on_more_button_clicked)
              

        # 8) Undo
        self.undo_button = QPushButton("Undo", self)
        self.undo_button.setMaximumWidth(50)
        self.undo_button.clicked.connect(self.undoClicked.emit)
        self._buttons_layout.addWidget(self.undo_button)

        # 9) Smooth
        self.smooth_button = QPushButton("Smooth", self)
        self.undo_button.setMaximumWidth(50)
        self.smooth_button.setToolTip("Smooth the complete GPX \nChoose this only if you have complete edited!")
        self.smooth_button.clicked.connect(self.smoothClicked.emit)
        self._buttons_layout.addWidget(self.smooth_button)

        # 10) Save
        self.save_button = QPushButton("", self)
        self.save_button.setIcon(self.style().standardIcon(QStyle.SP_DriveHDIcon))
        self.save_button.setMinimumWidth(60)
        self.save_button.setMaximumWidth(80)
        
        self.save_button.clicked.connect(self.saveClicked.emit)
        self._buttons_layout.addWidget(self.save_button)

        self._buttons_layout.addStretch()  # optional: damit die Buttons nach links rücken

        # ---------------------------------------------
        # (B) Zweite Zeile: Info (Video/Length/Duration/Elev)
        # ---------------------------------------------
        self._info_layout = QHBoxLayout()
        self._info_layout.setSpacing(10)  # Zwischenraum zwischen Labels
        self.main_vbox.addLayout(self._info_layout)
        
        self.label_video = QLabel("Video: 00:00:00", self)
        self._info_layout.addWidget(self.label_video)

        self.label_length = QLabel("Length(GPX): 0.00 km", self)
        self._info_layout.addWidget(self.label_length)

        self.label_duration = QLabel("Duration(GPX): 00:00:00", self)
        self._info_layout.addWidget(self.label_duration)

        self.label_elev = QLabel("Elevation Gain: 0 m", self)
        self._info_layout.addWidget(self.label_elev)
        
        self.label_slope_max = QLabel("Max%: 0.0%", self)
        self._info_layout.addWidget(self.label_slope_max)
        
        self.label_slope_min = QLabel("Min%: 0.0%", self)
        self._info_layout.addWidget(self.label_slope_min)

        self.label_zerospeed = QLabel("ZeroSpeed: 0", self)
        self._info_layout.addWidget(self.label_zerospeed)
        
        self.label_paused = QLabel("Breaks: 0", self)
        self._info_layout.addWidget(self.label_paused)
        

        # Falls du sie mittig haben willst, kannst du z. B. links und rechts stretch:
        #self._info_layout.insertStretch(0)  # links
        self._info_layout.addStretch()      # rechts
        
    def _on_set_gpx2video_triggered(self):
        """
        Zeigt eine MessageBox mit den Zeitbereichen (Video + GPX).
        Fragt den User: "Do you want to sync GPX time to the Video time range?"
        Falls OK => wir skalieren den GPX-Bereich B..E auf dieselbe Länge wie Video-B..E
        und shiften alle nachfolgenden GPX-Punkte.
        """
        mw = self._mainwindow
        if not mw:
            return  # kein MainWindow => abbrechen
    
        #gom PySide6.QtWidgets import QMessageBox
        

        # --------------------------------------------------------------------
        # 1) Hilfsfunktion zur Formatierung in "xh ym zs" (siehe vorher)
        # --------------------------------------------------------------------
        def _format_duration(seconds: float) -> str:
            if seconds < 0:
                return "(not set)"
            total_s = int(round(seconds))
            hh = total_s // 3600
            rest = total_s % 3600
            mm = rest // 60
            ss = rest % 60
            parts = []
            if hh > 0:
                parts.append(f"{hh}h")
            if mm > 0:
                parts.append(f"{mm}min")
            if ss > 0 or (hh == 0 and mm == 0):
                parts.append(f"{ss}s")
            return " ".join(parts)

        # --------------------------------------------------------------------
        # 2) Video-Bereich: markB_time_s, markE_time_s
        # --------------------------------------------------------------------
        vB = mw.cut_manager.markB_time_s or -1
        vE = mw.cut_manager.markE_time_s or -1
        if vB < 0 or vE < 0 or vE <= vB:
            video_len = -1
        else:
            video_len = (vE - vB)

        video_start_str = _format_duration(vB)
        video_end_str   = _format_duration(vE)
        video_len_str   = _format_duration(video_len)

        # --------------------------------------------------------------------
        # 3) GPX-Bereich: b_idx, e_idx + rel_s
        # --------------------------------------------------------------------
        b_idx = mw.gpx_widget.gpx_list._markB_idx
        e_idx = mw.gpx_widget.gpx_list._markE_idx
        gpx_data = mw.gpx_widget.gpx_list._gpx_data

        # Start/End als Sekunden
        if b_idx is not None and 0 <= b_idx < len(gpx_data):
            gpx_b_sec = gpx_data[b_idx].get("rel_s", -1)
        else:
            gpx_b_sec = -1
    
        if e_idx is not None and 0 <= e_idx < len(gpx_data):
            gpx_e_sec = gpx_data[e_idx].get("rel_s", -1)
        else:
            gpx_e_sec = -1

        if gpx_b_sec < 0 or gpx_e_sec < 0 or gpx_e_sec <= gpx_b_sec:
            gpx_len_sec = -1
        else:
            gpx_len_sec = (gpx_e_sec - gpx_b_sec)

        gpx_start_str = _format_duration(gpx_b_sec)
        gpx_end_str   = _format_duration(gpx_e_sec)
        gpx_len_str   = _format_duration(gpx_len_sec)
    
        # --------------------------------------------------------------------
        # 4) Info an den User (Anzeigen der Bereiche)
        # --------------------------------------------------------------------
        msg_text = (
            "Video Range:\n"
            f"  Start:  {video_start_str}\n"
            f"  End:    {video_end_str}\n"
            f"  Length: {video_len_str}\n\n"
            "GPX Range:\n"
            f"  Start:  {gpx_start_str}\n"
            f"  End:    {gpx_end_str}\n"
            f"  Length: {gpx_len_str}\n\n"
            "Do you want to synchronize the GPX range to the Video range?"
        )

        reply = QMessageBox.question(
            self,
            "SetGPX2VideoTime",
            msg_text,
            QMessageBox.Ok | QMessageBox.Cancel,
            QMessageBox.Cancel
        )
        if reply != QMessageBox.Ok:
            # => Abbruch
            return
    
        # --------------------------------------------------------------------
        # 5) Nur wenn BEIDE Bereiche valide sind (>=0) => skalieren wir
        # --------------------------------------------------------------------
        if video_len <= 0 or gpx_len_sec <= 0:
            QMessageBox.information(
                self,
                "SetGPX2VideoTime",
                "Invalid range(s). Unable to synchronize."
            )
            return
    
        # => Undo-Snapshot
        old_data = copy.deepcopy(gpx_data)
        mw.gpx_widget.gpx_list._history_stack.append(old_data)
    
        # alt = gpx_len_sec, neu = video_len
        old_duration = gpx_len_sec
        new_duration = video_len
        diff_s = new_duration - old_duration
    
        # (A) Skalierung: b_idx..e_idx
        # Wir gehen i von b_idx+1.. e_idx => berechnen fraction:
        # fraction = (time[i] - time[b_idx]) / old_duration
        # new_time[i] = time[b_idx] + fraction*new_duration
        t_b0 = gpx_data[b_idx]["time"]  # datetime
    
        if old_duration < 1e-9:
            # => Abbruch
            QMessageBox.warning(self, "Error", "GPX range is effectively 0s => cannot scale.")
            return

        for i in range(b_idx+1, e_idx+1):
            old_ti = gpx_data[i]["time"]
            # fraction
            fraction = (gpx_data[i]["rel_s"] - gpx_b_sec) / old_duration
            # z. B. 0.0..1.0
            new_rel = fraction * new_duration
            # => new_abstime = t_b0 + new_rel sek
            gpx_data[i]["time"] = t_b0 + timedelta(seconds=new_rel)
    
        # (B) Shift aller Punkte nach e_idx um diff_s
        # => d. h. ab e_idx+1 bis zum Ende => time[j] += diff_s
        if e_idx < len(gpx_data)-1 and abs(diff_s) > 1e-9:
            for j in range(e_idx+1, len(gpx_data)):
                old_tj = gpx_data[j]["time"]
                gpx_data[j]["time"] = old_tj + timedelta(seconds=diff_s)
    
        # (C) recalc + set
        recalc_gpx_data(gpx_data)
        mw.gpx_widget.set_gpx_data(gpx_data)
        mw._gpx_data = gpx_data
        mw._update_gpx_overview()
    
        # => Chart, Map
        mw.chart.set_gpx_data(gpx_data)
        if mw.mini_chart_widget:
            mw.mini_chart_widget.set_gpx_data(gpx_data)
        route_geojson = mw._build_route_geojson_from_gpx(gpx_data)
        mw.map_widget.loadRoute(route_geojson, do_fit=False)
    
        # Finale Info
        QMessageBox.information(
            self,
            "SetGPX2VideoTime",
            f"GPX range has been rescaled from { _format_duration(old_duration) } "
            f"to { _format_duration(new_duration) }.\n"
            "Subsequent points were shifted accordingly."
        )
    

     
     
    
        
    def update_set_gpx2video_state(self, video_edit_on: bool, auto_sync_on: bool):
        """
        Schaltet den Menüpunkt "SetGPX2VideoTime" an/aus.
        - Nur aktiv, wenn video_edit_on == True und auto_sync_on == False
        """
        enable_it = (video_edit_on and (not auto_sync_on))
        self._action_set_gpx2video.setEnabled(enable_it)    
        
    def set_directions_mode(self, enabled: bool):
        if enabled:
            self._action_closegaps.setText("Close Gaps (Directions)")
        else:
            self._action_closegaps.setText("Close Gaps")    
        
    
    def _on_more_button_clicked(self):
        # Menü manuell anzeigen, z.B. leicht unterhalb des Buttons:
        pos = self.more_button.mapToGlobal(QPoint(0, self.more_button.height()))
        self.more_menu.exec_(pos)    
        
    def set_mainwindow(self, mw):
        """
        Mit dieser Methode geben wir dem GPXControlWidget
        einen Zeiger auf das MainWindow, damit wir dort
        auf ._gpx_data, .gpx_widget, .map_widget usw. zugreifen können.
        """
        self._mainwindow = mw   
        
    def on_save_gpx_clicked(self):
        
        """
        Wird aufgerufen, wenn man im GPXControlWidget den Safe-Button drückt.
        => Speichert die GPX-Daten, ggf. gekürzt auf finale Videolänge,
        falls Videos geladen wurden.
        """
        #from PySide6.QtWidgets import QFileDialog, QMessageBox

        # 1) Dateidialog
        out_path, _ = QFileDialog.getSaveFileName(
            self,
            "Save GPX File",
            "export.gpx",
            "GPX Files (*.gpx)"
        )
        if not out_path:
            return

        # 2) Falls kein Video => final_duration_s = "unendlich"
        mw = self._mainwindow
        if not mw:
            # Falls aus irgendeinem Grund kein MainWindow-Objekt gesetzt ist, abbrechen
            return
            
        if not mw.playlist or not mw.video_durations:
            # => gar kein Video => wir beschneiden NICHT
            final_duration_s = float('inf')
        else:
            # => Video vorhanden => berechne final_length
            final_duration_s = mw.real_total_duration
            sum_cuts_s = mw.cut_manager.get_total_cuts()
            final_duration_s -= sum_cuts_s
            if final_duration_s < 0:
                final_duration_s = 0

        # 3) GPX-Daten => z. B. gpx_list._gpx_data
        gpx_data = mw.gpx_widget.gpx_list._gpx_data
        if not gpx_data:
            QMessageBox.warning(self, "No GPX", "Keine GPX-Daten vorhanden!")
            return

        # 4) Kürzen => alle Punkte, deren rel_s <= final_duration_s
        truncated = []
        for pt in gpx_data:
            rel_s = pt.get("rel_s", 0.0)
            if rel_s <= final_duration_s:
                truncated.append(pt)
            else:
                break  # Annahme: Zeit ist aufsteigend

        if len(truncated) < 2:
            QMessageBox.warning(self, "Truncation", 
                "Nach Kürzen an die Videolänge bleibt kein sinnvolles GPX übrig!")
            return
    
        # 5) => Speichern
        mw._save_gpx_to_file(truncated, out_path)
        
        
        ret = mw._increment_counter_on_server("gpx")
        if ret is not None:
            vcount, gcount = ret
            print(f"[INFO] Server-Counter nun: Video={vcount}, GPX={gcount}")
        else:
            print("[WARN] Konnte GPX-Zähler nicht hochsetzen.")
    
        QMessageBox.information(self, "Done", 
            f"GPX-Daten wurden als '{out_path}' gespeichert.")



    # ----------------------------------------------------------
    # Methode zum Aktualisieren der Info-Zeile
    # ----------------------------------------------------------
   
    def update_info_line(self,
                     video_time_str: str,
                     length_km: float,
                     duration_str: str,
                     elev_gain: float,
                     slope_max: float = 0.0,
                     slope_min: float = 0.0,
                     zero_speed_count: int = 0,
                     paused_count: int = 0):                         
        """
        Aktualisiert die 4 Labels in der Infozeile:
        - Video
        - Length(GPX)
        - Duration(GPX)
        - Elevation Gain
        """
        self.label_video.setText(f"Video: {video_time_str}")
        self.label_length.setText(f"Length(GPX): {length_km:.2f} km")
        self.label_duration.setText(f"Duration(GPX): {duration_str}")
        self.label_elev.setText(f"Elevation Gain: {int(elev_gain)} m")
        self.label_slope_max.setText(f"Max%: {slope_max:.1f}%")
        self.label_slope_min.setText(f"Min%: {slope_min:.1f}%")
        self.label_zerospeed.setText(f"ZeroSpeed: {zero_speed_count}")
        self.label_paused.setText(f"Paused: {paused_count}")    
        
        
    def set_markE_visibility(self, visible: bool):
        """
        Zeigt oder versteckt den MarkE-Button.
        """
        self.markE_button.setVisible(visible)    
    
    def on_delete_range_clicked(self):
        """
        Wird ausgelöst, wenn der Delete-Button (Mülleimer) 
        im gpx_control_widget geklickt wurde.
        => Leitet an die gpx_list weiter.
        """
        mw = self._mainwindow
        mw.map_widget.view.page().runJavaScript("showLoading('Deleting GPX-Range...');")
        mw.gpx_widget.gpx_list.delete_selected_range()
        mw._update_gpx_overview()
        mw._gpx_data = mw.gpx_widget.gpx_list._gpx_data
        route_geojson = mw._build_route_geojson_from_gpx(mw._gpx_data)
        mw.map_widget.loadRoute(route_geojson, do_fit=False)
        mw.chart.set_gpx_data(mw._gpx_data)
        
        if mw.mini_chart_widget and mw._gpx_data:
            mw.mini_chart_widget.set_gpx_data(mw._gpx_data)
        
        mw.map_widget.view.page().runJavaScript("hideLoading();")
        
        
    def on_undo_range_clicked(self):
        mw = self._mainwindow
        """
        Wird ausgelöst, wenn der Undo-Button 
        im gpx_control_widget geklickt wurde.
        => Leitet an die gpx_list weiter.
        """
        mw.map_widget.view.page().runJavaScript("showLoading('Undo GPX-Range...');")
        mw.gpx_widget.gpx_list.undo_delete()
        mw._update_gpx_overview()
        mw._gpx_data = mw.gpx_widget.gpx_list._gpx_data
        route_geojson = mw._build_route_geojson_from_gpx(mw._gpx_data)
        mw.map_widget.loadRoute(route_geojson, do_fit=False)
        mw.chart.set_gpx_data(mw._gpx_data)
        if mw.mini_chart_widget:
            mw.mini_chart_widget.set_gpx_data(mw._gpx_data)

        mw.map_widget.view.page().runJavaScript("hideLoading();")    
        
        
    def _on_show_max_slope(self):
        mw = self._mainwindow
        # 1) Finde Index    
        #    z. B. idx_max = self._index_of_max_slope
        #    (woher? -> du hast es in _update_gpx_overview() schon)
        #    oder du rechnest hier nochmal:
        data = mw.gpx_widget.gpx_list._gpx_data
        if not data:
            return
        slopes = [pt["gradient"] for pt in data]
        idx_max = slopes.index(max(slopes))  # index des Max-Wertes

        # 2) Markieren in Chart, Map, GpxList, MiniChart
        mw._highlight_index_everywhere(idx_max)    
        
    def _on_show_min_slope(self):
        mw = self._mainwindow
        data = mw.gpx_widget.gpx_list._gpx_data
        if not data:
            return
        slopes = [pt["gradient"] for pt in data]
        idx_min = slopes.index(min(slopes))

        mw._highlight_index_everywhere(idx_min)    
        
        
        
    def on_average_speed_clicked(self):
        mw = self._mainwindow 
        """
        Shows the current average speed for the selected range b_idx.. e_idx
        *without changing total time*.
        If the user accepts, we distribute the times so that
        each subsegment has the same local speed (i.e., flatten spikes),
        but overall time remains the same.
        """
        #from PySide6.QtWidgets import QMessageBox
        

        gpx_data = mw.gpx_widget.gpx_list._gpx_data
        if not gpx_data:
            QMessageBox.warning(self, "No GPX Data", "No GPX data available.")
            return

        n = len(gpx_data)
        if n < 2:
            QMessageBox.warning(self, "Too few points", "At least 2 GPX points are required.")
            return
    
        b_idx = mw.gpx_widget.gpx_list._markB_idx
        e_idx = mw.gpx_widget.gpx_list._markE_idx
    
        if b_idx is None or e_idx is None:
            QMessageBox.warning(self, "No Range Selected",
                "Please mark a range (markB..markE) first.")
            return
        if b_idx > e_idx:
            b_idx, e_idx = e_idx, b_idx
        if (e_idx - b_idx) < 1:
            QMessageBox.warning(self, "Invalid Range",
                "The selected range must contain at least 2 points.")
            return
    
        # 1) Gesamt-Zeit
        t_start = gpx_data[b_idx]["time"]
        t_end   = gpx_data[e_idx]["time"]
        total_s = (t_end - t_start).total_seconds()
        if total_s <= 0:
            QMessageBox.warning(self, "Invalid Time",
                f"Time in the range {b_idx}..{e_idx} is zero or reversed.")
            return
    
        # 2) Distanz summieren
        total_dist_m = 0.0
        for i in range(b_idx, e_idx):
            lat1, lon1 = gpx_data[i]["lat"],   gpx_data[i]["lon"]
            lat2, lon2 = gpx_data[i+1]["lat"], gpx_data[i+1]["lon"]
            d2 = self._haversine_m(lat1, lon1, lat2, lon2)
            total_dist_m += d2
        if total_dist_m < 0.001:
            QMessageBox.warning(self, "Zero Distance",
                f"Range {b_idx}..{e_idx} has almost no distance => speed meaningless.")
            return
    
        dist_km = total_dist_m / 1000.0
        time_h = total_s / 3600.0
        old_avg_speed = dist_km / time_h  # km/h
    
        # 3) Frage, ob wir flatten wollen
        msg = (
            f"Range {b_idx}..{e_idx}\n"
            f"Total distance: {dist_km:.3f} km\n"
            f"Total time: {total_s:.1f} s\n\n"
            f"Current average speed in this range: {old_avg_speed:.2f} km/h\n\n"
            "Do you want to flatten spikes so that every subsegment\n"
            "has the same local speed? (Total time remains unchanged!)"
        )
        reply = QMessageBox.question(
            self, "Flatten Speed?",
            msg,
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No
        )
        if reply != QMessageBox.Yes:
            return  # aborted
    
        # 4) Undo-Snapshot
        old_data = copy.deepcopy(gpx_data)
        mw.gpx_widget.gpx_list._history_stack.append(old_data)
    
        # 5) partial-dist array
        partial_dist = [0.0]
        cum = 0.0
        for i in range(b_idx, e_idx):
            d2 = self._haversine_m(
                gpx_data[i]["lat"], gpx_data[i]["lon"],
                gpx_data[i+1]["lat"], gpx_data[i+1]["lon"]
            )
            cum += d2
            partial_dist.append(cum)
    
        # 6) Verteilen => time[i] = t_start + frac*total_s
        for k in range(1, e_idx - b_idx + 1):
            frac = partial_dist[k] / partial_dist[-1]  # last partial_dist is total_dist_m
            offset_s = total_s * frac
            gpx_data[b_idx + k]["time"] = t_start + timedelta(seconds=offset_s)
    
        # => e_idx bleibt t_end => identisch => also total_s bleibt 
        # => wir ändern NICHT time[e_idx], da offset_s=total_s an k = e_idx - b_idx
    
        # 7) recalc
        recalc_gpx_data(gpx_data)
        mw.gpx_widget.set_gpx_data(gpx_data)
        mw._gpx_data = gpx_data
        mw._update_gpx_overview()
    
        mw.chart.set_gpx_data(gpx_data)
        if mw.mini_chart_widget:
            mw.mini_chart_widget.set_gpx_data(gpx_data)
    
        #route_geojson = mw._build_route_geojson_from_gpx(gpx_data)
        #mw.map_widget.loadRoute(route_geojson, do_fit=False)

        QMessageBox.information(
            self, "Flatten done",
            "All subsegments in this range now share the same local speed.\n"
            "Total time remained unchanged."
        )
        mw.gpx_widget.gpx_list.clear_marked_range()
        mw.map_widget.clear_marked_range()
    
    def _haversine_m(self, lat1, lon1, lat2, lon2):
        """
        Evtl. Hilfsfunktion, 
        distance in Meter
        """
        
        R = 6371000
        d_lat = math.radians(lat2 - lat1)
        d_lon = math.radians(lon2 - lon1)
        a = (math.sin(d_lat/2)**2 
            + math.cos(math.radians(lat1))*math.cos(math.radians(lat2))
            * math.sin(d_lon/2)**2)
        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))
        return R*c
        
        
    def on_max_speed_clicked(self):
        mw = self._mainwindow
        """
        Called when the user selects 'MaxSpeed' in the More-Menu.
        We find the GPX point with the highest speed_kmh, 
        then highlight and center that point in map, table, and chart.
        """
        gpx_data = mw.gpx_widget.gpx_list._gpx_data
        if not gpx_data:
            return  # or show a warning

        # Liste der Geschwindigkeiten
        speeds = [pt.get("speed_kmh", 0.0) for pt in gpx_data]
        max_val = max(speeds)
        idx_max = speeds.index(max_val)

        # "Springen" => Map, Chart, Table
        mw._go_to_gpx_index(idx_max)    
        
    def on_min_speed_clicked(self):
        mw = self._mainwindow
        """
        Called when the user selects 'MinSpeed' in the More-Menu.
        We find the GPX point (except the very first point index=0)
        with the lowest speed_kmh, then highlight and center that point
        in map, table, and chart.
        """
        gpx_data = mw.gpx_widget.gpx_list._gpx_data
        if not gpx_data:
            return
        if len(gpx_data) < 2:
            # Kein "echter" Punkt außer Index 0
            return

        # Erstelle eine Liste (speed, index), beginnend ab Index 1
        # => so wird der erste Punkt (Index 0) ausgeschlossen.
        spd_idx_pairs = [
            (pt.get("speed_kmh", 0.0), i)
            for i, pt in enumerate(gpx_data)
            if i > 0  # ab Index 1
        ]
        if not spd_idx_pairs:
            return

        # min(...) mit key=lambda x: x[0] => vergleicht speed
        min_speed, idx_min = min(spd_idx_pairs, key=lambda x: x[0])

        mw._go_to_gpx_index(idx_min)




    def on_smooth_clicked(self):
        mw = self._mainwindow
        """
        Wird aufgerufen, wenn im GPXControlWidget der 'Smooth' Button gedrückt wird.
        - Öffnet einen Dialog mit 2 Parametern: Box_Smoothing (default=10), Flatten_Value (default=2)
        - Bei OK => ruft _apply_smoothing(...) auf, das die komplette GPX glättet
        - Schreibt Undo-History, damit man zurück kann
        """
        
        gpx_data = mw.gpx_widget.gpx_list._gpx_data
        if not gpx_data:
            QMessageBox.warning(self, "No GPX", "Keine GPX-Daten vorhanden zum Smoothen!")
            return

        # 1) Dialog
        dlg = QDialog(self)
        dlg.setWindowTitle("GPX Smoothing Parameters")
        vbox = QVBoxLayout(dlg)

        lbl_info = QLabel(
            "Apply Slope Box Smoothing + Flatten Value\n\n"
            "Box_Smoothing: Average slope over +/- N points\n"
            "Flatten_Value: Max slope change between adjacent points\n"
            "Default: Box_Smoothing=10, Flatten_Value=2"
        )
        vbox.addWidget(lbl_info)

        # Box Smoothing
        row_box = QHBoxLayout()
        lbl_box = QLabel("Box_Smoothing:")
        spin_box = QDoubleSpinBox()
        spin_box.setRange(1.0, 9999.0)  # z. B. 1..9999
        spin_box.setDecimals(0)        # als ganze Zahl?
        spin_box.setValue(10.0)        # Standard=10
        row_box.addWidget(lbl_box)
        row_box.addWidget(spin_box)
        vbox.addLayout(row_box)
    
        # Flatten Value
        row_flat = QHBoxLayout()
        lbl_flat = QLabel("Flatten_Value:")
        spin_flat = QDoubleSpinBox()
        spin_flat.setRange(0.0, 50.0)
        spin_flat.setDecimals(2)
        spin_flat.setValue(2.0)  # Default=2
        row_flat.addWidget(lbl_flat)
        row_flat.addWidget(spin_flat)
        vbox.addLayout(row_flat)
    
        # Buttons OK/Cancel
        h_btns = QHBoxLayout()
        btn_ok = QPushButton("OK")
        btn_cancel = QPushButton("Cancel")
        h_btns.addWidget(btn_ok)
        h_btns.addWidget(btn_cancel)
        vbox.addLayout(h_btns)
    
        def on_ok():
            dlg.accept()
        def on_cancel():
            dlg.reject()
        btn_ok.clicked.connect(on_ok)
        btn_cancel.clicked.connect(on_cancel)
    
        if not dlg.exec():
            return  # abgebrochen
    
        # Gelesene Werte
        box_smoothing = int(spin_box.value())      # ggf. Ganzzahl
        flatten_val   = spin_flat.value()
    
        # 2) Undo => Kopie
        old_data = copy.deepcopy(gpx_data)
        mw.gpx_widget.gpx_list._history_stack.append(old_data)
    
        # 3) => smoothing
        self._apply_smoothing(gpx_data, box_smoothing, flatten_val)
    
        # 4) => Neu set + recalc
        from core.gpx_parser import recalc_gpx_data
        recalc_gpx_data(gpx_data)
        mw.gpx_widget.set_gpx_data(gpx_data)
        mw._gpx_data = gpx_data
        mw._update_gpx_overview()
    
        # => evtl. Map + Chart
        #route_geojson = self._build_route_geojson_from_gpx(gpx_data)
        #self.map_widget.loadRoute(route_geojson, do_fit=False)
        mw.chart.set_gpx_data(gpx_data)
        if mw.mini_chart_widget:
            mw.mini_chart_widget.set_gpx_data(gpx_data)
            
        QMessageBox.information(
            self, "Smooth done",
            f"Smoothing applied with Box={box_smoothing}, Flatten={flatten_val:.2f}"
        )    
        
    def _apply_smoothing(self, gpx_data, box_size=10, flatten_val=2.0):
        """
        wendet 2-stufiges Smoothing an:
        1) Box slope smoothing
        2) Flatten Value => wenn slope-Änderung > flatten_val => clamp
        => hinterher reconstruct elevation
        """
        import math
    
        n = len(gpx_data)
        if n < 2:
            return

        # 1) Dist2D:
        dist2d = [0.0]*n
        for i in range(1, n):
            lat1, lon1 = gpx_data[i-1]["lat"], gpx_data[i-1]["lon"]
            lat2, lon2 = gpx_data[i]["lat"],  gpx_data[i]["lon"]
            dist2d[i] = self._haversine_m(lat1, lon1, lat2, lon2)

        # 2) slope[i] = (ele[i]-ele[i-1]) / dist2d[i] * 100
        slope = [0.0]*n
        for i in range(1, n):
            d2 = dist2d[i]
            if d2 > 0.01:
                slope[i] = ((gpx_data[i]["ele"] - gpx_data[i-1]["ele"]) / d2)*100
            else:
                slope[i] = 0.0

        # 3) Box smoothing => slope_smooth[i] = average of slope[i-box..i+box], clamp 0..n-1
        slope_smooth = slope[:]  # copy
        for i in range(n):
            start_i = max(0, i-box_size)
            end_i   = min(n-1, i+box_size)
            count   = (end_i - start_i + 1)
            if count < 1:
                continue
            ssum = 0.0
            for j in range(start_i, end_i+1):
                ssum += slope[j]
            slope_smooth[i] = ssum / count

        # 4) Flatten => wir gehen i=1..n-1, check delta to slope_smooth[i-1]
        for i in range(1, n):
            delta_slope = slope_smooth[i] - slope_smooth[i-1]
            if abs(delta_slope) > flatten_val:
                # clamp => slope_smooth[i] = slope_smooth[i-1] + sign(delta)*flatten_val
                sign_ = 1.0 if delta_slope>0 else -1.0
                slope_smooth[i] = slope_smooth[i-1] + sign_*flatten_val
    
        # 5) Nun reconstruct elevation => 
        #    ele[0] bleibt wie es war
        #    ele[i] = ele[i-1] + dist2d[i] * (slope_smooth[i]/100)
        new_ele = gpx_data[0]["ele"]
        for i in range(1, n):
            old_ele = gpx_data[i]["ele"]  # nur debug
            new_ele = gpx_data[i-1]["ele"] + (dist2d[i]*(slope_smooth[i]/100))
            gpx_data[i]["ele"] = new_ele
        
    # ===========  NEU am Ende von mainwindow.py ============    
    
    def on_chEle_clicked(self):
        mw = self._mainwindow
        """
        Wird aufgerufen, wenn der Button 'chEle' im GPXControlWidget gedrückt wird.
        Erweiterung:
        - Falls (markB..markE) existieren und mehr als 1 Punkt umfasst sind,
            öffnet einen Dialog für einen Elevation-Offset (z.B. +1.25m => +1.25).
        - Sonst (kein B..E oder nur 1 Zeile) => alter Single-Point-Dialog.
        """
       
        

        # Referenz auf die GPX-Daten
        gpx_data = mw.gpx_widget.gpx_list._gpx_data
        if not gpx_data:
            QMessageBox.warning(self, "No GPX", "No GPX data available.")
            return

        # (A) Prüfe, ob ein Bereich (B..E) vorliegt und mehr als 1 Punkt abdeckt
        b_idx = mw.gpx_widget.gpx_list._markB_idx
        e_idx = mw.gpx_widget.gpx_list._markE_idx

        valid_range = False
        if b_idx is not None and e_idx is not None:
            if b_idx > e_idx:
                b_idx, e_idx = e_idx, b_idx  # tauschen
            if 0 <= b_idx < len(gpx_data) and 0 <= e_idx < len(gpx_data) and (e_idx - b_idx) >= 1:
                valid_range = True
    
        if valid_range:
            # -----------------------------------------------
            # (1) Dialog -> "Offset für B..E"
            # -----------------------------------------------
            dlg = QDialog(self)
            dlg.setWindowTitle(f"Offset Elevation for Area {b_idx}..{e_idx}")
            vbox = QVBoxLayout(dlg)
    
            lbl_info = QLabel(
                "Increase/decrease the elevation of all marked points.\n"
                "For example: +1.25 => +1.25 Meter\n"
                "          -2.00 => -2.00 Meter\n"
            )
            vbox.addWidget(lbl_info)
    
            # SpinBox für Offset
            spin_offset = QDoubleSpinBox()
            spin_offset.setRange(-9999.0, 9999.0)
            spin_offset.setDecimals(2)      # cm-Schritte
            spin_offset.setSingleStep(0.01) # 1 cm
            spin_offset.setValue(0.0)
            vbox.addWidget(spin_offset)
    
            # OK/Cancel
            h_btns = QHBoxLayout()
            btn_ok = QPushButton("OK")
            btn_cancel = QPushButton("Cancel")
            h_btns.addWidget(btn_ok)
            h_btns.addWidget(btn_cancel)
            vbox.addLayout(h_btns)
    
            def on_ok():
                dlg.accept()
    
            def on_cancel():
                dlg.reject()
    
            btn_ok.clicked.connect(on_ok)
            btn_cancel.clicked.connect(on_cancel)
    
            if not dlg.exec():
                return  # abgebrochen
    
            offset_val = spin_offset.value()
            if abs(offset_val) < 1e-9:
                QMessageBox.information(self, "No change", "Offset=0 => no change.")
                return
    
            # => Undo-Snapshot
            old_data = copy.deepcopy(gpx_data)
            mw.gpx_widget.gpx_list._history_stack.append(old_data)
    
            # => wende offset an: gpx_data[b_idx..e_idx]
            for i in range(b_idx, e_idx + 1):
                old_ele = gpx_data[i].get("ele", 0.0)
                gpx_data[i]["ele"] = old_ele + offset_val
    
            # => recalc
            recalc_gpx_data(gpx_data)
            mw.gpx_widget.set_gpx_data(gpx_data)
            
            mw._update_gpx_overview()
    
            # => Chart, Map, MiniChart
            mw.chart.set_gpx_data(gpx_data)
            if mw.mini_chart_widget:
                mw.mini_chart_widget.set_gpx_data(gpx_data)
            route_geojson = mw._build_route_geojson_from_gpx(gpx_data)
            mw.map_widget.loadRoute(route_geojson, do_fit=False)
    
            QMessageBox.information(
                self, "Done",
                f"Elevation of all Points in {b_idx}..{e_idx} chamged by {offset_val:+.2f} m."
            )
            mw.gpx_widget.gpx_list.clear_marked_range()
            mw.map_widget.clear_marked_range()
    
        else:
            # -----------------------------------------------
            # (2) Einzel-Punkt-Dialog (alte Logik)
            # -----------------------------------------------
            row = mw.gpx_widget.gpx_list.table.currentRow()
            if row < 0:
                QMessageBox.warning(self, "No selection", "Please select a GPX point.")
                return
    
            if row >= len(gpx_data):
                return
    
            old_ele = gpx_data[row].get("ele", 0.0)
    
            # Undo
            import copy
            old_data = copy.deepcopy(gpx_data)
            mw.gpx_widget.gpx_list._history_stack.append(old_data)
    
            # Dialog => neue absolute Höhe
            dlg = QDialog(self)
            dlg.setWindowTitle(f"Change Elevation – Point {row}")
            vbox = QVBoxLayout(dlg)
    
            lbl_info = QLabel(
                f"Current elevation: {old_ele:.2f} m\n"
                f"Please enter new absolute value:"
            )
            vbox.addWidget(lbl_info)
    
            spin_ele = QDoubleSpinBox()
            spin_ele.setRange(-500.0, 9000.0)  # z. B. +9k m, -500 m
            spin_ele.setDecimals(2)
            spin_ele.setSingleStep(0.01)
            spin_ele.setValue(old_ele)
            vbox.addWidget(spin_ele)
    
            hbox_btn = QHBoxLayout()
            btn_ok = QPushButton("OK")
            btn_cancel = QPushButton("Cancel")
            hbox_btn.addWidget(btn_ok)
            hbox_btn.addWidget(btn_cancel)
            vbox.addLayout(hbox_btn)
    
            def on_ok_single():
                dlg.accept()
    
            def on_cancel_single():
                dlg.reject()
    
            btn_ok.clicked.connect(on_ok_single)
            btn_cancel.clicked.connect(on_cancel_single)
    
            if not dlg.exec():
                return  # abgebrochen
    
            new_ele = spin_ele.value()
            if abs(new_ele - old_ele) < 1e-9:
                QMessageBox.information(self, "No change", "Elevation unchanged.")
                return
    
            # -> setze
            gpx_data[row]["ele"] = new_ele
    
            # -> partial recalc (oder full recalc)
            recalc_gpx_data(gpx_data)
            mw.gpx_widget.set_gpx_data(gpx_data)
            
            mw._update_gpx_overview()
            
            
            # -> Chart, Map
            mw.chart.set_gpx_data(gpx_data)
            if mw.mini_chart_widget:
                mw.mini_chart_widget.set_gpx_data(gpx_data)
            route_geojson = mw._build_route_geojson_from_gpx(gpx_data)
            mw.map_widget.loadRoute(route_geojson, do_fit=False)
    
            QMessageBox.information(
                self, "OK",
                f"Elevation of Point {row} changed to {new_ele:.2f} m."
            )
            
            
    def on_chTime_clicked_gpx(self):
        
        mw = self._mainwindow
        """
        Changes the time (the 'step') either for:
        - a single GPX point (old behavior), if no valid range is selected
        - OR for all segments in the marked range (markB..markE),
        and subsequently shifts the following points.
        """
        #from PySide6.QtWidgets import (
        #    QDialog, QVBoxLayout, QHBoxLayout, QLabel,
        #    QDoubleSpinBox, QPushButton, QMessageBox
        #)
       

        gpx_data = mw.gpx_widget.gpx_list._gpx_data
        if not gpx_data:
            QMessageBox.warning(self, "No GPX Data", "No GPX data available.")
            return
    
        n = len(gpx_data)
        if n < 2:
            QMessageBox.warning(self, "Too few points",
                "At least 2 GPX points are required.")
            return
    
        # --- Check if we have a valid range markB..markE ---
        b_idx = mw.gpx_widget.gpx_list._markB_idx
        e_idx = mw.gpx_widget.gpx_list._markE_idx
    
        valid_range = False
        if b_idx is not None and e_idx is not None:
            if b_idx > e_idx:
                b_idx, e_idx = e_idx, b_idx
            if 0 <= b_idx < n and 0 <= e_idx < n and (e_idx - b_idx) >= 1:
                valid_range = True
    
        # ----------------------------------------------------------------
        # CASE A) No valid range => single-point mode
        # ----------------------------------------------------------------
        if not valid_range:
            row = mw.gpx_widget.gpx_list.table.currentRow()
            if row < 1 or row >= n:
                QMessageBox.warning(self, "Invalid Selection",
                    "Please select a GPX point (row >= 1). The first point (row=0) has no predecessor.")
                return
    
            # 1) Undo snapshot
            old_data = copy.deepcopy(gpx_data)
            mw.gpx_widget.gpx_list._history_stack.append(old_data)
    
            t_prev = gpx_data[row - 1].get("time", None)
            t_curr = gpx_data[row].get("time", None)
            if not t_prev or not t_curr:
                QMessageBox.warning(self, "Missing Time",
                    f"Point {row-1} or {row} has no 'time' set.")
                return
    
            old_diff_s = (t_curr - t_prev).total_seconds()
            if old_diff_s < 0:
                QMessageBox.warning(self, "Unsorted Track",
                    "time[row] < time[row-1]? The track seems unsorted.")
                return
    
            # 2) Dialog: new step
            dlg = QDialog(self)
            dlg.setWindowTitle("Change Step - Single Point")
            vbox = QVBoxLayout(dlg)
    
            info_lbl = QLabel(
                f"Current step = {old_diff_s:.3f} seconds.\n"
                "Please enter a new step (>= 0.001)."
            )
            vbox.addWidget(info_lbl)
    
            spin_new_step = QDoubleSpinBox()
            spin_new_step.setRange(0.001, 999999.0)   # removed the 10s limit
            spin_new_step.setValue(old_diff_s)
            spin_new_step.setDecimals(3)
            spin_new_step.setSingleStep(0.001)
            vbox.addWidget(spin_new_step)
    
            btn_box = QHBoxLayout()
            btn_ok = QPushButton("OK")
            btn_cancel = QPushButton("Cancel")
            btn_box.addWidget(btn_ok)
            btn_box.addWidget(btn_cancel)
            vbox.addLayout(btn_box)
    
            def on_ok():
                new_val = spin_new_step.value()
                if new_val < 0.001:
                    QMessageBox.warning(dlg, "Invalid Value",
                        "New step cannot be < 0.001!")
                    return
                dlg.accept()
    
            def on_cancel():
                dlg.reject()
    
            btn_ok.clicked.connect(on_ok)
            btn_cancel.clicked.connect(on_cancel)
    
            if not dlg.exec():
                return  # user cancelled
    
            new_step_s = spin_new_step.value()
            delta_s = new_step_s - old_diff_s
    
            # 3) Shift all times from row onwards
            for j in range(row, n):
                t_old = gpx_data[j]["time"]
                t_new = t_old + timedelta(seconds=delta_s)
                gpx_data[j]["time"] = t_new
    
            # 4) recalc + update
            recalc_gpx_data(gpx_data)
            mw.gpx_widget.set_gpx_data(gpx_data)
            mw._gpx_data = gpx_data
            mw._update_gpx_overview()
            mw.chart.set_gpx_data(gpx_data)
            if mw.mini_chart_widget:
                mw.mini_chart_widget.set_gpx_data(gpx_data)
    
            #route_geojson = mw._build_route_geojson_from_gpx(gpx_data)
            #mw.map_widget.loadRoute(route_geojson, do_fit=False)

            QMessageBox.information(
                self, "Done",
                f"Row {row} step changed by {delta_s:+.3f} s.\n"
                "All subsequent points shifted accordingly."
            )
            
            return
    
        # ----------------------------------------------------------------
        # CASE B) Valid range => B..E
        # ----------------------------------------------------------------
        else:
            # 1) Undo snapshot
            old_data = copy.deepcopy(gpx_data)
            mw.gpx_widget.gpx_list._history_stack.append(old_data)
    
            # 2) Calculate old total duration in [B..E]
            t_start = gpx_data[b_idx]["time"]
            t_end   = gpx_data[e_idx]["time"]
            old_total_s = (t_end - t_start).total_seconds()
            if old_total_s < 0:
                QMessageBox.warning(self, "Unsorted Track",
                    "Time in the selected range is reversed? (unsorted data)")
                return
    
            seg_count = e_idx - b_idx  # number of segments in [B..E]
    
            # 3) Dialog: new step for each of these seg_count segments
            dlg = QDialog(self)
            dlg.setWindowTitle(f"Change Step - Range {b_idx}..{e_idx}")
            vbox = QVBoxLayout(dlg)
    
            info_text = (
                f"You have selected a range from index {b_idx} to {e_idx}.\n"
                f"This corresponds to {seg_count} segments.\n\n"
                f"Current total duration in this range: {old_total_s:.3f} s\n"
                "Please enter a new step (in seconds) for each segment."
            )
            lbl_info = QLabel(info_text)
            vbox.addWidget(lbl_info)
    
            spin_range_step = QDoubleSpinBox()
            spin_range_step.setRange(0.001, 999999.0)  # no more 10s limit
            if seg_count > 0:
                spin_range_step.setValue(old_total_s / seg_count)
            else:
                spin_range_step.setValue(1.0)
            spin_range_step.setDecimals(3)
            spin_range_step.setSingleStep(0.001)
            vbox.addWidget(spin_range_step)
    
            btn_box = QHBoxLayout()
            btn_ok = QPushButton("OK")
            btn_cancel = QPushButton("Cancel")
            btn_box.addWidget(btn_ok)
            btn_box.addWidget(btn_cancel)
            vbox.addLayout(btn_box)
    
            def on_ok_range():
                new_val = spin_range_step.value()
                if new_val < 0.001:
                    QMessageBox.warning(dlg, "Invalid Value",
                        "New step cannot be < 0.001!")
                    return
                dlg.accept()
    
            def on_cancel_range():
                dlg.reject()
    
            btn_ok.clicked.connect(on_ok_range)
            btn_cancel.clicked.connect(on_cancel_range)
    
            if not dlg.exec():
                return  # user cancelled
    
            new_step_s = spin_range_step.value()
            new_total_s = seg_count * new_step_s
            diff_s = new_total_s - old_total_s
    
            # 4) Set times from B..E so that each segment has new_step_s
            #    Keep time[B_idx] as it is.
            for i in range(b_idx + 1, e_idx + 1):
                offset_s = (i - b_idx) * new_step_s
                gpx_data[i]["time"] = t_start + timedelta(seconds=offset_s)
    
            # 5) Shift all points after e_idx by diff_s
            if e_idx < n - 1 and abs(diff_s) > 1e-9:
                for j in range(e_idx + 1, n):
                    old_t = gpx_data[j]["time"]
                    gpx_data[j]["time"] = old_t + timedelta(seconds=diff_s)
    
            # 6) recalc + update
            recalc_gpx_data(gpx_data)
            mw.gpx_widget.set_gpx_data(gpx_data)
            mw._gpx_data = gpx_data
            mw._update_gpx_overview()
    
            mw.chart.set_gpx_data(gpx_data)
            if mw.mini_chart_widget:
                mw.mini_chart_widget.set_gpx_data(gpx_data)
    
            #route_geojson = mw._build_route_geojson_from_gpx(gpx_data)
            #mw.map_widget.loadRoute(route_geojson, do_fit=False)

            QMessageBox.information(
                self, "Done",
                f"All segments in the range {b_idx}..{e_idx} have been set to {new_step_s:.3f} s.\n"
                f"Old duration was {old_total_s:.3f} s, new duration is {new_total_s:.3f} s.\n"
                f"Subsequent points have been shifted by {diff_s:+.3f} s."
            )
            mw.gpx_widget.gpx_list.clear_marked_range()
            mw.map_widget.clear_marked_range()
   
    def on_chPercent_clicked(self):
        
        mw = self._mainwindow
        """
        Called when the user clicks the 'ch%' button.
        - If no valid range is selected (or only 1 point in that range),
        it changes the slope for a single point (row) relative to row-1.
        - If a valid range [markB..markE] with >=2 points is selected,
        it applies one consistent slope across that entire range,
        and shifts subsequent points accordingly.
        All user-facing texts are in English.
        """
        #from PySide6.QtWidgets import (
        #    QDialog, QVBoxLayout, QHBoxLayout, QLabel,
        #    QDoubleSpinBox, QPushButton, QMessageBox
        #)
        
    
        gpx_data = mw.gpx_widget.gpx_list._gpx_data
        if not gpx_data:
            QMessageBox.warning(self, "No GPX Data", "No GPX data available.")
            return
    
        n = len(gpx_data)
        if n < 2:
            QMessageBox.warning(self, "Too few points", "At least 2 GPX points are required.")
            return

        # --- Check if we have a valid markB..markE range ---
        b_idx = mw.gpx_widget.gpx_list._markB_idx
        e_idx = mw.gpx_widget.gpx_list._markE_idx
    
        valid_range = False
        if b_idx is not None and e_idx is not None:
            if b_idx > e_idx:
                b_idx, e_idx = e_idx, b_idx
            if 0 <= b_idx < n and 0 <= e_idx < n and (e_idx - b_idx) >= 1:
                valid_range = True

        # ------------------------------------------------------------------
        # CASE A) No valid range => single-point slope change
        # ------------------------------------------------------------------
        if not valid_range:
            row = mw.gpx_widget.gpx_list.table.currentRow()
            if row < 1:
                QMessageBox.warning(self, "Invalid Selection",
                    "Please select a point with row >= 1.\n"
                    "Cannot compute slope for the very first point (row=0).")
                return
            if row >= n:
                return
    
            # => Undo
            old_data = copy.deepcopy(gpx_data)
            mw.gpx_widget.gpx_list._history_stack.append(old_data)
    
            # lat/lon/ele for row-1 and row
            lat1, lon1, ele1 = (
                gpx_data[row-1].get("lat", 0.0),
                gpx_data[row-1].get("lon", 0.0),
                gpx_data[row-1].get("ele", 0.0)
            )
            lat2, lon2, ele2 = (
                gpx_data[row].get("lat", 0.0),
                gpx_data[row].get("lon", 0.0),
                gpx_data[row].get("ele", 0.0)
            )
    
            # Dist2D => we can reuse a small helper or do a direct haversine:
            dist_2d = self._haversine_m(lat1, lon1, lat2, lon2)
            if dist_2d < 0.01:
                QMessageBox.warning(self, "Zero Distance",
                    f"Points {row-1} and {row} have nearly no distance => slope undefined.")
                return
    
            old_slope = 100.0 * ((ele2 - ele1) / dist_2d)
    
            # Dialog => new slope
            dlg = QDialog(self)
            dlg.setWindowTitle(f"Change Slope (Single Point) - Row {row}")
            vbox = QVBoxLayout(dlg)
    
            lbl_info = QLabel(
                f"Current slope between row {row-1} and row {row}: {old_slope:.2f}%\n"
                "Please enter the new slope (in %)."
            )
            vbox.addWidget(lbl_info)
    
            spin_slope = QDoubleSpinBox()
            spin_slope.setRange(-200.0, 200.0)  # e.g. -200%.. 200%
            spin_slope.setDecimals(2)
            spin_slope.setSingleStep(0.01)
            spin_slope.setValue(old_slope)
            vbox.addWidget(spin_slope)
    
            h_btn = QHBoxLayout()
            btn_ok = QPushButton("OK")
            btn_cancel = QPushButton("Cancel")
            h_btn.addWidget(btn_ok)
            h_btn.addWidget(btn_cancel)
            vbox.addLayout(h_btn)
    
            def on_ok():
                dlg.accept()
    
            def on_cancel():
                dlg.reject()
    
            btn_ok.clicked.connect(on_ok)
            btn_cancel.clicked.connect(on_cancel)
    
            if not dlg.exec():
                return
    
            new_slope = spin_slope.value()
            if abs(new_slope - old_slope) < 1e-9:
                QMessageBox.information(self, "No change", "Slope unchanged.")
                return
    
            # => new ele2 = ele1 + dist_2d*(new_slope/100)
            new_ele2 = ele1 + dist_2d * (new_slope / 100.0)
            gpx_data[row]["ele"] = new_ele2
    
            # recalc
            recalc_gpx_data(gpx_data)
            mw.gpx_widget.set_gpx_data(gpx_data)
            mw._gpx_data = gpx_data
            mw._update_gpx_overview()
    
            mw.chart.set_gpx_data(gpx_data)
            if mw.mini_chart_widget:
                mw.mini_chart_widget.set_gpx_data(gpx_data)
    
            # Map
            #route_geojson = mw._build_route_geojson_from_gpx(gpx_data)
            #mw.map_widget.loadRoute(route_geojson, do_fit=False)

            diff_val = new_slope - old_slope
            QMessageBox.information(
                self, "Done",
                f"Slope changed from {old_slope:.2f}% to {new_slope:.2f}%.\n"
                f"Elevation of row {row} updated accordingly."
            )
            return

        # ------------------------------------------------------------------
        # CASE B) Valid range => single linear slope for [b_idx..e_idx]
        # ------------------------------------------------------------------
        else:
            # => Undo
            old_data = copy.deepcopy(gpx_data)
            mw.gpx_widget.gpx_list._history_stack.append(old_data)
    
            lat_b, lon_b, ele_b = (
                gpx_data[b_idx].get("lat", 0.0),
                gpx_data[b_idx].get("lon", 0.0),
                gpx_data[b_idx].get("ele", 0.0)
            )
            lat_e, lon_e, ele_e = (
                gpx_data[e_idx].get("lat", 0.0),
                gpx_data[e_idx].get("lon", 0.0),
                gpx_data[e_idx].get("ele", 0.0)
            )
    
            # (1) Compute the total 2D distance from b_idx.. e_idx
            #     Summation of each segment's distance in [b_idx.. e_idx-1].
            total_2d = 0.0
            for i in range(b_idx, e_idx):
                la1, lo1 = gpx_data[i]["lat"], gpx_data[i]["lon"]
                la2, lo2 = gpx_data[i+1]["lat"], gpx_data[i+1]["lon"]
                dist_2d = self._haversine_m(la1, lo1, la2, lo2)
                total_2d += dist_2d
    
            if total_2d < 0.01:
                QMessageBox.warning(self, "Zero Distance",
                    f"The range {b_idx}..{e_idx} has almost no distance => slope undefined.")
                return
    
            # (2) old average slope
            old_dz = ele_e - ele_b
            old_slope = 100.0 * (old_dz / total_2d)
    
            # (3) Dialog => new slope
            dlg = QDialog(self)
            dlg.setWindowTitle(f"Change Average Slope - Range {b_idx}..{e_idx}")
            vbox = QVBoxLayout(dlg)
    
            lbl_info = QLabel(
                f"You have selected a range from {b_idx} to {e_idx}.\n"
                f"Current average slope in this range: {old_slope:.2f}%\n\n"
                "Please enter the new slope in % (e.g., 5.0 means 5%)."
            )
            vbox.addWidget(lbl_info)
    
            spin_slope = QDoubleSpinBox()
            spin_slope.setRange(-200.0, 200.0)  # e.g. -200..+200%
            spin_slope.setDecimals(2)
            spin_slope.setSingleStep(0.01)
            spin_slope.setValue(old_slope)
            vbox.addWidget(spin_slope)
    
            h_btn = QHBoxLayout()
            btn_ok = QPushButton("OK")
            btn_cancel = QPushButton("Cancel")
            h_btn.addWidget(btn_ok)
            h_btn.addWidget(btn_cancel)
            vbox.addLayout(h_btn)
    
            def on_ok_range():
                dlg.accept()
    
            def on_cancel_range():
                dlg.reject()
    
            btn_ok.clicked.connect(on_ok_range)
            btn_cancel.clicked.connect(on_cancel_range)
    
            if not dlg.exec():
                return
    
            new_slope = spin_slope.value()
            if abs(new_slope - old_slope) < 1e-9:
                QMessageBox.information(self, "No change", "Slope unchanged.")
                return
    
            # (4) new total height difference => new_dz
            new_dz = total_2d * (new_slope / 100.0)
            shift_dz = new_dz - old_dz   # how much we add from e_idx onward
    
            # (5) Recompute elevations linearly from b_idx.. e_idx
            #     Keep ele[b_idx] as it is, 
            #     then for each i in [b_idx+1.. e_idx], 
            #     compute the cumulative distance from b_idx to i.
            def cumulative_distance(b_i, i_i):
                dist_sum = 0.0
                for x in range(b_i, i_i):
                    la1, lo1 = gpx_data[x]["lat"], gpx_data[x]["lon"]
                    la2, lo2 = gpx_data[x+1]["lat"], gpx_data[x+1]["lon"]
                    dist_sum += self._haversine_m(la1, lo1, la2, lo2)
                return dist_sum
    
            for i in range(b_idx+1, e_idx+1):
                dist_i = cumulative_distance(b_idx, i)
                # slope-based new altitude
                new_ele_i = ele_b + (new_slope / 100.0) * dist_i
                gpx_data[i]["ele"] = new_ele_i
    
            # (6) Shift all points after e_idx by shift_dz
            if e_idx < n-1 and abs(shift_dz) > 1e-9:
                for j in range(e_idx+1, n):
                    gpx_data[j]["ele"] = gpx_data[j]["ele"] + shift_dz
    
            # (7) recalc + update
            recalc_gpx_data(gpx_data)
            mw.gpx_widget.set_gpx_data(gpx_data)
            mw._gpx_data = gpx_data
            mw._update_gpx_overview()
    
            mw.chart.set_gpx_data(gpx_data)
            if mw.mini_chart_widget:
                mw.mini_chart_widget.set_gpx_data(gpx_data)
    
            #route_geojson = mw._build_route_geojson_from_gpx(gpx_data)
            #mw.map_widget.loadRoute(route_geojson, do_fit=False)

            QMessageBox.information(
                self, "Done",
                f"Average slope in {b_idx}..{e_idx} changed from {old_slope:.2f}% to {new_slope:.2f}%.\n"
                f"Subsequent points have been shifted by {shift_dz:+.2f} m in elevation."
            )
            mw.gpx_widget.gpx_list.clear_marked_range()
            mw.map_widget.clear_marked_range()
    
    def on_close_gaps_clicked(self):
        mw = self._mainwindow
        if not mw:
            return

        # 1) GPX-Daten + markB..markE prüfen
        gpx_data = mw.gpx_widget.gpx_list._gpx_data
        if not gpx_data:
            #from PySide6.QtWidgets import QMessageBox
            QMessageBox.warning(self, "No GPX Data", "No GPX data available.")
            return

        b_idx = mw.gpx_widget.gpx_list._markB_idx
        e_idx = mw.gpx_widget.gpx_list._markE_idx
        if b_idx is None or e_idx is None:
            QMessageBox.warning(self, "No Range Selected",
                "Please mark two consecutive points (markB..markE).")
            return

        if b_idx > e_idx:
            b_idx, e_idx = e_idx, b_idx

        # Prüfen, ob wirklich b_idx+1 == e_idx
        if e_idx != b_idx + 1:
            #from PySide6.QtWidgets import QMessageBox
            QMessageBox.information(self, "No Gap",
                "Close Gaps only works if exactly two consecutive points are selected.")
            return

        t1 = gpx_data[b_idx]["time"]
        t2 = gpx_data[e_idx]["time"]
        dt = (t2 - t1).total_seconds()
        if dt < 1.0:
            #from PySide6.QtWidgets import QMessageBox
            QMessageBox.information(self, "No Gap to Close",
                f"Time difference is only {dt:.2f}s (<1s). Nothing to insert.")
            return

        # 2) Check Directions-Flag
        if not mw._directions_enabled:
            # => Altes Verhalten
            self._close_gaps_local_interpolation(b_idx, e_idx, dt)
        else:
            # => Directions=True => zeige Profil-Auswahl (QDialog)
            #    Dann rufe _close_gaps_mapbox(..., profile)
            #    Du kannst standard=cycling, optional=driving/walking
            prof = self._ask_profile_mode()
            if not prof:
                # Abbruch
                return
        
            # Rufe neue Methode
            self._close_gaps_mapbox(b_idx, e_idx, dt, prof)

    def _ask_profile_mode(self) -> str:
        """
        Zeigt einen kleinen Dialog mit RadioButtons:
        Bike (cycling), Car (driving), Foot (walking).
        Gibt den Profil‐String zurück oder None bei Cancel.
        """
        dlg = QDialog(self)
        dlg.setWindowTitle("Select Transport Mode")
        vbox = QVBoxLayout(dlg)

        lbl = QLabel("Directions: Please select a mode:")
        vbox.addWidget(lbl)
    
        group = QButtonGroup(dlg)
        rb_bike = QRadioButton("Bike (Default)")
        rb_car  = QRadioButton("Car")
        rb_walk = QRadioButton("Foot")
        rb_bike.setChecked(True)
        group.addButton(rb_bike)
        group.addButton(rb_car)
        group.addButton(rb_walk)

        vbox.addWidget(rb_bike)
        vbox.addWidget(rb_car)
        vbox.addWidget(rb_walk)

        hbtn = QHBoxLayout()
        btn_ok = QPushButton("OK")
        btn_cancel = QPushButton("Cancel")
        hbtn.addWidget(btn_ok)
        hbtn.addWidget(btn_cancel)
        vbox.addLayout(hbtn)

        def on_ok():
            dlg.accept()
        def on_cancel():
            dlg.reject()

        btn_ok.clicked.connect(on_ok)
        btn_cancel.clicked.connect(on_cancel)

        if not dlg.exec():
            return None  # abbruch

        if rb_car.isChecked():
            return "driving"
        elif rb_walk.isChecked():
            return "walking"
        else:
            return "cycling"
        
            
    
    def on_delete_way_errors_clicked(self):
        mw = self._mainwindow
        """
        Sucht alle aufeinanderfolgenden Duplikate in lat/lon,
        entfernt den zweiten Punkt und setzt einen neuen Interpolationspunkt
        zwischen 'ersten' und 'übernächsten' Punkt, um die Zeit
        wieder in zwei (annähernd) gleiche Schritte zu teilen.
        """
        #from PySide6.QtWidgets import QMessageBox
       

        gpx_data = mw.gpx_widget.gpx_list._gpx_data
        if not gpx_data:
            QMessageBox.warning(self, "No GPX Data", "No GPX data available.")
            return

        n = len(gpx_data)
        if n < 3:
            QMessageBox.information(self, "Not enough points",
                "At least 3 points are needed to fix Way Errors.")
            return

        # ---------------------------------------------
        # 1) Finde alle Paare (i, i+1) mit identischem lat/lon
        # ---------------------------------------------
        way_errors = []
        for i in range(len(gpx_data)-1):
            lat1, lon1 = gpx_data[i]["lat"], gpx_data[i]["lon"]
            lat2, lon2 = gpx_data[i+1]["lat"], gpx_data[i+1]["lon"]
            # Wir prüfen "fast" identisch, z.B. |lat1-lat2|<1e-12
            if abs(lat1 - lat2) < 1e-12 and abs(lon1 - lon2) < 1e-12:
                way_errors.append(i)

        count_err = len(way_errors)
        if count_err == 0:
            QMessageBox.information(self, "No Way Errors",
                "No duplicate coordinates found.")
            return

        # ---------------------------------------------
        # 2) Nachfrage => "We found X errors. Fix them all?"
        # ---------------------------------------------
        answer = QMessageBox.question(
            self,
            "Delete Way Errors?",
            f"We found {count_err} Way Errors (duplicate lat/lon).\n"
            f"Should we fix them all?",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No
        )
        if answer != QMessageBox.Yes:
            return

        # ---------------------------------------------
        # 3) Undo-Snapshot
        # ---------------------------------------------
        old_data = copy.deepcopy(gpx_data)
        mw.gpx_widget.gpx_list._history_stack.append(old_data)

        # ---------------------------------------------
        # 4) Fixen der Fehler - am besten in absteigender Index-Reihenfolge
        #
        #    Grund: Wenn wir i+1 entfernen, rückt i+2 -> i+1 usw.
        #           In absteigender Reihenfolge stören wir die
        #           kleineren Indizes nicht.
        # ---------------------------------------------
        way_errors.sort(reverse=True)

        for i in way_errors:
            if i >= len(gpx_data)-1:
                # Schon rausgeflogen oder am Ende -> skip
                continue

            # => i, i+1 haben identische lat/lon
            # => wir wollen i+1 löschen
            # => Dann haben wir Lücke => i.. i+2 (nach dem Löschen),
            #    wir teilen die Zeit. 
            # => ABER wir brauchen i+2 => check, ob i+2 existiert:
            if i+2 >= len(gpx_data):
                # wir können nicht vermitteln, da kein i+2
                # z.B. am Ende der Liste
                continue

            # (A) Hole Zeiten
            t_i   = gpx_data[i]["time"]
            t_ip2 = gpx_data[i+2]["time"]
            dt_total = (t_ip2 - t_i).total_seconds()
            if dt_total <= 0:
                # unsortiert => skip
                continue

            # (B) Hole Koordinaten i, i+2
            lat_i, lon_i, ele_i = (
                gpx_data[i]["lat"], gpx_data[i]["lon"], gpx_data[i]["ele"]
            )
            lat_ip2, lon_ip2, ele_ip2 = (
                gpx_data[i+2]["lat"], gpx_data[i+2]["lon"], gpx_data[i+2]["ele"]
            )

            # => Den zu entfernenden Punkt i+1
            # => wir schmeißen ihn raus
            gpx_data.pop(i+1)

            # => nun i+2 ist zum "i+1" geworden
            # => wir legen in der Mitte einen neuen Punkt an
            t_mid = t_i + timedelta(seconds=dt_total/2)
            lat_mid = lat_i + 0.5*(lat_ip2 - lat_i)
            lon_mid = lon_i + 0.5*(lon_ip2 - lon_i)
            ele_mid = ele_i + 0.5*(ele_ip2 - ele_i)

            new_pt = {
                "lat": lat_mid,
                "lon": lon_mid,
                "ele": ele_mid,
                "time": t_mid,
                "delta_m": 0.0,
                "speed_kmh": 0.0,
                "gradient": 0.0,
                "rel_s": 0.0
            }
            # => Insert an i+1
            gpx_data.insert(i+1, new_pt)

            # => i+2 existiert weiterhin, plus wir haben i+1 als middle
            # => Zeit: i..(i+1) ~ dt_total/2, (i+1)..(i+2) ~ dt_total/2
            # => lat/lon linear

        # ---------------------------------------------
        # 5) Recalc + Updates
        # ---------------------------------------------
        recalc_gpx_data(gpx_data)
        mw.gpx_widget.set_gpx_data(gpx_data)
        mw._gpx_data = gpx_data
        mw._update_gpx_overview()

        mw.chart.set_gpx_data(gpx_data)
        if mw.mini_chart_widget:
            mw.mini_chart_widget.set_gpx_data(gpx_data)

        route_geojson = mw._build_route_geojson_from_gpx(gpx_data)
        mw.map_widget.loadRoute(route_geojson, do_fit=False)

        QMessageBox.information(
            self,
            "Delete Way Errors",
            f"{count_err} Way Errors fixed (where possible)."
        )
    
        
    def on_delete_time_errors_clicked(self):
        mw = self._mainwindow
        """
        Called when the user selects 'Delete Time Errors' in the More-menu.
        We look for all GPX points i where time[i] == time[i-1] => step=0.
        Then we ask the user if we should remove them all.
        After confirmation, we remove them from gpx_data, recalc, and update.
        """
        #from PySide6.QtWidgets import QMessageBox
      

        gpx_data = mw.gpx_widget.gpx_list._gpx_data
        if not gpx_data:
            QMessageBox.warning(self, "No GPX Data", "No GPX data available.")
            return

        n = len(gpx_data)
        if n < 2:
            QMessageBox.information(self, "Not enough points", 
                "There are not enough points to check for time errors.")
            return

        # 1) Alle Indizes i (1..n-1) suchen, bei denen time[i] == time[i-1]
        zero_step_indices = []
        for i in range(1, n):
            t_cur = gpx_data[i]["time"]
            t_prev = gpx_data[i-1]["time"]
            if t_cur == t_prev:
                zero_step_indices.append(i)

        count_err = len(zero_step_indices)
        if count_err == 0:
            QMessageBox.information(self, "No Time Errors",
                "No points with 0s step found.")
            return

        # 2) Nachfrage => "We found X time errors. Do you want to remove them?"
        answer = QMessageBox.question(
            self,
            "Delete Time Errors?",
            f"We found {count_err} time errors (0s step). Do you want to remove them all?",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No
        )
        if answer != QMessageBox.Yes:
            return

        # 3) Undo-Snapshot
        old_data = copy.deepcopy(gpx_data)
        mw.gpx_widget.gpx_list._history_stack.append(old_data)

        # 4) Entfernen der betroffenen Indizes (in absteigender Reihenfolge!)
        zero_step_indices.sort(reverse=True)
        for i in zero_step_indices:
            # i < len(gpx_data) ?
            if i < len(gpx_data):
                gpx_data.pop(i)

        # 5) recalc + updates
        recalc_gpx_data(gpx_data)
        mw.gpx_widget.set_gpx_data(gpx_data)
        mw._gpx_data = gpx_data
        mw._update_gpx_overview()

        mw.chart.set_gpx_data(gpx_data)
        if mw.mini_chart_widget:
            mw.mini_chart_widget.set_gpx_data(gpx_data)

        route_geojson = mw._build_route_geojson_from_gpx(gpx_data)
        mw.map_widget.loadRoute(route_geojson, do_fit=False)

        QMessageBox.information(
            self, "Done",
            f"{count_err} Time Errors removed."
        )    
        
    def on_cut_before_b_clicked(self):
        """
        Löscht alle GPX-Punkte von Index 0 bis einschließlich MarkB
        und verschiebt anschließend die Zeit so, dass die neue erste Zeit = 0 ist.
        Danach Chart/Map/Minichart/Tabelle usw. updaten.
        """
        mw = self._mainwindow
        if mw is None:
            return  # kein MainWindow-Objekt gesetzt
    
        b_idx = mw.gpx_widget.gpx_list._markB_idx
        if b_idx is None:
            # Falls gar kein MarkB existiert => Abbruch
            #from PySide6.QtWidgets import QMessageBox
            QMessageBox.warning(self, "Cut <B", "No MarkB set.")
            return
    
        # Schneller Zugriff
        gpx_data = mw.gpx_widget.gpx_list._gpx_data
        if not gpx_data:
            return
        
        if b_idx < 0 or b_idx >= len(gpx_data):
            # Sicherheitscheck
            return
    
        # 1) Undo-Snapshot
        
        old_data = copy.deepcopy(gpx_data)
        mw.gpx_widget.gpx_list._history_stack.append(old_data)
    
        # 2) Löschen der Daten von 0..b_idx (inkl. b_idx)
        del gpx_data[0 : b_idx+1]

        if not gpx_data:
            # Falls jetzt gar nichts mehr übrig bleibt
            # -> wir setzen die Liste leer und updaten
            mw.gpx_widget.set_gpx_data([])
            mw._gpx_data = []
            # Alle Widgets neu leeren
            mw.chart.set_gpx_data([])
            if mw.mini_chart_widget:
                mw.mini_chart_widget.set_gpx_data([])
            mw.map_widget.loadRoute(None, do_fit=False)
            mw._update_gpx_overview()
            mw.gpx_widget.gpx_list.clear_marked_range()
            mw.map_widget.clear_marked_range()
            return
    
        # 3) Zeiten so verschieben, dass neuer Startpunkt rel_s=0
        
        shift_s = gpx_data[0].get("rel_s", 0.0)
        if shift_s > 0:
            for pt in gpx_data:
                pt["rel_s"] = pt["rel_s"] - shift_s
            # echte Time-Objekte ebenfalls verschieben
            import datetime
            first_time = gpx_data[0]["time"]
            # wir gehen davon aus, dass "time" monoton ist
            # => shift_dt = old_first_time - new_first_time
            #    Hier: new_first_time soll 1:1 = first_time bleiben, 
            #    also eigentlich kein SHIFT in "time" nötig 
            #    ODER du verschiebst "time" so, dass time[0] = originalZeit.
            #    Das ist Geschmackssache. 
            # => wir rufen recalc an, das berechnet delta_m, speed, gradient
        recalc_gpx_data(gpx_data)
    
        # 4) Data neu in GUI setzen
        mw.gpx_widget.set_gpx_data(gpx_data)
        mw._gpx_data = gpx_data
    
        # 5) Tabellen/Charts/Map etc. neu aufbauen
        mw._update_gpx_overview()
        route_geojson = mw._build_route_geojson_from_gpx(gpx_data)
        mw.map_widget.loadRoute(route_geojson, do_fit=False)
        mw.chart.set_gpx_data(gpx_data)
        if mw.mini_chart_widget:
            mw.mini_chart_widget.set_gpx_data(gpx_data)
        
        # 6) Markierungen zurücksetzen
        mw.gpx_widget.gpx_list.clear_marked_range()
        mw.map_widget.clear_marked_range()
    
    
    def on_cut_after_e_clicked(self):
        """
        Löscht alle GPX-Punkte ab MarkE bis zum Ende (einschl. E).
        Falls kein MarkE existiert, aber ein MarkB gesetzt ist, 
        verwenden wir ersatzweise MarkB als E.
        """
        mw = self._mainwindow
        if mw is None:
            return
    
        # Primär: MarkE-Index
        e_idx = mw.gpx_widget.gpx_list._markE_idx

        # Fallback: falls MarkE nicht gesetzt, nimm MarkB
        if e_idx is None:
            e_idx = mw.gpx_widget.gpx_list._markB_idx

        # Falls weder B noch E gesetzt => Fehlermeldung
        if e_idx is None:
            #from PySide6.QtWidgets import QMessageBox
            QMessageBox.warning(self, "Cut >E", "No MarkE or MarkB set.")
            return
    
        gpx_data = mw.gpx_widget.gpx_list._gpx_data
        if not gpx_data:
            return
    
        if e_idx < 0 or e_idx >= len(gpx_data):
            return
    
        # 1) Undo-Snapshot
        
        old_data = copy.deepcopy(gpx_data)
        mw.gpx_widget.gpx_list._history_stack.append(old_data)
    
        # 2) Löschen ab e_idx (inkl.) bis zum Ende
        del gpx_data[e_idx:]

        if not gpx_data:
            # Falls dabei alles wegfällt
            mw.gpx_widget.set_gpx_data([])
            mw._gpx_data = []
            mw.chart.set_gpx_data([])
            if mw.mini_chart_widget:
                mw.mini_chart_widget.set_gpx_data([])
            mw.map_widget.loadRoute(None, do_fit=False)
            mw._update_gpx_overview()
            mw.gpx_widget.gpx_list.clear_marked_range()
            mw.map_widget.clear_marked_range()
            return
        
        # 3) recalc
        
        recalc_gpx_data(gpx_data)
        
        # 4) Neu setzen und Widgets aktualisieren
        mw.gpx_widget.set_gpx_data(gpx_data)
        mw._gpx_data = gpx_data
        
        mw._update_gpx_overview()
        route_geojson = mw._build_route_geojson_from_gpx(gpx_data)
        mw.map_widget.loadRoute(route_geojson, do_fit=False)
        mw.chart.set_gpx_data(gpx_data)
        if mw.mini_chart_widget:
            mw.mini_chart_widget.set_gpx_data(gpx_data)
        
        # 5) Markierungen zurücksetzen
        mw.gpx_widget.gpx_list.clear_marked_range()
        mw.map_widget.clear_marked_range()
    
        
        
    def highlight_markB_button(self):
        """Zeigt MarkB-Button in roter Farbe an."""
        self.markB_button.setStyleSheet("background-color: red; color: white;")

    def highlight_markE_button(self):
        """Zeigt MarkE-Button in roter Farbe an."""
        self.markE_button.setStyleSheet("background-color: red; color: white;")

    def reset_mark_buttons(self):
        """Setzt MarkB- und MarkE-Button auf ihr ursprüngliches StyleSheet zurück."""
        self.markB_button.setStyleSheet(self._default_markB_style)
        self.markE_button.setStyleSheet(self._default_markE_style)
        
        
    def _close_gaps_local_interpolation(self, b_idx: int, e_idx: int, dt: float):
        """
        Das ist dein alter Code, der zwischen b_idx und e_idx
        lineare Punkte einfügt, damit jeder Schritt ~1s lang ist.
        """
        mw = self._mainwindow
        gpx_data = mw.gpx_widget.gpx_list._gpx_data

        # 1) Undo-Snapshot
        
        old_data = copy.deepcopy(gpx_data)
        mw.gpx_widget.gpx_list._history_stack.append(old_data)

        # 2) Koordinaten
        lat1, lon1, ele1 = gpx_data[b_idx]["lat"], gpx_data[b_idx]["lon"], gpx_data[b_idx]["ele"]
        lat2, lon2, ele2 = gpx_data[e_idx]["lat"], gpx_data[e_idx]["lon"], gpx_data[e_idx]["ele"]
        t1 = gpx_data[b_idx]["time"]

        # 3) Wie bisher: Anzahl Intervalle = round(dt)
        
        num_intervals = int(round(dt))
        if num_intervals < 2:
            #from PySide6.QtWidgets import QMessageBox
            QMessageBox.information(self, "No Gap to Close",
                f"Time difference ~{dt:.2f}s => no extra points needed.")
            return

        sub_s = dt / num_intervals
        new_points = []
        for i in range(1, num_intervals):
            frac = i / num_intervals
            new_t = t1 + timedelta(seconds=sub_s * i)
            lat_new = lat1 + frac*(lat2 - lat1)
            lon_new = lon1 + frac*(lon2 - lon1)
            ele_new = ele1 + frac*(ele2 - ele1)
            pt = {
                "lat": lat_new,
                "lon": lon_new,
                "ele": ele_new,
                "time": new_t,
                "delta_m": 0.0,
                "speed_kmh": 0.0,
                "gradient": 0.0,
                "rel_s": 0.0
            }
            new_points.append(pt)

        # 4) Einfügen
        for i, p in enumerate(new_points):
            gpx_data.insert(b_idx + 1 + i, p)
    
        # 5) recalc
        
        recalc_gpx_data(gpx_data)
        mw.gpx_widget.set_gpx_data(gpx_data)
        mw._gpx_data = gpx_data
        mw._update_gpx_overview()
    
        mw.chart.set_gpx_data(gpx_data)
        if mw.mini_chart_widget:
            mw.mini_chart_widget.set_gpx_data(gpx_data)
        route_geojson = mw._build_route_geojson_from_gpx(gpx_data)
        mw.map_widget.loadRoute(route_geojson, do_fit=False)

        #from PySide6.QtWidgets import QMessageBox
        QMessageBox.information(self, "Close Gaps",
            f"Inserted {len(new_points)} new point(s)\n(time-based local interpolation).")

        # 6) Markierungen zurücksetzen
        mw.gpx_widget.gpx_list.clear_marked_range()
        mw.map_widget.clear_marked_range()
    
    
    def _close_gaps_mapbox(self, b_idx: int, e_idx: int, dt: float, profile: str):
        """
        Ruft die Mapbox Directions API auf (profil = 'driving','cycling','walking'),
        berechnet time-based Densify in 1s-Schritten,
        und ersetzt b_idx..e_idx im GPX durch die neue Route.
        """
        mw = self._mainwindow
        gpx_data = mw.gpx_widget.gpx_list._gpx_data

       
        #from PySide6.QtWidgets import QMessageBox
      
    
        # 1) Undo-Snapshot
        old_data = copy.deepcopy(gpx_data)
        mw.gpx_widget.gpx_list._history_stack.append(old_data)

        lat1, lon1 = gpx_data[b_idx]["lat"], gpx_data[b_idx]["lon"]
        lat2, lon2 = gpx_data[e_idx]["lat"], gpx_data[e_idx]["lon"]

        # 2) Key prüfen
        if not mw._mapbox_key:
            QMessageBox.warning(self, "Mapbox Key missing",
                "Directions=True, aber kein mapbox_key gesetzt.\nFalle zurück auf lokale Interpolation.")
            self._close_gaps_local_interpolation(b_idx, e_idx, dt)
            return

        # 3) URL bauen (Mapbox-Directions)
        base_url = "https://api.mapbox.com/directions/v5/mapbox"
        url = (f"{base_url}/{profile}/{lon1:.6f},{lat1:.6f};{lon2:.6f},{lat2:.6f}"
            f"?geometries=geojson&overview=full&access_token={mw._mapbox_key}")
    
        # 4) HTTP an Mapbox per urllib
        try:
            with urllib.request.urlopen(url, timeout=10) as resp:
                body = resp.read().decode("utf-8")
            data = json.loads(body)
        except Exception as ex:
            QMessageBox.critical(self, "Mapbox Error",
                f"Could not fetch route from Mapbox:\n{ex}\n\nFalle zurück auf lokale Interpolation.")
            self._close_gaps_local_interpolation(b_idx, e_idx, dt)
            return

        if "routes" not in data or not data["routes"]:
            QMessageBox.warning(self, "No Route",
                "Mapbox lieferte keine 'routes' zurück.\nFalle zurück auf lokal.")
            self._close_gaps_local_interpolation(b_idx, e_idx, dt)
            return

        coords = data["routes"][0]["geometry"]["coordinates"]  # => [[lon, lat], [lon, lat], ...]
    
        if len(coords) < 2:
            QMessageBox.warning(self, "Invalid route",
                "Zu wenige Punkte in Mapbox-Route.\nFalle zurück auf lokal.")
            self._close_gaps_local_interpolation(b_idx, e_idx, dt)
            return

        # 5) Distanzberechnung => wir bauen Segmente, 
        #    dann verteilen wir dt in 1s-Schritte => time-based densify
        def haversine_m(latA, lonA, latB, lonB):
            import math
            R = 6371000
            rLA = math.radians(latA)
            rLB = math.radians(latB)
            dLat = rLB - rLA
            dLon = math.radians(lonB - lonA)
            a = (math.sin(dLat/2)**2
                + math.cos(rLA)*math.cos(rLB)*math.sin(dLon/2)**2)
            return R*2*math.atan2(math.sqrt(a), math.sqrt(1-a))

        # Koords in (lat, lon) => big_coords
        big_coords = [(c[1], c[0]) for c in coords]  # c[0]=lon, c[1]=lat

        segments = []
        total_dist = 0.0
        for i in range(len(big_coords)-1):
            la1, lo1 = big_coords[i]
            la2, lo2 = big_coords[i+1]
            d = haversine_m(la1, lo1, la2, lo2)
            segments.append((la1, lo1, la2, lo2, d, total_dist))
            total_dist += d

        if total_dist < 0.01:
            QMessageBox.information(self, "No Distance", 
                "Mapbox lieferte quasi Start=End.\nFalle zurück auf lokal.")
            self._close_gaps_local_interpolation(b_idx, e_idx, dt)
            return

        # Hilfsfunc
        def get_coord_at_dist(dist_val):
            # dist_val=0 => Start, dist_val>=total_dist => End
            if dist_val<=0:
                return big_coords[0]
            if dist_val>=total_dist:
                return big_coords[-1]
            for seg in segments:
                la1, lo1, la2, lo2, dseg, segStart = seg
                segEnd = segStart + dseg
                if dist_val>=segStart and dist_val<=segEnd:
                    frac = (dist_val-segStart)/dseg
                    lat_ = la1 + frac*(la2-la1)
                    lon_ = lo1 + frac*(lo2-lo1)
                    return (lat_, lon_)
            # fallback
            return big_coords[-1]

        # => now 1s-Schritte
       
        new_points = []
        t_start = gpx_data[b_idx]["time"]
        # final => gpx_data[e_idx]["time"] => dt sek

        speed_ms = total_dist/dt
        # how many integer steps => floor(dt)
        steps_count = int(math.floor(dt))
        if steps_count<1:
            steps_count=1

        for i in range(steps_count+1):
            dist_i = i*speed_ms
            if dist_i>total_dist:
                dist_i=total_dist
            (lat_, lon_) = get_coord_at_dist(dist_i)
            t_new = t_start + timedelta(seconds=i)
            pt = {
                "lat": lat_,
                "lon": lon_,
                "ele": 0.0,  # falls du ELEVation linear interpolieren willst, machst du es später
                "time": t_new,
                "delta_m": 0.0,
                "speed_kmh": 0.0,
                "gradient": 0.0,
                "rel_s": 0.0
            }
            new_points.append(pt)

        # Letzter Punkt => exaktes E
        latE, lonE = gpx_data[e_idx]["lat"], gpx_data[e_idx]["lon"]
        new_points[-1]["lat"] = latE
        new_points[-1]["lon"] = lonE
        new_points[-1]["time"] = gpx_data[e_idx]["time"]

        # Optional: Elevation linear B->E
        eleB = gpx_data[b_idx]["ele"]
        eleE = gpx_data[e_idx]["ele"]
        total_count = len(new_points)-1
        for i in range(1, total_count):
            frac = i/total_count
            new_points[i]["ele"] = eleB + frac*(eleE-eleB)

        # 6) b_idx+1.. e_idx entfernen
        del gpx_data[b_idx+1 : e_idx+1]

        # Füge new_points[1..] ein (index=0 ist b_idx selbst)
        for i, p in enumerate(new_points[1:], start=1):
            gpx_data.insert(b_idx + i, p)

        # 7) recalc
       
        recalc_gpx_data(gpx_data)
        mw.gpx_widget.set_gpx_data(gpx_data)
        mw._gpx_data = gpx_data
        mw._update_gpx_overview()

        mw.chart.set_gpx_data(gpx_data)
        if mw.mini_chart_widget:
            mw.mini_chart_widget.set_gpx_data(gpx_data)
        route_geojson = mw._build_route_geojson_from_gpx(gpx_data)
        mw.map_widget.loadRoute(route_geojson, do_fit=False)

        QMessageBox.information(self, "Close Gaps (Mapbox)",
            f"Inserted {len(new_points)-1} new point(s)\n"
            f"via Directions={profile}, total time {dt:.2f}s kept.")

        mw.gpx_widget.gpx_list.clear_marked_range()
        mw.map_widget.clear_marked_range()

```
import math
from datetime import datetime
import platform

from PySide6.QtCore import Qt, Signal, QTimer
from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QTableWidget, QTableWidgetItem,
    QHeaderView, QAbstractItemView, QStyledItemDelegate, QStyle,
    QAbstractScrollArea
)
from PySide6.QtGui import QColor



class MarkColumnDelegate(QStyledItemDelegate):
    """
    Delegate für Spalte 8 ("Mark"):
    Ignoriert den Selektions-State, damit Spalte 8 nicht blau übermalt wird.
    """
    def paint(self, painter, option, index):
        # Wenn Spalte 8 selektiert wäre, entfernen wir den Selektionszustand,
        # damit der Hintergrund (z.B. rot) sichtbar bleibt.
        if index.column() == 8 and (option.state & QStyle.State_Selected):
            option.state &= ~QStyle.State_Selected
        super().paint(painter, option, index)



class GPXListWidget(QWidget):
    # Signal, wenn der Nutzer im Pause-Modus in der Tabelle auf eine Zeile klickt
    rowClickedInPause = Signal(int)
    markBSet = Signal(int)          # Signal: B=Index
    markESet = Signal(int)          # Signal: E=Index
    markRangeCleared = Signal()     # Signal: Deselect

    def __init__(self, parent=None):
        super().__init__(parent)
        layout = QVBoxLayout(self)
        
        self._markB_idx = None
        self._markE_idx = None
        
        self.table = QTableWidget(self)
        layout.addWidget(self.table)

        self.table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.table.setSelectionMode(QAbstractItemView.SingleSelection)
        self.table.setColumnCount(9)
        self.table.setHorizontalHeaderLabels([
            "Time(GPX)", "Lat", "Lon", "Step (s)",
            "m", "km/h", "Height", "%Slope", "Mark"
        ])
        header = self.table.horizontalHeader()
        
        
        if platform.system().startswith("Windows"):
            header.setSectionResizeMode(QHeaderView.Stretch)
        elif platform.system().startswith("Darwin"):        
            header.setSectionResizeMode(QHeaderView.ResizeToContents)
        else:
            # Für Linux/sonstige OS ggf. was anderes
            header.setSectionResizeMode(QHeaderView.ResizeToContents)
        
       
        
        font = self.table.font()
        font.setPointSize(9)  # or 8
        self.table.setFont(font)
        self.table.setHorizontalScrollBarPolicy(Qt.ScrollBarAsNeeded)
        self.table.setHorizontalScrollMode(QAbstractItemView.ScrollPerPixel)
        self.table.setSizeAdjustPolicy(QAbstractScrollArea.AdjustToContents)
        
        self.table.verticalHeader().setDefaultSectionSize(24)
       
        self.table.setItemDelegateForColumn(8, MarkColumnDelegate(self.table))

        # B) StyleSheet: Selektierte Zeile blau (auch wenn kein Fokus).
        self.table.setStyleSheet("""
            QTableView::item:selected {
                background-color: #3874f2;  /* Blau */
                color: white;               /* Weißer Text */
            }
            /* optional: bei NoFocus bleibt es sichtbar */
            QTableView {
                selection-background-color: #3874f2;
            }
        """)
        self.table.setFocusPolicy(Qt.StrongFocus)
       
        # Intern
        self._gpx_data = []            # interner Speicher der GPX-Punkte
        self._history_stack = []
        
        self._markB_idx = None
        self._markE_idx = None
        
        self._marked_rows = set()
        
        
        self._gpx_times = []
        self._last_video_row = None
        self._video_is_playing = False

        # Wenn die Auswahl (Selektion) geändert wird
        self.table.itemSelectionChanged.connect(self._on_table_selection_changed)
        
    # ---------------------------------------------------
    # markB markE und Deselect
    # ---------------------------------------------------
   
    def set_markB_row(self, new_b: int):
        if not (0 <= new_b < self.table.rowCount()):
            return

        old_b = self._markB_idx
        old_e = self._markE_idx
        
        if old_e is not None:
            # => E existiert schon => Zeitvergleich
            t_e = self._get_time_of_row(old_e)
            t_b_new = self._get_time_of_row(new_b)
            if t_e and t_b_new:
                if t_b_new > t_e:
                    from PySide6.QtWidgets import QMessageBox
                    QMessageBox.warning(
                        self.table,
                        "Invalid Range",
                        "MarkB cannot be set to a time later than MarkE!"
                    )
                    return


        # FALL A) Gar kein B, kein E => B alleine
        if old_b is None and old_e is None:
            self.clear_marked_range()
            self._markB_idx = new_b
            self._color_mark_cell(new_b, QColor("red"))
            print(f"[DEBUG] set_markB_row => B={new_b} (no E yet)")
            self.markBSet.emit(new_b)
            return

        # FALL B) B=None, E!=None => (theoretisch seltener) => "erstes B"
        # => male range
        if old_b is None and old_e is not None:
            self._markB_idx = new_b
            b_ = min(new_b, old_e)
            e_ = max(new_b, old_e)
            self._mark_range(b_, e_)
            print(f"[DEBUG] set_markB_row => E={old_e}, B={new_b}, range=[{b_}..{e_}]")
            self.markBSet.emit(new_b)
            return

        # FALL C) B war schon gesetzt => SHIFT
        if old_b is not None:
            # (C1) E=None => B -> B
            if old_e is None:
                # => wir ersetzen den alten B
                self._color_mark_cell(old_b, QColor("white"))
                self._markB_idx = new_b
                self._color_mark_cell(new_b, QColor("red"))
                print(f"[DEBUG] set_markB_row => replaced old B={old_b} => new B={new_b} (E=None)")
                self.markBSet.emit(new_b)
                return

            # (C2) E existiert => SHIFT range
            b_old = min(old_b, old_e)
            e_old = max(old_b, old_e)
            self._unmark_range(b_old, e_old)

            self._markB_idx = new_b
            b_new = min(new_b, old_e)
            e_new = max(new_b, old_e)
            self._mark_range(b_new, e_new)
            print(f"[DEBUG] set_markB_row => shift range old=[{b_old}..{e_old}], new=[{b_new}..{e_new}]")
            self.markBSet.emit(new_b)
            return

    
    
   
    def set_markE_row(self, new_e: int):
        """
        Setzt den MarkE-Index auf new_e. 
        Falls MarkB noch nicht gesetzt wurde, haben wir nur E allein.
        Falls B schon gesetzt ist => färbe den Bereich B..E rot.
        Falls E schon existiert => SHIFT.
        """
        if not (0 <= new_e < self.table.rowCount()):
            return

        old_b = self._markB_idx
        old_e = self._markE_idx
        
        if old_b is not None:
            # => B existiert schon => Zeitvergleich
            t_b = self._get_time_of_row(old_b)
            t_e_new = self._get_time_of_row(new_e)
            if t_b and t_e_new:
                if t_e_new < t_b:
                    # => MarkE liegt vor MarkB => Verboten
                    from PySide6.QtWidgets import QMessageBox
                    QMessageBox.warning(
                        self.table,  # parent widget
                        "Invalid Range",
                        "MarkE cannot be set to a time earlier than MarkB!"
                    )
                    return  # Abbruch
        

        # ============== FALL A) Noch gar kein E, kein B => E alleine ==============
        if old_e is None and old_b is None:
            # E "erstmalig" ohne B
            self.clear_marked_range()  # Sicherheit: alles weg
            self._markE_idx = new_e
            self._color_mark_cell(new_e, QColor("red"))  # E allein = rote Zelle
            print(f"[DEBUG] set_markE_row => E={new_e} (only E set, no B yet)")
            self.markESet.emit(new_e)
            return

        # ============== FALL B) E war noch None, aber B ist schon da => range ==============
        if old_e is None and old_b is not None:
            # => wir haben B, aber noch keinen E => nun E = new_e => male B..E
            self._markE_idx = new_e
    
            b_ = min(old_b, new_e)
            e_ = max(old_b, new_e)
            self._mark_range(b_, e_)
            print(f"[DEBUG] set_markE_row => B={old_b}, E={new_e}, range=[{b_}..{e_}]")
            self.markESet.emit(new_e)
            return

        # ============== FALL C) E war schon gesetzt => SHIFT ==============
        # Wir hatten old_e != None
        if old_e is not None:
            # (C1) Falls B=None aber E!=None => wir ersetzen den alten E
            if old_b is None:
                # => wir hatten E allein, jetzt kommt "neuer" E => 
                # => Farbe in alter E-Zelle zurücksetzen
                self._color_mark_cell(old_e, QColor("white"))
                # => neue E
                self._markE_idx = new_e
                self._color_mark_cell(new_e, QColor("red"))
                self.markESet.emit(new_e)
                print(f"[DEBUG] set_markE_row => replaced old E={old_e} with new E={new_e}, B=None")
                return
    
            # (C2) B und E existieren => SHIFT
            b_old = min(old_b, old_e)
            e_old = max(old_b, old_e)
            # altes Intervall ENT-marken
            self._unmark_range(b_old, e_old)
    
            # E => new_e
            self._markE_idx = new_e
    
            b_new = min(old_b, new_e)
            e_new = max(old_b, new_e)
            self._mark_range(b_new, e_new)
            print(f"[DEBUG] set_markE_row => old=[{b_old}..{e_old}], new=[{b_new}..{e_new}]")
            self.markESet.emit(new_e)
            return
    
    
    
    # ---------------------------------------------------------
    # Deselect
    # ---------------------------------------------------------
    def clear_marked_range(self):
        """
        Entfernt jegliche Markierung von B..E
        """
        if self._markB_idx is None and self._markE_idx is None:
            return
        if self._markB_idx is not None and self._markE_idx is not None:
            b = min(self._markB_idx, self._markE_idx)
            e = max(self._markB_idx, self._markE_idx)
            self._unmark_range(b, e)
        elif self._markB_idx is not None:
            # Falls nur B existiert
            self._color_mark_cell(self._markB_idx, QColor("white"))
        
        self._markB_idx = None
        self._markE_idx = None
        print("[DEBUG] clear_marked_range => done")
        self.markRangeCleared.emit()

    # ---------------------------------------------------------
    # Helper-Funktionen
    # ---------------------------------------------------------
    def _mark_range(self, row_start: int, row_end: int):
        """
        Färbt Zeilen row_start..row_end (Spalte 8) rot
        """
        for r in range(row_start, row_end+1):
            self._color_mark_cell(r, QColor("red"))

    def _unmark_range(self, row_start: int, row_end: int):
        """
        Färbt Zeilen row_start..row_end (Spalte 8) wieder weiß
        """
        for r in range(row_start, row_end+1):
            self._color_mark_cell(r, QColor("white"))
        
    
    
    def _color_mark_cell(self, row: int, color: QColor):
        col_mark = 8
        item = self.table.item(row, col_mark)
        if not item:
            item = QTableWidgetItem("")
            self.table.setItem(row, col_mark, item)
        item.setBackground(color)
        
    def _mark_row_bg_except_markcol(self, row: int, color):
        """
        Färbt Spalten 0..7 von `row` in `color`,
        ohne Spalte 8 (Mark) zu verändern.
        """
        col_count = self.table.columnCount()  # meist 9
        for col in range(col_count):
            if col == 8:
                continue  # Spalte 8 bleibt, wie sie ist (rot/weiß)
            item = self.table.item(row, col)
            if not item:
                item = QTableWidgetItem("")
                self.table.setItem(row, col, item)
            item.setBackground(color)
    
        

    # ---------------------------------------------------
    # 1) Play/Pause
    # ---------------------------------------------------
    def set_video_playing(self, playing: bool):
        """
        Wird vom MainWindow aufgerufen, wenn wir auf Play oder Pause wechseln.
        """
        if playing:
            # Beim Umschalten auf Play -> vorhandene manuelle Auswahl entfernen
            self.table.blockSignals(True)
            self.table.clearSelection()
            self.table.blockSignals(False)
        self._video_is_playing = playing

    # ---------------------------------------------------
    # 2) Live-Aktualisierung (Video läuft)
    # ---------------------------------------------------
    def highlight_video_time(self, current_s: float, is_playing: bool):
        """
        Wird periodisch aufgerufen, wenn das Video läuft (oder 
        wenn man per Zeit-Set gehen will),
        damit die "beste" Zeile (in Spalten 0..7) gelb wird,
        ohne Spalte 8 (Mark) zu überschreiben.
        """
        self._video_is_playing = is_playing

        # Alte gelbe Zeile (Spalten 0..7) ggf. weiß
        if self._last_video_row is not None:
            self._mark_row_bg_except_markcol(self._last_video_row, Qt.white)

        if not self._gpx_times:
            return

        # Index mit minimaler Zeitdifferenz
        best_idx = self.get_closest_index_for_time(current_s)

        # Neue Markierung (Spalten 0..7 = gelb)
        self._mark_row_bg_except_markcol(best_idx, Qt.yellow)
        self._last_video_row = best_idx

        # Scroll-Logik
        
        item = self.table.item(best_idx, 0)
        if not item:
            return

        viewport_rect = self.table.viewport().rect()
        if is_playing:
            row_scroll = min(best_idx + 2, self.table.rowCount() - 1)
            item2 = self.table.item(row_scroll, 0)
            if item2:
                item2_rect = self.table.visualItemRect(item2)
                if not viewport_rect.contains(item2_rect):
                    self.table.scrollToItem(item2, QAbstractItemView.PositionAtBottom)
        else:
            item_rect = self.table.visualItemRect(item)
            if not viewport_rect.contains(item_rect):
                self.table.scrollToItem(item, QAbstractItemView.PositionAtCenter)

    # ---------------------------------------------------
    # 3) Manuelles Klicken im Pause-Modus
    # ---------------------------------------------------
    def _on_table_selection_changed(self):
        """
        Wird aufgerufen, wenn der Nutzer eine Zeile in der Tabelle anklickt
        (im Pause-Modus). Wir wollen verhindern, dass ein bereits
        rot markierter Bereich in Spalte 8 (B..E) zurückgesetzt wird.

        - Falls _video_is_playing => Abbruch
        - Alte gelbe Zeile (0..7) ggf. auf weiß => ABER Spalte 8 bleibt rot falls B..E
        - Neue Zeile (0..7) wird gelb
        - Signal rowClickedInPause(new_idx) => damit MainWindow synchron agieren kann
        """
        if self._video_is_playing:
            return

        selected = self.table.selectionModel().selectedRows()
        if not selected:
            return

        new_idx = selected[0].row()

        # 1) Alte Zeile 0..7 -> zurück auf weiß (nur, wenn sie nicht in B..E liegt)
        if self._last_video_row is not None and self._last_video_row != new_idx:
            # Prüfen, ob _last_video_row in B..E
            if self._markB_idx is not None and self._markE_idx is not None:
                b = min(self._markB_idx, self._markE_idx)
                e = max(self._markB_idx, self._markE_idx)
                if b <= self._last_video_row <= e:
                    # => NICHT Spalte 8 ändern, NICHT 0..7 "komplett" weißfärben?
                    # Wir wollen aber evtl. 0..7 trotzdem auf weiß, 
                    # damit nicht 2 Zeilen gelb sind.
                    # => Wir nehmen die Hilfsmethode => except Mark:
                    self._mark_row_bg_except_markcol(self._last_video_row, Qt.white)
                else:
                    # alter Punkt außerhalb B..E => normal auf weiß
                    self._mark_row_bg_except_markcol(self._last_video_row, Qt.white)
            else:
                # kein B..E => normal
                self._mark_row_bg_except_markcol(self._last_video_row, Qt.white)

        # 2) Neue Zeile 0..7 => gelb
        self._mark_row_bg_except_markcol(new_idx, Qt.yellow)
        self._last_video_row = new_idx

        # 3) Jetzt erst das Signal -> MainWindow
        self.rowClickedInPause.emit(new_idx)

    def select_row_in_pause(self, row_idx: int):
        if self._video_is_playing:
            return
        if not (0 <= row_idx < self.table.rowCount()):
            return

        self.table.blockSignals(True)

        # Falls es eine alte gelbe Zeile gibt
        if self._last_video_row is not None and self._last_video_row != row_idx:
            # => 0..7 auf weiß
            self._mark_row_bg_except_markcol(self._last_video_row, Qt.white)

        # Neue Zeile 0..7 => gelb
        self._mark_row_bg_except_markcol(row_idx, Qt.yellow)
        self._last_video_row = row_idx

        # Offiziell selektieren
        self.table.setCurrentCell(row_idx, 0)
        self.table.selectRow(row_idx)

        self.table.blockSignals(False)
 

    def delete_selected_range(self):
        """
        Löscht [markB..markE], 
        setzt Zeitlücke = 1s,
        ruft recalc_gpx_data,
        und updatet Table => set_gpx_data.
        Danach entfernen wir die betroffenen Punkte auch aus der Karte,
        indem wir 'remove_point_on_map(stable_id)' aufrufen (NEU).
        """
        if self._markB_idx is None:
            print("[DEBUG] Nichts markiert, Abbruch.")
            return
    
        b = self._markB_idx
        e = self._markE_idx
        if e is None:
            e = b
        if b > e:
            b, e = e, b
    
        # Grenzen checken
        if b < 0 or b >= len(self._gpx_data):
            print("[DEBUG] B ausserhalb => Abbruch.")
            return
        if e < 0:
            e = 0
        if e >= len(self._gpx_data):
            e = len(self._gpx_data) - 1
    
        print(f"[DEBUG] DELETE => b={b}, e={e}")
        
        # 1) Undo-Snapshot
        import copy
        old_data = copy.deepcopy(self._gpx_data)
        self._history_stack.append(old_data)
    
        # (NEU) 1b) Wir merken uns die stable_ids der zu löschenden Punkte:
        to_remove_ids = []
        for i in range(b, e+1):
            if "stable_id" in self._gpx_data[i]:
                to_remove_ids.append(self._gpx_data[i]["stable_id"])
    
        # 2) Entfernen
        del self._gpx_data[b:e+1]
    
        # 3) Zeitlücke = 1 Sek
        if b > 0 and b < len(self._gpx_data):
            time_before = self._gpx_data[b-1]["time"]
            time_after  = self._gpx_data[b]["time"]
            old_gap = (time_after - time_before).total_seconds()
            shift = old_gap - 1.0
            if shift > 0:
                from datetime import timedelta
                for i in range(b, len(self._gpx_data)):
                    self._gpx_data[i]["time"] = self._gpx_data[i]["time"] - timedelta(seconds=shift)
            print(f"[DEBUG] SHIFT={shift:.3f}s, old_gap={old_gap:.3f}s")

        # 4) Neu berechnen
        from core.gpx_parser import recalc_gpx_data
        recalc_gpx_data(self._gpx_data)
    
        # 5) Tabelle updaten
        self.set_gpx_data(self._gpx_data)
    
        # 6) Markierung entfernen
        self.clear_marked_range()
        print("[DEBUG] delete_selected_range => fertig.")
    
        # (NEU) 7) Map partial update => remove
        mw = self._get_mainwindow()  # (NEU) => MainWindow holen
        if mw is not None:
            for sid in to_remove_ids:
                if sid:
                    mw.remove_point_on_map(sid)  # ruft JS 'removePoint' auf
    
        
   
    
    

    def undo_delete(self):
        """
        Stellt den letzten Zustand wieder her,
        ruft recalc und set_gpx_data.
        """
        if not self._history_stack:
            print("[DEBUG] Undo: Nichts mehr im Stack.")
            return

        import copy
        old_data = self._history_stack.pop()
        self._gpx_data = old_data

        # recalc (zur Sicherheit, 
        #  falls wir den alten Zustand modifiziert hatten)
        from core.gpx_parser import recalc_gpx_data
        recalc_gpx_data(self._gpx_data)

        self.set_gpx_data(self._gpx_data)
        self.clear_marked_range()
        print("[DEBUG] undo_delete => fertig.")

        
        
    
    


    # ---------------------------------------------------
    # 4) GPX-Daten
    # ---------------------------------------------------
    def set_gpx_data(self, data):
        self._gpx_data = data
        
        n = len(data)
        self.table.setRowCount(n)
        self._gpx_times = [0.0]*n
        self._last_video_row = None

        if n == 0:
            return

        base_dt = data[0].get("time", None)
        base_ts = base_dt.timestamp() if base_dt else None
        prev_dt = None

        for row_idx, pt in enumerate(data):
            dt = pt.get("time", None)
            if dt and base_ts is not None:
                rel_s = dt.timestamp() - base_ts
                if rel_s < 0:
                    rel_s = 0.0
            else:
                rel_s = 0.0

            self._gpx_times[row_idx] = rel_s

            time_str = self._format_hhmmss_milli(rel_s)
            self._set_cell(row_idx, 0, time_str)

            lat_val = pt.get("lat", 0.0)
            lon_val = pt.get("lon", 0.0)
            self._set_cell(row_idx, 1, f"{lat_val:.6f}")
            self._set_cell(row_idx, 2, f"{lon_val:.6f}")

            if row_idx == 0 or not dt or not prev_dt:
                step_s = 0.0
            else:
                diff_s = (dt - prev_dt).total_seconds()
                step_s = diff_s if diff_s > 0 else 0.0
            self._set_cell(row_idx, 3, f"{step_s:.3f}")
            prev_dt = dt

            dist_val = pt.get("delta_m", 0.0)
            self._set_cell(row_idx, 4, f"{dist_val:.2f}")
            spd_val = pt.get("speed_kmh", 0.0)
            self._set_cell(row_idx, 5, f"{spd_val:.2f}")
            ele_val = pt.get("ele", 0.0)
            self._set_cell(row_idx, 6, f"{ele_val:.2f}")
            grd_val = pt.get("gradient", 0.0)
            self._set_cell(row_idx, 7, f"{grd_val:.1f}")
            self._set_cell(row_idx, 8, "")

    # ---------------------------------------------------
    # 5) get_closest_index_for_time
    # ---------------------------------------------------
    def get_closest_index_for_time(self, current_s: float) -> int:
        """
        Sucht in self._gpx_times den Index mit minimaler Differenz zu current_s.
        """
        if not self._gpx_times:
            return 0
        best_idx = 0
        best_diff = abs(self._gpx_times[0] - current_s)
        for i, val in enumerate(self._gpx_times):
            diff = abs(val - current_s)
            if diff < best_diff:
                best_diff = diff
                best_idx = i
        return best_idx

    # ---------------------------------------------------
    # 6) Hilfsfunktionen (Zeilen-Markierung, Format, usw.)
    # ---------------------------------------------------
    def _mark_row_bg(self, row_index, color):
        for col in range(self.table.columnCount()):
            it = self.table.item(row_index, col)
            if it:
                it.setBackground(color)

    def _format_hhmmss_milli(self, secs: float) -> str:
        ms_total = int(round(secs * 1000))
        hh = ms_total // 3600000
        rest = ms_total % 3600000
        mm = rest // 60000
        rest = rest % 60000
        ss = rest // 1000
        ms = rest % 1000
        return f"{hh:02d}:{mm:02d}:{ss:02d}.{ms:03d}"

    def _set_cell(self, row, col, text):
        item = QTableWidgetItem(text)
        flags = item.flags()
        flags &= ~Qt.ItemIsEditable
        item.setFlags(flags)
        self.table.setItem(row, col, item)

    def _get_mainwindow(self):
        """
        Durchwandert die Eltern-Widgets, bis das MainWindow gefunden wird.
        Voraussetzung: GPXListWidget wird im MainWindow verschachtelt.
        """
        w = self.parentWidget()
        while w is not None:
            # Prüfen auf Typ oder ob es z. B. mainwindow-Attribut besitzt
            if hasattr(w, "remove_point_on_map") and hasattr(w, "add_or_update_point_on_map"):
                # => wir gehen davon aus, dass das unser MainWindow ist
                return w
            w = w.parentWidget()
        return None
        
    def _get_time_of_row(self, row_idx: int):
        """
        Gibt das Python-datetime-Objekt zurück, das zu row_idx gehört.
        Falls row_idx ungültig ist, None.
        """
        if not self._gpx_data or row_idx < 0 or row_idx >= len(self._gpx_data):
            return None
        return self._gpx_data[row_idx].get("time", None)    
```
# widgets/gpx_widget.py

from PySide6.QtWidgets import QWidget, QVBoxLayout
from .gpx_list_widget import GPXListWidget

class GPXWidget(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        layout = QVBoxLayout(self)
        self.gpx_list = GPXListWidget(self)
        layout.addWidget(self.gpx_list)

    def set_gpx_data(self, data):
        self.gpx_list.set_gpx_data(data)

    def highlight_video_time(self, current_s: float, is_playing: bool):
        self.gpx_list.highlight_video_time(current_s, is_playing)

    def get_closest_index_for_time(self, current_s: float) -> int:
        return self.gpx_list.get_closest_index_for_time(current_s)
        
    def set_video_playing(self, playing: bool):
        """ Delegiert an die Methode der gpx_list. """
        self.gpx_list.set_video_playing(playing)    

    def set_flag(self, index: int, color: str, size: int, label_text: str):
        """
        Weist JavaScript an, ein Flag an Punkt 'index' zu setzen,
        z.B. mit bestimmter Farbe und Label (B/E).
        """
        js_code = (
            f"setFlag({index}, '{color}', {size}, '{label_text}')"
        )
        self.view.page().runJavaScript(js_code)
        
    def remove_all_flags(self):
        """
        Weist JavaScript an, alle Flag-Icons zu entfernen.
        """
        js_code = "removeAllFlags();"
        self.view.page().runJavaScript(js_code)    
```
# widgets/map_bridge.py

from PySide6.QtCore import QObject, Signal, Slot

class MapBridge(QObject):
    pointClickedSignal = Signal(int)
    pointMovedSignal = Signal(int, float, float)
    syncClickedSignal = Signal(int)  # <-- Neu
    syncClickedNoArg = Signal()   # <-- Neue Signal-Variante ohne Parameter
    newPointInsertedSignal = Signal(float, float, int)
    
        
    def __init__(self, parent=None):
        super().__init__(parent)
        
    @Slot(str)
    def jsLog(self, text):
        """
        Wird von JavaScript via channelObj.jsLog("...") aufgerufen.
        => Gibt 'text' im Python-Terminal aus.
        """
        print(f"[JS->Py] {text}")    
    

    @Slot(int)
    def pointClicked(self, index):
        self.pointClickedSignal.emit(index)
    
    @Slot(int, float, float)
    def pointMoved(self, index, lat, lon):
        """
        Wird von JavaScript aufgerufen, wenn ein Feature (Point)
        in der Karte verschoben wurde.
        index: int => id des Punktes
        lat, lon: float => neue Koordinaten
        """
        print(f"[DEBUG] pointMoved => index={index}, lat={lat:.6f}, lon={lon:.6f}")
        # => Jetzt weitergeben an Python-Logik, z.B. über ein Signal:
        self.pointMovedSignal.emit(index, lat, lon)
        # ... oder direkt an self.parent().onPointMoved(index, lat, lon) ...
        
    @Slot(int)
    def syncClicked(self, idx):
        self.syncClickedSignal.emit(idx)   # <-- NEU    
        
    @Slot()
    def syncNoArgSlot(self):
        """
        Diese Slot-Methode kann JS aufrufen: channelObj.syncNoArgSlot()
        => wir lösen damit das Signal syncClickedNoArg in Python aus.
        """
        self.syncClickedNoArg.emit()
        # (Optional: Hier kannst du auch print("JS rief syncNoArgSlot auf!") machen)    
        
    
    @Slot(float, float, int)
    def newPointInserted(self, lat, lon, idx):
        """
        Diese Methode wird von JS via channelObj.newPointInserted(...) aufgerufen.
        """
        print(f"[Py Debug] => newPointInserted => lat={lat}, lon={lon}, idx={idx}")
        # Weitergeben an MainWindow oder sonstige Logik:
        self.newPointInsertedSignal.emit(lat, lon, idx)
    
```
import os
import sys
import json
from PySide6.QtWidgets import QWidget, QVBoxLayout
from PySide6.QtCore import QUrl, Signal, Slot
from PySide6.QtWebEngineWidgets import QWebEngineView
from PySide6.QtWebEngineCore import QWebEngineSettings
from PySide6.QtWebChannel import QWebChannel

from .map_bridge import MapBridge

class MapWidget(QWidget):
    """
    Neue Version: 2 Zustände => gelb (Video Play), blau (Pause-Klick).
    """
    # Signale
    pointClickedInPause = Signal(int)
    pointClickedInMap   = Signal(int)  # optional fürs MainWindow

    def __init__(self, mainwindow=None, parent=None):
        super().__init__(parent)
        self._mainwindow = mainwindow

        # Zustands-Variablen
        self._video_is_playing = False
        self._yellow_idx = None
        self._blue_idx   = None
        self._num_points = 0
        self._markB_idx  = None
        self._markE_idx  = None

        # Layout + QWebEngineView
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)

        self.view = QWebEngineView(self)
        layout.addWidget(self.view)

        # Erlaubt: Remote URLs / z.B. OSM, MapTiler, Mapbox, Bing
        self.view.settings().setAttribute(
            QWebEngineSettings.LocalContentCanAccessRemoteUrls, True
        )

        # WebChannel + Bridge
        self._bridge = MapBridge()
        self._bridge.pointClickedSignal.connect(self.onMapPointClicked)

        self._channel = QWebChannel()
        self._channel.registerObject("mapBridge", self._bridge)
        self.view.page().setWebChannel(self._channel)

        # map_page.html laden
        base_dir = os.path.dirname(os.path.abspath(sys.argv[0]))
        html_path = os.path.join(base_dir, "map_page.html")
        self.view.load(QUrl.fromLocalFile(html_path))

        # Callback, wenn HTML fertig geladen ist
        self.view.loadFinished.connect(self._on_map_page_load_finished)

        # Weitere Bridge-Signale
        self._bridge.pointMovedSignal.connect(self.on_point_moved)
        self._bridge.syncClickedNoArg.connect(self._on_sync_noarg_from_js)
        self._bridge.newPointInsertedSignal.connect(self._on_new_point_inserted)

    @Slot(bool)
    def _on_map_page_load_finished(self, ok):
        """
        Wird aufgerufen, sobald map_page.html fertig geladen ist.
        Früher wurde hier der MapTiler-Key geladen,
        das macht jetzt aber NUR noch MainWindow (und sendet per JS).
        """
        if not ok:
            print("[WARN] Karte konnte nicht geladen werden.")
            return

        print("[DEBUG] Karte ist geladen ⇒ wende jetzt ggf. QSettings-Einstellungen an.")
        # Beispiel: Du könntest hier nur noch "apply map-sizes" o. Ä. aufrufen.
        # Falls du eine Funktion in MainWindow hast, z. B. _apply_map_sizes_from_settings():
        if self._mainwindow and hasattr(self._mainwindow, "_apply_map_sizes_from_settings"):
            self._mainwindow._apply_map_sizes_from_settings()

    @Slot(float, float, int)
    def _on_new_point_inserted(self, lat, lon, idx):
        """
        Ruft MainWindow.on_new_gpx_point_inserted(...) auf,
        falls vorhanden. So kann das GPX-Handling fortgesetzt werden.
        """
        if self._mainwindow and hasattr(self._mainwindow, "on_new_gpx_point_inserted"):
            self._mainwindow.on_new_gpx_point_inserted(lat, lon, idx)

    @Slot()
    def _on_sync_noarg_from_js(self):
        """
        JS => channelObj.syncClickedNoArg() => rufe mainwindow.on_map_sync_any().
        """
        if self._mainwindow and hasattr(self._mainwindow, "on_map_sync_any"):
            self._mainwindow.on_map_sync_any()

    def on_point_moved(self, index: int, lat: float, lon: float):
        """
        Wird gerufen, wenn man im Browser (Karte) einen Punkt draggt.
        Reicht an MainWindow weiter, falls on_point_moved existiert.
        """
        if self._mainwindow and hasattr(self._mainwindow, "on_point_moved"):
            self._mainwindow.on_point_moved(index, lat, lon)

    def loadRoute(self, route_geojson: dict, do_fit: bool = True):
        """
        Ruft loadRoute(...) in JS auf, um ein GeoJSON in der Karte darzustellen.
        """
        if not route_geojson or not isinstance(route_geojson, dict):
            return

        # Anzahl Points ermitteln
        features = route_geojson.get("features", [])
        self._num_points = sum(
            1 for feat in features
            if feat.get("geometry", {}).get("type") == "Point"
        )

        
        do_fit_str = "true" if do_fit else "false"
        js = f"loadRoute({json.dumps(route_geojson)}, {do_fit_str});"
        self.view.page().runJavaScript(js)

    # ----------------------------------------------------------
    # Markierungen B/E
    # ----------------------------------------------------------
    def set_markB_idx(self, b_idx: int):
        self._markB_idx = b_idx

    def set_markE_idx(self, e_idx: int):
        self._markE_idx = e_idx

    def set_markB_point(self, new_b: int):
        if new_b < 0:
            return
        self._markB_idx = new_b
        js_code = f"set_markB_point({new_b});"
        self.view.page().runJavaScript(js_code)

    def set_markE_point(self, new_e: int):
        if new_e < 0:
            return
        js_code = f"set_markE_point({new_e});"
        self.view.page().runJavaScript(js_code)

    def clear_marked_range(self):
        js_code = "clear_marked_range();"
        self.view.page().runJavaScript(js_code)

    # ----------------------------------------------------------
    # Play/Pause -> Video
    # ----------------------------------------------------------
    def set_video_playing(self, playing: bool):
        """
        Wird vom MainWindow aufgerufen, wenn Play/Pause umgeschaltet wird.
        """
        self._video_is_playing = playing
        js_bool = "true" if playing else "false"
        self.view.page().runJavaScript(f"setVideoPlayState({js_bool})")

        if playing:
            # alten blauen Marker entfernen
            if self._blue_idx is not None:
                self._color_point(self._blue_idx, "#000000", size=4)
                self._blue_idx = None
        else:
            # Bei Pause belassen wir ggf. den gelben Marker
            pass

    # ----------------------------------------------------------
    # Klick in der Karte => onMapPointClicked
    # ----------------------------------------------------------
    @Slot(int)
    def onMapPointClicked(self, index_clicked: int):
        """
        Wenn das Video pausiert, machen wir 'show_blue'.
        Danach benachrichtigen wir MainWindow, dass index_clicked geklickt wurde.
        """
        if self._video_is_playing:
            return
        self.show_blue(index_clicked)

        if self._mainwindow and hasattr(self._mainwindow, "on_user_selected_index"):
            self._mainwindow.on_user_selected_index(index_clicked)

    # ----------------------------------------------------------
    # Hilfsfunktion: JS highlightPoint(...)
    # ----------------------------------------------------------
    def _color_point(self, index: int, color: str, size: int=4, do_center: bool=False):
        """
        Intern: Ruft highlightPoint(index, color, size, do_center) in JS auf.
        """
        js_code = (
            f"highlightPoint({index}, '{color}', {size}, {str(do_center).lower()});"
        )
        self.view.page().runJavaScript(js_code)

    # ----------------------------------------------------------
    # show_blue / show_yellow
    # ----------------------------------------------------------
    def show_blue(self, index: int, do_center: bool=False):
        """
        Marker blau bei Pause-Klick.
        """
        if index < 0 or index >= self._num_points:
            return

        # Alten blauen Marker revert
        if self._blue_idx is not None and self._blue_idx != index:
            old_b = self._blue_idx
            color_old = self.get_default_color_for_index(old_b)
            self._color_point(old_b, color_old, size=4, do_center=False)
            self._blue_idx = None

        # Gelben Marker (wenn existiert) revert
        if self._yellow_idx is not None:
            old_y = self._yellow_idx
            color_old_y = self.get_default_color_for_index(old_y)
            self._color_point(old_y, color_old_y, size=4, do_center=False)
            self._yellow_idx = None

        # Jetzt den neuen Index blau
        self._blue_idx = index
        self._color_point(index, "#0000FF", size=6, do_center=do_center)

    def show_yellow(self, index: int, do_center: bool=False):
        """
        Marker gelb beim Video-Playback.
        """
        if index == self._yellow_idx:
            return
        if index < 0 or index >= self._num_points:
            return

        # alten gelben Marker revert
        if self._yellow_idx is not None:
            old_y = self._yellow_idx
            color_old = self.get_default_color_for_index(old_y)
            self._color_point(old_y, color_old, size=4, do_center=False)
            self._yellow_idx = None

        # Falls dieser Index blau war => revert
        if self._blue_idx == index:
            color_old_b = self.get_default_color_for_index(index)
            self._color_point(index, color_old_b, size=4, do_center=False)
            self._blue_idx = None

        # Neuer Index => gelb
        self._yellow_idx = index
        self._color_point(index, "#FFFF00", size=6, do_center=do_center)

    # ----------------------------------------------------------
    # Farblogik (rot bei MarkB..MarkE, sonst schwarz)
    # ----------------------------------------------------------
    def is_in_marked_range(self, idx: int) -> bool:
        if self._markB_idx is not None and self._markE_idx is not None:
            b = min(self._markB_idx, self._markE_idx)
            e = max(self._markB_idx, self._markE_idx)
            return (b <= idx <= e)
        elif self._markB_idx is not None:
            return (idx == self._markB_idx)
        elif self._markE_idx is not None:
            return (idx == self._markE_idx)
        else:
            return False

    def get_default_color_for_index(self, i: int) -> str:
        """
        - '#FF0000' (rot) in B..E
        - '#000000' sonst
        """
        if i < 0 or i >= self._num_points:
            return "#000000"

        if self._markB_idx is not None and self._markE_idx is not None:
            b = min(self._markB_idx, self._markE_idx)
            e = max(self._markB_idx, self._markE_idx)
            if b <= i <= e:
                return "#FF0000"
        elif self._markB_idx is not None:
            if i == self._markB_idx:
                return "#FF0000"
        elif self._markE_idx is not None:
            if i == self._markE_idx:
                return "#FF0000"

        return "#000000"

```
# widgets/mini_chart_widget.py

from PySide6.QtWidgets import QWidget
from PySide6.QtCore import Qt, QRect
from PySide6.QtGui import QPainter, QPen, QBrush, QColor, QFont

class MiniChartWidget(QWidget):
    """
    Zeigt eine Mini-Chart von maximal 30 GPX-Punkten.
    Hat einen festen Marker bei ca. 70% (x=0.7 * width).
    'darunter' läuft die Kurve, damit immer der aktuelle GPX-Punkt 
    an dieser Marker-Linie auftaucht. 

    Unten am Marker wird der "Slope" (Steigung) des aktuellen Punkts 
    als Text dargestellt.
    """

    def __init__(self, parent=None):
        super().__init__(parent)
        self.setAutoFillBackground(True)

        # Ggf. Hintergrund wie Timeline => #333333
        self.setStyleSheet("background-color: #444444 ;")

        # Interne Daten
        self._gpx_data = []
        self._max_points = 30   # Standard: 30 Gpx-Punkte anzeigen
        self._marker_ratio_x = 0.7  # 70% vom Widget
        self._current_index = 0     # Welcher Punkt ist 'aktuell'?

        

    def set_max_points(self, num: int):
        """Erlaubt es dir, die max. Anzahl von GPX-Punkten (30) zu ändern."""
        self._max_points = max(1, num)
        self.update()

    def set_gpx_data(self, data: list):
        """
        data: Liste von Dicts, z.B. [{'lat':..., 'lon':..., 'ele':..., 
                                     'speed_kmh':..., 'gradient':..., ...}, ...]
        Wir schneiden uns max. _max_points 'vor' dem aktuellen Index heraus 
        und ein paar 'danach', damit die Kurve "scrollt".
        """
        self._gpx_data = data or []
        self.update()

    def set_current_index(self, idx: int):
        """Setzt den Index des 'aktuellen' GPX-Punkts."""
        if idx < 0:
            idx = 0
        if idx >= len(self._gpx_data):
            idx = len(self._gpx_data) - 1
        self._current_index = idx
        self.update()

    def paintEvent(self, event):
        super().paintEvent(event)
        if not self._gpx_data:
            return

        painter = QPainter(self)
        painter.setRenderHint(QPainter.Antialiasing, True)
        
        painter.fillRect(self.rect(), QColor("#333333"))
        
        rect_ = self.rect()
        w = rect_.width()
        h = rect_.height()

        # 1) Berechne, welche GPX-Punkte wir anzeigen (Fenster um current_index).
        #    z.B. ± 15 Punkte um den aktuellen herum => max 30
        N = len(self._gpx_data)
        if N < 1:
            return

        c_idx = self._current_index
        half_window = self._max_points // 2
        start_i = c_idx - half_window
        end_i   = c_idx + half_window
        if self._max_points % 2 == 0:
            # z.B. 30 => 15 + 15
            end_i -= 1  # damit wir "mittig" sind

        if start_i < 0:
            start_i = 0
        if end_i >= N:
            end_i = N - 1

        # Extrahiere Teilbereich
        relevant_points = self._gpx_data[start_i : end_i+1]
        # Wir tun so, als ob relevant_points[0] => x=0, relevant_points[-1] => x=someMax
        # => "scroll" => damit der aktuelle Index c_idx immer in der Mitte (marker) landet.

        # 2) Koordinatensystem auf x=0..1 => Mapping => dann "schieben wir" so,
        #    dass c_idx bei marker_ratio_x.
        count_window = len(relevant_points)
        if count_window < 2:
            return

        # Index des c_idx in relevant_points:
        local_idx = c_idx - start_i  # z.B. 15
        # => local_idx => welchen Pkt in relevant_points

        # x-Positionen definieren wir in [0..1], 
        # so dass local_idx => x = self._marker_ratio_x
        # => offset_x => local_idx => marker_ratio_x
        # => 1 step => 1/(count_window-1)

        step = 1.0 / max(1, (count_window - 1))
        offset_in_data = local_idx * step  # z.B. 15*0.0333=0.5
        # => Wir wollen offset_in_data im Diagramm auf marker_ratio_x schieben
        shift_x = self._marker_ratio_x - offset_in_data
        # => x_data => (i*step + shift_x)

        # Finde min & max Ele oder Speed oder was du willst.
        # Hier z.B. nimmst du "ele" oder "speed_kmh" oder "gradient".
        # Du sagst, du willst Slope => wir nehmen "gradient".
        grads = [p.get("gradient", 0.0) for p in relevant_points]
        min_val = min(grads)
        max_val = max(grads)
        if abs(max_val - min_val) < 0.001:
            # Verhindert Division by zero
            max_val += 0.1
            min_val -= 0.1

        # X->Pixel: x_pixel = (x_data)*w
        # Y->Pixel => wir zeichnen => Y=0 oben => wir drehen es => 0 => h, max => 0
        # => y_pixel = h - ( (val - min_val)/(max_val-min_val) * (h-20) ) - 10
        # so haben wir 10px oben/unten

        pts_screen = []
        for i, p in enumerate(relevant_points):
            x_data = i*step + shift_x
            val = p.get("gradient", 0.0)
            frac = (val - min_val) / (max_val - min_val)
            y_ = (h-20)*frac
            y_pix = (h - 10) - y_
            x_pix = x_data * w
            pts_screen.append((x_pix, y_pix))
            
        ###
        painter.setPen(Qt.NoPen)           # kein Rand
        painter.setBrush(QColor("#cccccc"))  # z. B. ein graues "fill"

        for (xx, yy) in pts_screen:
            # z. B. einen kleinen Kreis radius=3
            painter.drawEllipse(int(xx)-1, int(yy)-1, 4, 4)
            # original: painter.drawEllipse(int(xx)-3, int(yy)-3, 6, 6)

        ###

        # 3) Pfad zeichnen
        pen_line = QPen(QColor("#00cccc"), 2)  # z.B. cyan
        painter.setPen(pen_line)
        for i in range(len(pts_screen)-1):
            (x1, y1) = pts_screen[i]
            (x2, y2) = pts_screen[i+1]
            painter.drawLine(x1, y1, x2, y2)

        # 4) Den festen Marker bei x_marker = marker_ratio_x * w
        x_marker = int(self._marker_ratio_x * w)
        pen_marker = QPen(QColor("white"), 2)
        painter.setPen(pen_marker)
        painter.drawLine(x_marker, 0, x_marker, h)

        # 5) Aktueller Punkt => in relevant_points => local_idx. 
        # => screen-Koordinate:
        if 0 <= local_idx < len(pts_screen):
            xP, yP = pts_screen[local_idx]
            # Kleiner Kreis
            painter.setBrush(QColor("#ffff00"))  # gelb
            painter.drawEllipse(int(xP)-3, int(yP)-3, 6, 6)

            # Slope (gradient):
            slope_val = relevant_points[local_idx].get("gradient", 0.0)
            # Unten am Marker => Text
            slope_str = f"{slope_val:.1f}%"
            #slope_str = f"Slope: {slope_val:.1f}%"

            painter.setPen(QColor("#ffffff"))
            font_ = QFont()
            font_.setPointSize(10)
            painter.setFont(font_)

            text_w = painter.fontMetrics().horizontalAdvance(slope_str)
            # -> Mitte am Marker X => wir schieben Text bisschen nach unten:
            painter.drawText(x_marker - text_w//2, h - 5, slope_str)
        # Ende paintEvent

```
# widgets/video_control_widget.py

from PySide6.QtWidgets import (
    QWidget, QHBoxLayout, QPushButton, QLineEdit, QLabel,
    QStyle, QDialog, QVBoxLayout, QFrame
)
from PySide6.QtCore import Signal, Qt, QRegularExpression
from PySide6.QtGui import QRegularExpressionValidator, QCursor



class VideoControlWidget(QWidget):
    play_pause_clicked       = Signal()
    stop_clicked             = Signal()
    step_value_changed       = Signal(str)
    multiplier_value_changed = Signal(str)
    backward_clicked         = Signal()
    forward_clicked          = Signal()
    goToEndClicked           = Signal()
    timeHMSSetClicked        = Signal(int, int, int)
    markBClicked             = Signal()
    markEClicked             = Signal()
    cutClicked               = Signal()
    undoClicked              = Signal()
    markClearClicked         = Signal()
    safeClicked              = Signal()
    syncClicked              = Signal()
    set_beginClicked         = Signal()  

    def __init__(self, parent=None):
        super().__init__(parent)
        layout = QHBoxLayout(self)
        layout.setContentsMargins(5,5,5,5)
        layout.setSpacing(5)

        self.play_pause_button = QPushButton()
        self.play_pause_button.setIcon(
            self.style().standardIcon(QStyle.SP_MediaPlay)
        )
        self.play_pause_button.clicked.connect(self.play_pause_clicked.emit)
        layout.addWidget(self.play_pause_button)

        self.stop_button = QPushButton()
        self.stop_button.setIcon(
            self.style().standardIcon(QStyle.SP_MediaStop)
        )
        self.stop_button.clicked.connect(self.stop_clicked.emit)
        layout.addWidget(self.stop_button)
        
        
        self._step_values = ["s", "m", "k", "f"]  # <-- "f" ergänzt
        self._step_index = 0
        self.step_button = QPushButton(self._step_values[self._step_index])
        self.step_button.setToolTip("Choose the Step-Value")
        self.step_button.setFixedSize(40, 24)
        self.step_button.clicked.connect(self.on_step_button_clicked)
        layout.addWidget(self.step_button)

        self._multiplier_values = ["1x", "2x", "4x", "8x", "15x", "30x"]
        self._multiplier_index = 0
        self.multiplier_button = QPushButton(self._multiplier_values[self._multiplier_index])
        self.multiplier_button.setToolTip("Choose the Multiplier of the Stepper")
        self.multiplier_button.setFixedSize(40, 24)
        self.multiplier_button.clicked.connect(self.on_multiplier_button_clicked)
        layout.addWidget(self.multiplier_button)

        self.backward_button = QPushButton()
        self.backward_button.setToolTip("Step backwards: Step x Multiplier")
        self.backward_button.setIcon(self.style().standardIcon(QStyle.SP_MediaSeekBackward))
        self.backward_button.clicked.connect(self.backward_clicked.emit)
        layout.addWidget(self.backward_button)

        self.forward_button = QPushButton()
        self.forward_button.setToolTip("Step forwards: Step x Multiplier")
        self.forward_button.setIcon(self.style().standardIcon(QStyle.SP_MediaSeekForward))
        self.forward_button.clicked.connect(self.forward_clicked.emit)
        layout.addWidget(self.forward_button)

        self.hour_edit = QLineEdit("00")
        self.hour_edit.setVisible(False)
        self.hour_edit.setValidator(QRegularExpressionValidator(QRegularExpression("^[0-9]{2}$")))
        layout.addWidget(self.hour_edit)

        self.min_edit = QLineEdit("00")
        self.min_edit.setVisible(False)
        self.min_edit.setValidator(QRegularExpressionValidator(QRegularExpression("^[0-5]\\d$")))
        layout.addWidget(self.min_edit)

        self.sec_edit = QLineEdit("00")
        self.sec_edit.setVisible(False)
        self.sec_edit.setValidator(QRegularExpressionValidator(QRegularExpression("^[0-5]\\d$")))
        layout.addWidget(self.sec_edit)

        self.time_btn = QPushButton("SetTime")
        self.time_btn.setToolTip("Jump to video time")

        self.time_btn.setFixedWidth(60)
        self.time_btn.clicked.connect(self._on_time_btn_clicked)
        layout.addWidget(self.time_btn)
        
        self._current_h = 0
        self._current_m = 0
        self._current_s = 0
        
        
       
        

        self.markB_button = QPushButton("[-")
        self.markB_button.setToolTip("Mark the Begin of the Cut")
        self.markB_button.setFixedWidth(40)
        self.markB_button.clicked.connect(self._on_markB_clicked)
        layout.addWidget(self.markB_button)

        self.markE_button = QPushButton("-]") 
        self.markE_button.setToolTip("Mark the End of the Cut")
        self.markE_button.setFixedWidth(40)
        self.markE_button.clicked.connect(self._on_markE_clicked)
        layout.addWidget(self.markE_button)
        
        self.clear_button = QPushButton("x")
        self.clear_button.setToolTip("Deselect the marked Area")
        self.clear_button.setFixedWidth(30)
        self.clear_button.clicked.connect(self.markClearClicked.emit)
        layout.addWidget(self.clear_button)

        self.cut_button = QPushButton("cut")
        self.cut_button.setToolTip("Cut the marked Area \nChoose AutoCutVideo+GPX in the config to cut the GPX-Area too")
        self.cut_button.setFixedWidth(40)
        self.cut_button.clicked.connect(self.cutClicked.emit)
        layout.addWidget(self.cut_button)
        
        
                
        self.set_begin_button = QPushButton("<B")
        self.set_begin_button.setToolTip("Cut the Begin of the Video and/or the GPX")
        self.set_begin_button.setFixedWidth(40)
        self.set_begin_button.clicked.connect(self.set_beginClicked.emit)
        layout.addWidget(self.set_begin_button)
        
        
        self.set_begin_button.setStyleSheet(
        """
        QPushButton {
            background-color: #C0392B;
            color: white;
            
        }
        QPushButton:hover {
            background-color: #E74C3C;
            color: black;
        }
        """
        )
        
        self.go_to_end_button = QPushButton(">E")
        self.go_to_end_button.setToolTip("Cut the End of the Video and the GPX\nSet first a markB")
        self.go_to_end_button.setFixedWidth(40)
        
        self.go_to_end_button.clicked.connect(self.goToEndClicked.emit)
        layout.addWidget(self.go_to_end_button)
        
        
        
        self.go_to_end_button.setStyleSheet(
        """
        QPushButton {
            background-color: #C0392B;
            color: white;
            
        }
        QPushButton:hover {
            background-color: #E74C3C;
            color: black;
        }
        """
        )

            
        
        
        
        self.undo_button = QPushButton("Undo")
        self.undo_button.setFixedWidth(45)
        self.undo_button.clicked.connect(self.undoClicked.emit)
        layout.addWidget(self.undo_button)

        self.sync_button = QPushButton("GSync")
        self.sync_button.setToolTip("Show the corresponding GPX-Point")
        self.sync_button.setFixedWidth(45)
        self.sync_button.clicked.connect(self.syncClicked.emit)
        layout.addWidget(self.sync_button)

        self.safe_button = QPushButton()
        self.safe_button.setFixedWidth(45)
        self.safe_button.setIcon(
            self.style().standardIcon(QStyle.SP_DriveHDIcon)
        )
        self.safe_button.clicked.connect(self.safeClicked.emit)
        layout.addWidget(self.safe_button)

        layout.addStretch()
        
    
    def set_editing_mode(self, enabled: bool):
        """
        Schaltet Buttons wie MarkB, MarkE, Clear, Cut, etc. an oder aus.
        """
        self.markB_button.setVisible(enabled)
        self.markE_button.setVisible(enabled)
        self.clear_button.setVisible(enabled)
        self.cut_button.setVisible(enabled)
        
        self.go_to_end_button.setVisible(enabled)
        self.undo_button.setVisible(enabled)
        


    def _on_markB_clicked(self):
        # 1) erst Sync-Funktion aufrufen:
        #self.syncClicked.emit()
        # 2) danach das 'eigentliche' MarkB-Signal:
        self.markBClicked.emit()

    def _on_markE_clicked(self):
        # 1) erst Sync-Funktion aufrufen:
        #self.syncClicked.emit()
        # 2) danach das 'eigentliche' MarkE-Signal:
        self.markEClicked.emit()    

    def update_play_pause_icon(self, is_playing):
        if is_playing:
            self.play_pause_button.setIcon(
                self.style().standardIcon(QStyle.SP_MediaPause)
            )
        else:
            self.play_pause_button.setIcon(
                self.style().standardIcon(QStyle.SP_MediaPlay)
            )

    def on_step_button_clicked(self):
        self._step_index = (self._step_index + 1) % len(self._step_values)
        new_value = self._step_values[self._step_index]
        self.step_button.setText(new_value)
        self.step_value_changed.emit(new_value)

    def on_multiplier_button_clicked(self):
        self._multiplier_index = (self._multiplier_index + 1) % len(self._multiplier_values)
        new_value = self._multiplier_values[self._multiplier_index]
        self.multiplier_button.setText(new_value)
        self.multiplier_value_changed.emit(new_value)
    
    def set_hms_time(self, hh: int, mm: int, ss: int):
        self._current_h = hh
        self._current_m = mm
        self._current_s = ss    
        
    def _on_time_btn_clicked(self):
        """
        Beim Klick auf "SetTime"-Button ein Popup öffnen,
        das mit (self._current_h, _current_m, _current_s) vorbelegt ist.
        """
        dlg = QDialog(self)
        dlg.setWindowTitle("Set Time")

        vbox = QVBoxLayout(dlg)
        row = QHBoxLayout()

        # Vorbelegung mit unseren internen h,m,s
        hh_str = f"{self._current_h:02d}"
        mm_str = f"{self._current_m:02d}"
        ss_str = f"{self._current_s:02d}"

        popup_h = QLineEdit(hh_str, dlg)
        popup_h.setFixedWidth(25)
        popup_h.setMaxLength(2)
        popup_h.setValidator(QRegularExpressionValidator(QRegularExpression("^[0-9]{2}$")))

        popup_m = QLineEdit(mm_str, dlg)
        popup_m.setFixedWidth(25)
        popup_m.setMaxLength(2)
        popup_m.setValidator(QRegularExpressionValidator(QRegularExpression("^[0-5]\\d$")))

        popup_s = QLineEdit(ss_str, dlg)
        popup_s.setFixedWidth(25)
        popup_s.setMaxLength(2)
        popup_s.setValidator(QRegularExpressionValidator(QRegularExpression("^[0-5]\\d$")))

        row.addWidget(popup_h)
        row.addWidget(QLabel(":", dlg))
        row.addWidget(popup_m)
        row.addWidget(QLabel(":", dlg))
        row.addWidget(popup_s)

        row_box = QHBoxLayout()
        row_box.addStretch()
        row_box.addLayout(row)
        row_box.addStretch()
        vbox.addLayout(row_box)

        # Buttons
        btn_box = QHBoxLayout()
        btn_box.addStretch()
        btn_set = QPushButton("Set", dlg)
        btn_set.clicked.connect(
            lambda: self._popup_accepted(dlg, popup_h, popup_m, popup_s)
        )
        btn_box.addWidget(btn_set)
        btn_box.addStretch()
        vbox.addLayout(btn_box)

        dlg.setModal(True)
        dlg.move(QCursor.pos())
        dlg.exec()    
    

    def _show_time_popup_at_cursor(self, hh_str: str, mm_str: str, ss_str: str):


        dlg = QDialog(self)
        dlg.setWindowTitle("Set time")

        vbox = QVBoxLayout(dlg)
        row = QHBoxLayout()
        popup_h = QLineEdit(hh_str, dlg)
        popup_h.setFixedWidth(25)
        popup_h.setMaxLength(2)
        popup_h.setValidator(QRegularExpressionValidator(QRegularExpression("^[0-9]{2}$"), popup_h))

        popup_m = QLineEdit(mm_str, dlg)
        popup_m.setFixedWidth(25)
        popup_m.setMaxLength(2)
        popup_m.setValidator(QRegularExpressionValidator(QRegularExpression("^[0-5]\\d$"), popup_m))

        popup_s = QLineEdit(ss_str, dlg)
        popup_s.setFixedWidth(25)
        popup_s.setMaxLength(2)
        popup_s.setValidator(QRegularExpressionValidator(QRegularExpression("^[0-5]\\d$"), popup_s))

        row.addWidget(popup_h)
        row.addWidget(QLabel(":", dlg))
        row.addWidget(popup_m)
        row.addWidget(QLabel(":", dlg))
        row.addWidget(popup_s)

        row_box = QHBoxLayout()
        row_box.addStretch()
        row_box.addLayout(row)
        row_box.addStretch()
        vbox.addLayout(row_box)

        btn_box = QHBoxLayout()
        btn_box.addStretch()
        btn_set = QPushButton("Set", dlg)
        btn_set.clicked.connect(
            lambda: self._popup_accepted(dlg, popup_h, popup_m, popup_s)
        )
        btn_box.addWidget(btn_set)
        btn_box.addStretch()
        vbox.addLayout(btn_box)

        dlg.setModal(True)
        dlg.move(QCursor.pos())
        dlg.exec()

    def _popup_accepted(self, dlg, edit_h, edit_m, edit_s):
        txtH = edit_h.text().strip()
        txtM = edit_m.text().strip()
        txtS = edit_s.text().strip()

        hh = int(txtH) if txtH.isdigit() else 0
        mm = int(txtM) if txtM.isdigit() else 0
        ss = int(txtS) if txtS.isdigit() else 0

        # Speichere es erneut (oder schicke ein Signal)
        self._current_h = hh
        self._current_m = mm
        self._current_s = ss

        # => Optional: Signal, wenn du das im MainWindow weiterverarbeiten willst
        self.timeHMSSetClicked.emit(hh, mm, ss)

        dlg.close()

```
import platform
import mpv
import math

from PySide6.QtWidgets import (
    QWidget, QGridLayout, QFrame, QLabel, QVBoxLayout
)
from PySide6.QtCore import Qt, QTimer, Signal

class VideoEditorWidget(QWidget):
    """
    Ein mpv-basierter Video-Player, der die alten Methoden (show_first_frame_at_index,
    set_playback_rate, etc.) bereitstellt, damit dein restlicher Code weiter funktioniert.
    Er kann mehrere Videos in die mpv-Playlist laden und nacheinander abspielen.
    
    Ob du 'end-file' auswertest, liegt bei dir. Siehe _on_mpv_event(...).
    """

    play_ended = Signal()  # z.B. wenn das letzte Video fertig ist

    def __init__(self, parent=None):
        super().__init__(parent)
        self._cut_intervals = []
    
        self._time_mode = "global"  # default
        self._final_time_callback = None   # optional
        
        # Haupt-Layout
        layout = QGridLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)

        # Ein Frame als Video-Anzeige
        self.video_frame = QFrame(self)
        self.video_frame.setStyleSheet("background:black;")
        layout.addWidget(self.video_frame, 0, 0)
        layout.setRowStretch(0, 1)
        layout.setColumnStretch(0, 1)

        # Oben Rechts: Speed-Label
        self.speed_label = QLabel("", self)
        self.speed_label.setStyleSheet("color:white; background-color:rgba(0,0,0,120); padding:2px;")
        self.speed_label.hide()
        layout.addWidget(self.speed_label, 0, 0, alignment=Qt.AlignTop | Qt.AlignRight)

        # Oben Rechts: Aktuelle Zeit
        self.current_time_widget = QWidget(self)
        vbox_time = QVBoxLayout(self.current_time_widget)
        vbox_time.setContentsMargins(0,20,0,0)
        vbox_time.setSpacing(0)
        vbox_time.setAlignment(Qt.AlignTop | Qt.AlignRight)

        self.current_time_label = QLabel("", self.current_time_widget)
        self.current_time_label.setTextFormat(Qt.RichText)
        self.current_time_label.setStyleSheet(
            "background-color:rgba(0,0,0,120); color: yellow; font-size:16px;"
            "padding:2px;"
        )
        vbox_time.addWidget(self.current_time_label)
        layout.addWidget(self.current_time_widget, 0, 0, alignment=Qt.AlignTop | Qt.AlignRight)

        # Extra: Edit-Status
        self.edit_status_widget = QWidget(self)
        self.edit_status_widget.setMaximumWidth(65)

        vbox_edit = QVBoxLayout(self.edit_status_widget)
        vbox_edit.setContentsMargins(0, 50, 0, 0)
        vbox_edit.setSpacing(0)

        self.edit_status_label = QLabel("", self.edit_status_widget)
        self.acut_status_label = QLabel("", self.edit_status_widget)
        vbox_edit.addWidget(self.edit_status_label)
        vbox_edit.addWidget(self.acut_status_label)
        layout.addWidget(self.edit_status_widget, 0, 0, alignment=Qt.AlignTop | Qt.AlignRight)

        # Unten Links: total_length + cut_time
        self.right_time_widget = QWidget(self)
        vbox_right_time = QVBoxLayout(self.right_time_widget)
        vbox_right_time.setContentsMargins(0,0,0,0)
        vbox_right_time.setSpacing(0)
        vbox_right_time.setAlignment(Qt.AlignRight)

        self.total_length_label = QLabel("", self.right_time_widget)
        self.total_length_label.setStyleSheet("color:white; padding-left:5px;")
        vbox_right_time.addWidget(self.total_length_label)

        self.cut_time_label = QLabel("", self.right_time_widget)
        self.cut_time_label.setStyleSheet("color:red; padding-left:5px;")
        vbox_right_time.addWidget(self.cut_time_label)
        self.cut_time_label.hide()

        layout.addWidget(self.right_time_widget, 0, 0, alignment=Qt.AlignBottom | Qt.AlignLeft)

        # MPV Setup
        self._player = mpv.MPV(
            wid=str(int(self.video_frame.winId())),
            log_handler=self._mpv_log_handler,
            hr_seek="yes",
            hr_seek_framedrop="yes",
            loglevel='info',
        )
        # Fenstereinstellungen, damit wir (fast) nie Schwarz flackern
        self._player["force-window"] = "immediate"
        self._player["keep-open"] = "yes"

        # Start = paused
        self._player.pause = True
        self._player.volume = 50

        self.is_playing = False
        self.playlist = []
        self._current_index = 0
        self.multi_durations = []
        self.boundaries = []

        # Falls du end-file auswerten willst:
        # (Wenn du python-mpv >= 0.5.2 hast, geht so:)
        self._player.observe_property('playlist-pos', self._on_playlist_pos_changed)
        # oder mit self._player.register_event_callback(...) + Auswertung event.event_id ?

        # Du kannst z. B. die Zeitanzeige in einer Timer-Schleife updaten
        self._time_timer = QTimer(self)
        self._time_timer.timeout.connect(self._update_time_label)
        self._time_timer.start(200)  # alle 200ms

    # -----------------------------------------
    # ALTE METHODEN (Schnittstellen), die dein restlicher Code aufruft
    # -----------------------------------------
    
    def set_cut_intervals(self, intervals):
        """
        Speichert eine Liste von (start_s, end_s)-Schnittbereichen.
        Beispiel: [(0.0, 12.5), (80.0, 85.2)]
        """
        if not intervals:
            self._cut_intervals = []
        else:
            self._cut_intervals = intervals
    
    def _get_cut_end_if_zero(self) -> float:
        """
        Falls in self._cut_intervals ein Bereich [0..end] existiert,
        gib end zurück. Sonst 0.0.
        Wir suchen das größte 'end', bei dem start quasi 0 ist.
        """
        max_cut_end = 0.0
        for (start_s, end_s) in self._cut_intervals:
            # Prüfen, ob der Schnitt (start_s..end_s) wirklich
            # am absoluten Anfang ansetzt (z.B. <= 0.001)
            if abs(start_s) < 0.001:
                if end_s > max_cut_end:
                    max_cut_end = end_s
        return max_cut_end    
            
            
    def set_time_mode(self, mode: str):
        self._time_mode = mode    
        
    def set_final_time_callback(self, func):
        """func soll sein: func(global_s) -> final_s"""
        self._final_time_callback = func    
        

    def show_first_frame_at_index(self, index: int):
        """
        Gehe zum playlist-Index 'index', pausiere + seek an den Anfang => 1. Frame
        """
        if not self.playlist or index < 0 or index >= len(self.playlist):
            return  # Ungültig => Abbruch

        self.is_playing = False
    
        # => mpv springt zu Clip 'index'
        self._player.command("playlist-play-index", str(index))
    
        def do_seek():
            # 1) Prüfen, ob mpv noch ein Video hat + Position >=0
            if self._player.playlist_count == 0:
                return
            if self._player.playlist_pos is None or self._player.playlist_pos < 0:
                return

            # 2) Seek an 0s
            try:
                self._player.command("seek", "0", "absolute", "exact")
                self._player.pause = True
                self.is_playing = False
            except SystemError as e:
                # -12 bedeutet oft, dass mpv in Idle ist oder “keine Datei mehr hat”
                print(f"[WARN] show_first_frame: mpv refused to seek => {e}")

        QTimer.singleShot(80, do_seek)

    def set_playback_rate(self, rate: float):
        self._player.speed = rate
        self._show_speed_label(f"Speed: {rate:.2f}x")

    def _show_speed_label(self, txt: str):
        self.speed_label.setText(txt)
        self.speed_label.show()
        QTimer.singleShot(2000, self.speed_label.hide)

    def set_total_length(self, total_s: float):
        # z. B. Summe aller Videos
        txt = self.format_seconds_simple(total_s)
        self.total_length_label.setText(txt)

    def set_old_time(self, old_s: float):
        """
        Falls dein Code hierhin ruft (historische Funktion).
        Man kann z. B. `old_s` = summe aller Video-Längen *vor* dem Cut?
        """
        txt = self.format_seconds_simple(old_s)
        self.total_length_label.setText(txt)

    def set_cut_time(self, cut_s: float):
        if cut_s > 0:
            self.cut_time_label.setText(self.format_seconds_simple(cut_s))
            self.cut_time_label.show()
        else:
            self.cut_time_label.setText("")
            self.cut_time_label.hide()

    def format_seconds_simple(self, secs: float) -> str:
        """z. B. 74.2 => '00:01:14' (ohne ms)"""
        s_rounded = round(secs)
        hh = s_rounded // 3600
        mm = (s_rounded % 3600) // 60
        ss = s_rounded % 60
        return f"<span style='font-size:14px;'>{hh:02d}:{mm:02d}:{ss:02d}</span>"

    def format_seconds_html(self, secs: float) -> str:
        """z. B. 12.345 => '00:00:12.<ms=345>' in HTML-Font-Styles."""
        
        base = int(math.floor(secs))
        fraction = secs - base
        ms = int(round(fraction * 1000))
        if ms == 1000:
            base += 1
            ms = 0
        hh = base // 3600
        mm = (base % 3600) // 60
        ss = base % 60

        return (
            f"<span style='font-size:16px;'>"
            f"{hh:02d}:{mm:02d}:{ss:02d}"
            "</span>"
            f".<span style='font-size:10px;'>{ms:03d}</span>"
        )

    def set_current_time(self, secs: float):
        """
        Wird evtl. aufgerufen, wenn Timeline den Schieberegler setzt und wir
        nur das UI-Label anpassen wollen. (Oder optional -> self._player.seek())
        """
        # => wir machen hier NUR Label:
        text_html = self.format_seconds_html(secs)
        self.current_time_label.setTextFormat(Qt.RichText)
        self.current_time_label.setText(text_html)

    def play_pause(self):
        if self.is_playing:
            self._player.pause = True
            self.is_playing = False
        else:
            self._player.pause = False
            self.is_playing = True



    def get_current_position_s(self) -> float:
        """
        Gibt die *globale* Zeit (in Sekunden) über alle Clips zurück.
        Ruft intern get_current_global_time() auf.
        """
        return self.get_current_global_time()

    def get_current_index(self) -> int:
        """Ablösung für dein altes self._current_index => mpv.playlist_pos."""
        pos = self._player.playlist_pos
        if pos is None or pos < 0:
            return -1
        return pos

    def set_time(self, new_s: float):
        """
        Globaler Sprung in der gesamten Playlist:
        Rechnet new_s => clipIndex + local_s und ruft 'playlist-play-index' + 'seek' auf.
        """
        self._jump_to_global_time(new_s)

    def frame_step_forward(self):
        self._player.command("frame-step")

    def frame_step_backward(self):
        self._player.command("frame-step", -1)

    # -----------------------------------------
    # Playlist-Funktionen
    # -----------------------------------------
    def set_multi_durations(self, durations_list):
        """z.B. [60.0, 90.0] => 2 Videos => sum=150 => boundaries=[60,150]."""
        self.multi_durations = durations_list or []
        self.boundaries = []
        accum = 0.0
        for d in self.multi_durations:
            accum += d
            self.boundaries.append(accum)

    def set_playlist(self, video_list):
        """Erzeugt mpv-Playlist per 'append-play'."""
        self._player.command("playlist-clear")
        if not video_list:
            self.playlist = []
            return
        # Erstes normal load
        self._player.command("loadfile", video_list[0])
        # Rest => append
        for path in video_list[1:]:
            self._player.command("loadfile", path, "append-play")

        # Start paused
        self._player.pause = True
        self.is_playing = False

        self.playlist = video_list

    def _jump_to_global_time(self, wanted_s: float):
        """
        'wanted_s' ist die globale Zeit über alle Clips.
        Wir ermitteln clipIndex + local_s.
        Nur wenn der clipIndex sich tatsächlich ändert, machen wir
        playlist-play-index + 80ms Delay. Sonst: direkt seek.
        """
        if not self.boundaries:
            return

        total = self.boundaries[-1]
        if wanted_s < 0:
            wanted_s = 0.0
        elif wanted_s > total:
            wanted_s = total

        # ClipIndex suchen
        clip_idx = 0
        offset_prev = 0.0
        for i, bound_val in enumerate(self.boundaries):
            if wanted_s < bound_val:
                clip_idx = i
                break
            offset_prev = bound_val
    
        local_s = wanted_s - offset_prev
        if local_s < 0:
            local_s = 0

        # Aktueller mpv-Playlist-Index:
        current_idx = self._player.playlist_pos

        if current_idx == clip_idx:
            # 1) GLEICHER CLIP => kein Delay, kein playlist-play-index
            try:
                self._player.command("seek", f"{local_s}", "absolute", "exact")
                self._player.pause = True
                self.is_playing = False
            except SystemError as e:
                print(f"[WARN] _jump_to_global_time: mpv refused to seek => {e}")
        else:
            # 2) CLIP WECHSEL => playlist-play-index + kleiner Delay
            self._player.command("playlist-play-index", str(clip_idx))

            def do_seek():
                if self._player.playlist_count == 0:
                    return
                if self._player.playlist_pos is None or self._player.playlist_pos < 0:
                    return
                try:
                    self._player.command("seek", f"{local_s}", "absolute", "exact")
                    self._player.pause = True
                    self.is_playing = False
                except SystemError as e:
                    print(f"[WARN] _jump_to_global_time: mpv refused to seek => {e}")

            QTimer.singleShot(80, do_seek)


    

    # -----------------------------------------
    # mpv Event-Handling
    # -----------------------------------------

    def _on_playlist_pos_changed(self, name, value):
        """
        mpv ruft diese Callback auf, sobald 'playlist-pos' wechselt.
        Falls wir am Ende sind, pos=None. Dann => play_ended-Signal?
        """
        if value is None or value < 0:
            # => wir sind evtl. am Ende der Playlist
            self.play_ended.emit()

    # optionales Log
    def _mpv_log_handler(self, level, component, message):
        print(f"[MPV] {level} {component}: {message}", end="")
    
    def _update_time_label(self):
        if not self.playlist or self._player.playlist_count == 0:
            self.current_time_label.hide()
            return
        else:
            self.current_time_label.show()
            
        

        # 1) globale Sekunde
        global_s = self.get_current_global_time()

        # 2) falls "global" => zeige global_s
        #    falls "final"  => rufe callback auf
        if self._time_mode == "final" and self._final_time_callback:
            show_s = self._final_time_callback(global_s)
        else:
            show_s = global_s

        text_html = self.format_seconds_html(show_s)
        self.current_time_label.setText(text_html)

    def stop(self):
        """
        Wenn am Anfang ein Schnitt [0..X] existiert, springen wir an X,
        ansonsten an 0s des ersten Videos.
        """
        if not self.playlist:
            return
    
        # (1) Prüfe, ob wir [0..cutX] haben
        cut0_end = self._get_cut_end_if_zero()

        if cut0_end > 0.001:
            # => wir haben einen Schnitt am Anfang => an cut0_end springen
            self._jump_to_global_time(cut0_end)
        
            # Danach Pause + is_playing = False
            self._player.pause = True
            self.is_playing = False

        else:
            # => kein Schnitt am Anfang => normaler Sprung an Clip=0, 0s
            self._player.command("playlist-play-index", "0")

            def do_seek_zero():
                if self._player.playlist_count == 0:
                    return
                if self._player.playlist_pos is None or self._player.playlist_pos < 0:
                    return
            
                try:
                    self._player.command("seek", "0", "absolute", "exact")
                    self._player.pause = True
                    self.is_playing = False
                except SystemError as e:
                    print(f"[WARN] stop(): mpv refused to seek => {e}")
        
            QTimer.singleShot(50, do_seek_zero)

        
        
    def get_current_global_time(self) -> float:
        """
        Gibt die 'globale' Zeit (in Sekunden) über alle Clips zurück.
        Beispiel: wenn wir im 2. Clip sind, der erste Clip war 60s lang 
        und im 2. Clip sind wir gerade bei Sekunde 10 => Rückgabe = 70.
        """
        clipIndex = self._player.playlist_pos  # python-mpv property
        local_s   = self._player.time_pos or 0.0
        if clipIndex is None or clipIndex < 0:
            return 0.0

        # offset_prev = boundaries[clipIndex - 1] (0.0 wenn clipIndex==0)
        if clipIndex == 0:
            offset_prev = 0.0
        else:
            offset_prev = self.boundaries[clipIndex - 1]
    
        return offset_prev + local_s    
```
# widgets/video_timeline_widget.py
import math

from PySide6.QtWidgets import QWidget
from PySide6.QtCore import Qt, QPoint, Signal
from PySide6.QtGui import QPainter, QPen, QBrush, QColor, QPolygon, QWheelEvent

def _nice_number(value: float) -> float:
    
    if value <= 0:
        return 1.0
    exp = math.floor(math.log10(value))
    f = value / (10 ** exp)
    if f < 2:
        nf = 1
    elif f < 5:
        nf = 2
    elif f < 10:
        nf = 5
    else:
        nf = 10
    return nf * (10 ** exp)

class VideoTimelineWidget(QWidget):
    markerMoved = Signal(float)

    def __init__(self, parent=None):
        super().__init__(parent)
        self.total_duration = 0.0
        self._marker_position_s = 0.0
        self.boundaries = []
        self.markB_time_s = -1.0
        self.markE_time_s = -1.0
        self._cut_intervals = []
        self._dragging_marker = False
        self._dragging_timeline = False
        self._timeline_drag_start_x = 0
        self._horizontal_offset_start = 0
        self._marker_screen_x_at_drag_start = 0
        self._zoom_factor = 1.0
        self._min_zoom = 1.0
        self._max_zoom = 50.0
        self._horizontal_offset = 0
        self._scroll_speed_px = 50
        self.setStyleSheet("background-color: #333333;")

    def set_marker_position(self, time_s: float):
        if self.total_duration <= 0:
            self._marker_position_s = 0.0
            return
        if time_s < 0:
            time_s = 0
        if time_s > self.total_duration:
            time_s = self.total_duration
        self._marker_position_s = time_s
        self._keep_marker_visible()
        self.update()

    def marker_position(self) -> float:
        return self._marker_position_s

    def _update_marker_by_mouse_x(self, x_mouse: int):
        w = self.width()
        if w <= 0 or self.total_duration <= 0:
            return
        timeline_real_width = w * self._zoom_factor
        x_timeline = x_mouse + self._horizontal_offset
        if x_timeline < 0:
            x_timeline = 0
        if x_timeline > timeline_real_width:
            x_timeline = timeline_real_width
        ratio = x_timeline / timeline_real_width if timeline_real_width > 0 else 0.0
        new_time_s = ratio * self.total_duration
        self.set_marker_position(new_time_s)
        self.markerMoved.emit(new_time_s)

    def _keep_marker_visible(self):
        w = self.width()
        if w <= 0 or self.total_duration <= 0:
            return
        timeline_real_width = w * self._zoom_factor
        ratio = self._marker_position_s / self.total_duration
        marker_x = ratio * timeline_real_width - self._horizontal_offset
        if marker_x < 0:
            self._horizontal_offset = ratio * timeline_real_width
            if self._horizontal_offset < 0:
                self._horizontal_offset = 0
            return
        right_threshold = 0.95 * w
        left_position = 0.05 * w
        if marker_x > right_threshold:
            if ratio < 0.95:
                shift = marker_x - left_position
                self._horizontal_offset += shift
                if self._horizontal_offset < 0:
                    self._horizontal_offset = 0

    def set_total_duration(self, dur_s: float):
        self.total_duration = max(0.0, dur_s)
        if self._marker_position_s > self.total_duration:
            self._marker_position_s = self.total_duration
        self._keep_marker_visible()
        self.update()

    def set_boundaries(self, boundary_list):
        self.boundaries = boundary_list
        self.update()

    def set_markB_time(self, time_s: float):
        self.markB_time_s = time_s
        self.update()

    def set_markE_time(self, time_s: float):
        self.markE_time_s = time_s
        self.update()

    def add_cut_interval(self, start_s: float, end_s: float):
        self._cut_intervals.append((start_s, end_s))
        self.update()

    def remove_last_cut_interval(self):
        if self._cut_intervals:
            self._cut_intervals.pop()
            self.update()

    def mousePressEvent(self, event):
        if event.button() == Qt.LeftButton:
            self._dragging_marker = True
            self._update_marker_by_mouse_x(event.pos().x())
            event.accept()
        elif event.button() == Qt.RightButton:
            self._dragging_timeline = True
            self._timeline_drag_start_x = event.pos().x()
            self._horizontal_offset_start = self._horizontal_offset
            w = self.width()
            if w > 0 and self.total_duration > 0:
                timeline_real_width = w * self._zoom_factor
                marker_x_current = (self._marker_position_s / self.total_duration)*timeline_real_width - self._horizontal_offset
                self._marker_screen_x_at_drag_start = marker_x_current
            else:
                self._marker_screen_x_at_drag_start = 0
            event.accept()
        else:
            event.ignore()

    def mouseMoveEvent(self, event):
        if self._dragging_marker:
            self._update_marker_by_mouse_x(event.pos().x())
            event.accept()
        elif self._dragging_timeline:
            delta_x = event.pos().x() - self._timeline_drag_start_x
            self._horizontal_offset = self._horizontal_offset_start - delta_x
            w = self.width()
            if w > 0 and self.total_duration > 0:
                timeline_real_width = w * self._zoom_factor
                new_marker_x_abs = self._marker_screen_x_at_drag_start + self._horizontal_offset
                ratio = new_marker_x_abs / timeline_real_width
                if ratio < 0:
                    ratio = 0
                elif ratio > 1:
                    ratio = 1
                new_time_s = ratio * self.total_duration
                self._marker_position_s = new_time_s
                self.markerMoved.emit(new_time_s)
            self.update()
            event.accept()
        else:
            event.ignore()

    def mouseReleaseEvent(self, event):
        if event.button() == Qt.LeftButton and self._dragging_marker:
            self._dragging_marker = False
            event.accept()
        elif event.button() == Qt.RightButton and self._dragging_timeline:
            self._dragging_timeline = False
            event.accept()
        else:
            event.ignore()

    def wheelEvent(self, event: QWheelEvent):
        delta = event.angleDelta().y()
        if delta == 0:
            super().wheelEvent(event)
            return
        if event.modifiers() & Qt.ShiftModifier:
            if delta > 0:
                self._horizontal_offset = max(0, self._horizontal_offset - self._scroll_speed_px)
            else:
                self._horizontal_offset += self._scroll_speed_px
            self._keep_marker_visible()
            self.update()
            event.accept()
            return
        if event.modifiers() & Qt.ControlModifier:
            factor = 1.1 if delta > 0 else (1.0 / 1.1)
            new_zoom = self._zoom_factor * factor
            if new_zoom < self._min_zoom:
                new_zoom = self._min_zoom
            if new_zoom > self._max_zoom:
                new_zoom = self._max_zoom
            self._zoom_factor = new_zoom
            self._center_marker_at_ratio(0.3)
            self.update()
            event.accept()
            return
        super().wheelEvent(event)

    def _center_marker_at_ratio(self, widget_ratio: float):
        w = self.width()
        if w <= 0 or self.total_duration <= 0:
            return
        timeline_real_width = w * self._zoom_factor
        marker_x_absolute = (self._marker_position_s / self.total_duration)*timeline_real_width
        desired_x_in_widget = widget_ratio * w
        self._horizontal_offset = marker_x_absolute - desired_x_in_widget
        if self._horizontal_offset < 0:
            self._horizontal_offset = 0

    def paintEvent(self, event):
        from PySide6.QtGui import QPainter, QPen, QBrush, QPolygon
        from PySide6.QtCore import QPoint

        painter = QPainter(self)
        painter.setRenderHint(QPainter.Antialiasing, True)

        rect_ = self.rect()
        w = rect_.width()
        h = rect_.height()
        painter.fillRect(rect_, QColor("#333333"))
        painter.setClipRect(rect_)

        timeline_real_width = w * self._zoom_factor
        self._draw_time_ticks(painter, w, h, timeline_real_width)
        self._draw_boundaries_and_markers(painter, w, h, timeline_real_width)

    def _draw_time_ticks(self, painter, w, h, timeline_real_width):
        if self.total_duration <= 0 or timeline_real_width <= 0:
            return
        desired_px_between_major_ticks = 100.0
        num_subticks = 4
        px_per_sec = timeline_real_width / self.total_duration
        raw_step_sec = desired_px_between_major_ticks / px_per_sec
        step_sec = _nice_number(raw_step_sec)
        sub_tick_sec = step_sec / (num_subticks + 1)

        from PySide6.QtGui import QPen
        pen_major = QPen(QColor("#CCCCCC"), 2)
        pen_minor = QPen(QColor("#AAAAAA"), 1)

        main_tick_height = 10
        sub_tick_height  = 6
        text_offset_y = h - main_tick_height - 3
        end_time = self.total_duration
        t = 0.0
        while t <= end_time + 0.0001:
            x_timeline = (t * px_per_sec) - self._horizontal_offset
            if -50 < x_timeline < w + 50:
                index_float = t / step_sec
                is_major = abs(index_float - round(index_float)) < 0.001
                if is_major:
                    painter.setPen(pen_major)
                    y_start = h - main_tick_height
                    painter.drawLine(x_timeline, y_start, x_timeline, h)
                    mm = int(t // 60)
                    ss = int(t % 60)
                    time_label = f"{mm:02d}:{ss:02d}"
                    painter.drawText(x_timeline - 15, text_offset_y, time_label)
                else:
                    painter.setPen(pen_minor)
                    y_start = h - sub_tick_height
                    painter.drawLine(x_timeline, y_start, x_timeline, h)
            t += sub_tick_sec

    def _draw_boundaries_and_markers(self, painter, w, h, timeline_real_width):
        from PySide6.QtGui import QPen, QBrush, QPolygon
        pen_blue = QPen(QColor("blue"), 3)
        painter.setPen(pen_blue)
        painter.setBrush(Qt.NoBrush)
        if self.total_duration > 0:
            for b_sec in self.boundaries:
                if 0 < b_sec < self.total_duration:
                    ratio_b = b_sec / self.total_duration
                    x_b = ratio_b*timeline_real_width - self._horizontal_offset
                    if -50 < x_b < w+50:
                        painter.drawLine(x_b, 0, x_b, h)

        pen_marker = QPen(QColor("white"), 2)
        painter.setPen(pen_marker)
        painter.setBrush(QBrush(QColor("white")))
        if self.total_duration > 0:
            ratio = self._marker_position_s / self.total_duration
            marker_x = ratio*timeline_real_width - self._horizontal_offset
            if -50 < marker_x < w+50:
                painter.drawLine(marker_x, 0, marker_x, h)
                arrow_height = 10
                arrow_half = 6
                arrow_points = [
                    QPoint(marker_x - arrow_half, 0),
                    QPoint(marker_x + arrow_half, 0),
                    QPoint(marker_x, arrow_height),
                ]
                painter.drawPolygon(QPolygon(arrow_points))

        pen_yellow = QPen(QColor("yellow"), 2)
        painter.setPen(pen_yellow)
        painter.setBrush(Qt.NoBrush)
        xB = xE = -1
        if 0 <= self.markB_time_s <= self.total_duration:
            xB = (self.markB_time_s/self.total_duration)*timeline_real_width - self._horizontal_offset
            if -50 < xB < w+50:
                painter.drawLine(xB, 0, xB, h)

        if 0 <= self.markE_time_s <= self.total_duration:
            xE = (self.markE_time_s/self.total_duration)*timeline_real_width - self._horizontal_offset
            if -50 < xE < w+50:
                painter.drawLine(xE, 0, xE, h)

        if xB >= 0 and xE >= 0:
            left_x = min(xB, xE)
            right_x = max(xB, xE)
            if right_x > left_x:
                brush_yellow = QBrush(QColor(255,255,0,80))
                painter.fillRect(left_x, 0, right_x-left_x, h, brush_yellow)

        brush_black = QBrush(QColor(0, 0, 0, 150))
        pen_black = QPen(QColor("black"), 1)
        painter.setPen(pen_black)
        for (start_s, end_s) in self._cut_intervals:
            if start_s < 0 or end_s <= 0 or self.total_duration <= 0:
                continue
            start_ratio = max(0.0, start_s/self.total_duration)
            end_ratio   = min(1.0, end_s/self.total_duration)
            if end_ratio <= start_ratio:
                continue
            x_start = start_ratio*timeline_real_width - self._horizontal_offset
            x_end   = end_ratio*timeline_real_width - self._horizontal_offset
            if x_end < -50 or x_start > w+50:
                continue
            rect_width = x_end - x_start
            if rect_width < 1:
                rect_width = 1
            painter.fillRect(x_start, 0, rect_width, h, brush_black)

```
